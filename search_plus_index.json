{"./":{"url":"./","title":"Linux宝典","keywords":"","body":"Linux宝典 01.linux基本操作使用 02.linux获取命令使用帮助 03.linux常用基础命令 04.根文件系统 05.Linux系统上的文件类型和历史命令 06.目录文本查看命令 07.文件管理命令 08.glob通配及IO重定向 09.用户和组管理概念 10.用户和组管理命令 11.用户权限管理 12.shell变量,算数和逻辑运算及配置文件 13.grep和基本正则表达式 14.vim编辑器 15.文件查找find和特殊权限及facl 16.磁盘及文件系统管理 17.shell条件测试,逻辑判断,参数传递 18.RAID技术 19.LVM2 20.btrfs文件系统 21.压缩工具 22.Liunx任务计划crontab 23.软件包管理rpm 24.软件包管理yum 25.shell多分支if和for循环 26.文本处理神器sed 27.计算机网络基础 28.Linux网络属性配置 29.Linux进程及作业管理 30.Linux进程及作业管理二 31.网络客户端工具和while、untill循环 32.CentOS系统启动流程 33.grub系统配置与使用 34.Linux内核功能及模块应用 35.Linux内核模块功能定制 36.Linux自动化安装anaconda配置定制 37.Linux系统自动化安装无人值守环境配置部署 38.函数编程和case语句 39.systemd及systemctl实战 40.SELinux简介 41.shell数组和字符串处理工具 42.shell信号捕捉实战 43.awk使用与实践 44.通信加密和解密、公钥、私钥、CA 45.OpenSSL 46.DNS 47.DNS and Bind 48.http协议及Web服务 49.Apache 50.LAMP 51.MariaDB 52.php-fpm基础应用与实战 53.文件共享服务、ftp、vsftp 54.nfs服务配置应用与实战 55.samba服务基础应用 56.iptables 57.iptables网络防火墙 58.iptables_nat路由 59.Linux时间服务-chrony GitLab安装_CentOS7 JDK安装 Linux中kill -2和kill -9的区别 linux中修改环境变量及生效方法 Linux查看设置系统时区 rc.local脚本开机自启动 SSH免密登录 Systemd日志管理journal和journalctl使用 TCP_IP协议总结 TCP_UDP结构 VMware虚拟机克隆CentOS7并分别设置静态IP Vmware虚拟机问题解决方案 window下面git公钥的配置 文件描述符 最小化安装centos7.9 查看服务器状态工具 "},"pages/01.linux基本操作使用.html":{"url":"pages/01.linux基本操作使用.html","title":"01.linux基本操作使用","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 linux远程连接 查看所用shell的类型(注意大小写,linux所有包括命令都区分大小写) 查看本机ip ping iptables防火墙 CLI接口: 几个基础命令小结 linux目录命令 终端设备: terminal 多任务、多用户 物理终端,控制台:console 虚拟终端:6个,ttyCtrl+Alt+F[1-6] 图形终端:CentOS6: Ctrl+Alt+F7CentOS7: 在哪个虚拟终端启动,即位于哪个虚拟终端 串行终端: ttyS 伪终端: pty Linux的哲学思想之一:一切皆文件表现之一:硬件设备也通过文件表示物理终端:/dev/console虚拟终端:/dev/tty#[1-6]串行终端:/dev/tty5#伪终端:/dev/pts/# 注意:在启动设备之后,在其上关联一个用户接口程序,即可实现与用户交互查看终端设备: tty 查看接口程序: echo $SHELL 启动GUI 在某一虚拟终端接口运行命令:startx & &:代表在后台运行 linux远程连接 ssh协议:secure shell #该命令用于查看系统是否监听于tcp协议的22号端口 ss -tnl # ssh连接 ssh 192.168.147.139 ssh root@192.168.18.137 查看所用shell的类型(注意大小写,linux所有包括命令都区分大小写) echo $SHELL 查看本机ip ifconfig 或者 ip addr list ping ping 10.12.78.179 iptables防火墙 #CentOS7 #查看防火墙规则 iptables -L -n #清空防火墙规则,这种清理值对当前有效 iptables -F #CentOS7停止防火墙,这种清理值对当前有效 systemctl stop firewalld.service #禁用防火墙,开机不自启动 systemctl disable firewalld.service #CentOS6 #停止防火墙,这种清理值对当前有效 service iptables stop #禁用防火墙,开机不自启动 checkconfig iptables off CLI接口: 命令行接口: [root@node1 ~]# COMMAND　prompt:　　　root:当前登录用户　　　node1: 当前主机的主机名,非完整格式;此处完整格式为:node1.kecloud.com　　　~:用户当前所在的目录(current directory),也成为工作目录(working directory);相对路径;　　　#:命令提示符　　　#:管理员账号,为root;拥有最高权限,能执行所有操作　　　$:普通用户,非root用户;不具有管理权限,不能执行系统管理类操作;　　 几个基础命令小结 ```shell　　　 查看当前的终端设备 tty 查看活动接口的ip地址 ifconfig ip addr list ip addr show 回显 echo 探测网络的目标主机与当前主机之间的连通性 ping 终止命令行执行 Ctrl+c 关机命令 CentOS7: systemctl poweroff 重启 systemctl reboot 所有linux操作系统 关机 poweroff halt 重启 reboot ### linux目录命令 ```shell #basename:最右侧的文件或目录名 basename /etc/sysconfig/network-scripts/ifcfg-eno16777736 #dirname:basename左侧的路径 dirname /etc/sysconfig/network-scripts/ifcfg-eno16777736 "},"pages/02.linux获取命令使用帮助.html":{"url":"pages/02.linux获取命令使用帮助.html","title":"02.linux获取命令使用帮助","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 命令本身是一个可执行的程序文件:二进制格式的文件,有可能会调用共享库文件: 命令必须遵循特定格式规范：.exe,msi,ELF(linux) 命令分为两类 shell程序是独特的程序,负责解析用户提供的命令: 查看命令类型 type COMMAND: OPTIONS ARGUMENTS: 获取命令的使用帮助 G:跳转到指定行 info COMMAND 用于查看在线帮助文档 很多应用程序会自带帮助文档:/usr/share/doc/APP-VERSION TLDR帮助工具 centos最小安装的情况下,man帮助不全 命令的语法通用格式 COMMAND OPTIONS ARGUMENTS　发起一个命令:请求内核将某个二进制程序运行为一个进程:　　　　程序 --> 进程　　　　静态 --> 动态 (有生命周期) 命令本身是一个可执行的程序文件:二进制格式的文件,有可能会调用共享库文件: 　　多数系统程序文件都存放在: /bin,/sbin,/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin　　　　普通命令:/bin,/usr/bin,/usr/local/bin　　　　管理命令:/sbin,/usr/sbin,/usr/local/sbin　　共享库:/lib,/lib64,/usr/lib,/usr/lib64,/usr/local/lib,/usr/local/lib64　　　　32bits的库:/lib,/usr/lib,/usr/local/lib　　　　64bits的库:/lib64,/usr/lib64,/usr/local/lib64 　　　　注意:并非所有的命令都有一个在某目录与之对应的可执行文件 命令必须遵循特定格式规范：.exe,msi,ELF(linux) file /bin/ls 命令分为两类 由shell程序自带的命令:内置命令(builtin)独立的可执行程序文件,文件名既命令名:外部命令 shell程序是独特的程序,负责解析用户提供的命令: 环境变量:PATH:从哪些路径中查找用户键入的命令字符串所对应的命令文件,查询次序:自左而右: echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 查看命令类型 type COMMAND: type cd cd 是 shell 内嵌 type cat cat 是 /usr/bin/cat OPTIONS 指定命令的运行特性: 选项有两种表现形式:短选项:-C,例如-l,-d注意:有些命令的选项么有-;如果同一命令同时使用多个短选项,多数可合并: -l -d = -ld 长选项:--word,例如--help,--human-readable注意:长选项不能合并 注意:有些选项可以带参数,此称为选项参数 ARGUMENTS: 命令的作用对象:命令对什么生效之一:不同的命令参数,有些命令可以同时带多个参数,多个之间以空白字符分割例如:ls -ld /var /etc 获取命令的使用帮助 内置(嵌)命令:help COMMAND例如: #type命令是内内嵌命令 help type 外部命令:1.命令自带简要格式的使用帮助COMMAND --help 例如:ls --help2.使用手册:manual : man COMMAND手册文件在/usr/share/man/目录中 例如:man poweroffSECTION:NAME:功能性说明SYNOPSIS:语法格式DESCRIPTION:描述OPTIONS:选项EXAMPLES:使用示例AUTHOR:作者BUGS:报告程序bug的方式SEE ALSO:参考... SYNOPSIS:[]:可选内容<>:必须提供的内容a|b|c:多选一...:同类内容可出现多个,彼此间使用空白字符分隔 使用手册:压缩格式的文件,有章节之分: ls /usr/share/man main1:用户命令main2:系统调用main3:C库调用main4:设备文件及特殊文件main5:文件格式(配置文件格式)main6:游戏使用帮助main7:杂项main8:管理工具及守护进程 例如使用whatis passwd 可以看到命令passwd在手册的哪些章节中存在这样就可以通过man CHAPTER COMMAND来查看指定章节下的手册内容了 man 5 passwd man lssl passwd man 1 passwd man命令打开手册以后的操作方法:翻屏:空格键:向文件尾翻一屏b:向文件首部翻一屏Ctrl+d:向文件尾部翻半屏Ctrl+u:向文件首部翻半屏回车键:像文件尾部翻一行k:向文件首部翻一行G:跳转至最后一行 G:跳转到指定行 1G:跳转到文件首部文件搜索:/keyword:从文件首部向文件尾部依次查找:不区分字符大小写?keyword:从文件尾部向文件首部依次查找 /this ?token n:与查找命令方向相同N:与查找命令方向相反q:退出(quit)选项:-M /PATH/TO/SOMEDIR:到指定目录下查找命令手册并打开之练习:获取useradd命令的用法添加用户gentoo: useradd gentoo id gentoo 添加用户slackware,要求指定其所用的shell为/bin/tcsh useradd -s /bin/tcsh slackware tail -1 /etc/passwd info COMMAND 用于查看在线帮助文档 info ls 很多应用程序会自带帮助文档:/usr/share/doc/APP-VERSION README:程序的相关的信息INSTALL:安装帮助CHANGES:版本迭代时的改动信息 TLDR帮助工具 TLDR 全称是 Too Long, Don't Read，太长不看的意思 #安装tldr yum install -y npm npm install -g tldr #查看帮助 tldr curl centos最小安装的情况下,man帮助不全 1、命令： yum install man 后发现，有的函数仍然没有。经过一番查找，原来安装的不完全，还要执行下面命令： yum install -y man man-pages "},"pages/03.linux常用基础命令.html":{"url":"pages/03.linux常用基础命令.html","title":"03.linux常用基础命令","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 pwd:printing working directory 显示当前工作目录 cd:change dirctory ls:list,列出指定目录下的内容 cat:concatenate 文本查看工具 tac: 文本文件查看工具与cat不同的是它从最后一行倒序显示内容 file:查看文件的内容类型 echo 回显 关机或重启命令:shutdown 日期相关的命令 常用命令 pwd:printing working directory 显示当前工作目录 cd:change dirctory cd [/PATH/TO/SOMEDIR] #切换到家目录 cd #切换回自己的家目录,在bash中,~表示家目录 cd ~ #切换至指定用户的家目录 cd ~root cd ~zhangsan #在上一次所在目录与当前目录之间来回切换 cd - #相关环境变量 #$PWD:当前工作目录 `echo $PWD` #$OLDPWD:上一次的工作目录 `echo $OLDPWD` #`cd -`相当于`cd $OLDPWD` cd $OLDPWD ls:list,列出指定目录下的内容 ls [OPTION]... [FILE]...-a:显示所有文件,包括隐藏文件-A:显示除.和..之外的所有文件-l:long,长格式列表,即显示文件的详细属性信息如:-rw-r--r--. 1 root root 1571 5月 8 16:26 anaconda-ks.cfg-:文件的类型, -，d,b,c,l,s,p-rw-------rw-:文件属主的权限r--:文件属组的权限r--:其他用户(非属主,属组)的权限1:数字表示文件被硬链接的次数或者目录存放文件的个数root:文件的属主root:文件的属组 1571:数字表示文件的大小, 单位是字节5月 8 16:26:文件最近一次被修改的时间anaconda-ks.cfg:文件名-h,human-readable:对文件大小单位换算:换算后结果可能会非精确值-d:查看目录自身而非内部的文件列表-r:reverse,降序显示-R:recursive,递归显示 cat:concatenate 文本查看工具 cat [OPTION]... [FILE]...-n:给显示的文本行编号-E:显示行结束符$ #查看文件类型,这里ASCII text代表是文本文件 file /etc/fstab /etc/fstab: ASCII text #cat的使用 cat /etc/fstab cat /etc/passwd cat /etc/issue cat /etc/fstab /etc/issue tac: 文本文件查看工具与cat不同的是它从最后一行倒序显示内容 tac /etc/fstab file:查看文件的内容类型 file [FILE]... echo 回显 echo[OPTION]... [STRING]... -n:不进行换行 -e:让转义符生效 echo -n \"helloworld\" echo -e \"hello\\neveryone\" STRING可以使用引号,单引号和双引号均可单引号:强引用,变量引用不执行替换双引号:弱引用,变量应用会被替换 echo \"使用的是$SHELL\" 使用的是/bin/bash echo '使用的是$SHELL' 使用的是$SHELL 关机或重启命令:shutdown shutdown [OPTIONS...] [TIME] [WALL...] OPTIONS:-h:halt 关机-r:reboot 重启-c:cancel 取消运行中的 shutdown 进程 TIME:now:当前时间hh:mm:指定几点几分+m：指定几分钟后如:+5+0:相当于now WALL 向各终端发送关机消息 shutdown -h now shutdown -h +10 shutdown -h 18:30 日期相关的命令 Linux:系统启动时从硬件读取日期和时间信息:读取完成以后,就不再与硬件相关联系统时钟 date硬件时钟 clock date 系统时钟 显示日期时间:date [OPTION]...[+FORMAT] #日期,按 24 小时制显示(yyyy:MM:dd) date +%F #时间,按 24 小时制显示(hh:mm:ss) date +%T #+后有空格需要用\"\"扩起来 date +\"%F %T\" #当前区域的日期和时间 date +%c #获取我们习惯的日期格式 date +\"%Y-%m-%d %H:%M:%S\" #从1970年1月1日(unix元年)0点0分0秒到现在历经的秒数 date +%s #设置日期时间:date [MMDDhhmm[[CC]YY][.ss]] date 062615102015 hwclock,clock:硬件时钟,显示或设定硬件时钟,下图显示clock是hwclock的软链接,两个命令是一样的-s,--hctosys:以硬件为准,把系统时间调整为硬件时间相同 (hc代表hard clock,sysy代表system)-w,--systohc:以系统为准,把硬件时间调整为与系统时钟相同 clock -s clock -w cal calendar 日历cal [[month] year] cal 2015 cal 12 2015 "},"pages/04.根文件系统.html":{"url":"pages/04.根文件系统.html","title":"04.根文件系统","keywords":"","body":"FHS:FileSystem Hierarchy Standard 文件系统层次结构标准 所有Linux的发行版都应该遵循FHS标准 /bin: 所有用户可用的基本命令程序文件/sbin:供系统管理使用的工具程序/boot:引导加载器必须用到的各静态文件:kernel,initramfs(initrd),grub等/dev:存储特殊文件或设备文件，设备文件有两种类型:字符设备(线性设备)、块设备(随机设备)/etc:系统程序的配置文件,只能为静态/home:普通的家目录的集中位置;一般每个普通用户的家目录默认为此目录下与用户名同名的子目录,/home/USERNAME/root:管理员的家目录;可选 /lib:为系统启动或根文件系统上的应用程序(/bin,/sbin等)提供共享库,以及为内核提供内核模块子目录:libc.so.:动态链接的C库ld:运行时链接器/加载器 modules:用于存储内核模块的目录/lib64:64位系统特有的存放64位共享库的路径/media:便携式设备挂载点,cdrom,floppy等 /mnt:其他文件系统的临时挂载点/opt:附加应用程序的安装位置;可选路径/srv:当前主机位服务提供的程序/tmp:为那些会产生临时文件的程序提供的用于存储临时文件的目录;可供所有用户执行写入操作;有特殊权限/usr:usr Hierarchy,全局共享的只读数据路径子目录:bin,sbinlib,lib64include:C程序头文件share:命令手册页和自带文档等架构特有的文件存储位置local:另一个层级目录X11R6:X-Window程序的安装位置src:程序源码文件的存储位置 /usr/local:Local hierarchy,让系统管理员安装本地应用程序;也通常用于安装第三方程序/var:/var hierarchy,存储常发生变化的数据目录/proc:基于内存的虚拟文件系统,用于为内核及进程存储其相关信息;他们多为内核参数,例如net.ipv4.ip_forward,虚拟为net/ipv4/ip_forward,存储于/proc/sys/,因此其完整路径为/proc/sys/net/ipv4/ip_forward/sys:sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径;其主要作用在于为管理Linux设备提供一种统一模型的接口 "},"pages/05.Linux系统上的文件类型和历史命令.html":{"url":"pages/05.Linux系统上的文件类型和历史命令.html","title":"05.Linux系统上的文件类型和历史命令","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 基本命令 which命令 whereis who命令: w命令: bash的基础特性 history 命令历史 技巧:调用上一条命令的最后一次参数 控制命令历史记录的方式: Linux系统上的文件类型 -: 常规文件;注:其他程序中常规文件用f来表示,ll命令会用-来表示d: dirctory,目录文件b: block device,块设备文件,支持以\"block\"为单位进行随机访问c: character device,字符设备文件,支持以\"character\"为单位进行线性访问major number:主设备号,用于标识设备类型,进而确定要加载的驱动程序minor number:次设备号,用于标识同一类型中的不同的设备l:symobolic link,符号链接文件(相当于windows上的快捷方式),也交软链接soft linkp:pipe,命名管道s:socket,套接字文件;主要用于服务的提供 基本命令 命令类型: 外部命令shell的内嵌命令注shell本身是外部命令,它自带了很多命令,如pwd等;所以内嵌命令其实应该叫shell的内嵌命令 命令别名:命令可以有别名;别名可以与原名相同,此时原名被隐藏; 此时如果要运行原命令,则使用\\COMMAND 上图可以看出,\\ls使用运行原命令,列出的文件列表是没有颜色的 获取所有可用别名的定义: alias 定义别名 alias NAME='COMMAND': #注意:定义别名仅对当前shell进程有效 alias cls=clear 撤销别名 unalias NAME: unalias cls which命令 用于显示命令的完整路径[OPTSIONS]--skip-alias 用于忽略别名显示 which ls which --skip-alias ls whereis 用于显示命令的二进制程序路径和手册路径 whereis [options] name...-b:仅搜索二进制程序路径-m:仅搜索使用手册文件路径 whereis ls whereis -b ls whereis -m ls who命令: 查看当前谁登陆了系统who [OPTION]...-b:系统此次启动的时间;-r:运行级别; who who -b who -r w命令: 增强的who命令,不光显示当前谁登陆了系统,还显示谁做了什么 bash的基础特性 history 命令历史 定制history的功能,可通过环境变量的实现$HISTSIZE: shell进程(内存中)可保留的命令历史的条数$HISTFILE: 持久保存命令历史的文件路径,每个用户都有自己的历史文件路径,在用户家目录的.bash_history文件中$HISTFILESIZE: 命令历史文件的大小 命令用法: #-c 清空shell进程(内存中)命令历史 history -c #-d offset:删除指定命令地址 history -d 61 #-r:从文件读取命令历史至历史文件中 history -r #-w:把历史列表中的命令追加至历史文件中 history -w #history #:显示最近#条命令 history 10 #!#:再一次执行历史列表中的第#条命令 !1060 #!STRING:再一次执行命令历史列表中最近一个以STRING开头的命令 #这里执行命令历史列表中最近一个以m开头的命令 !m #再一次执行上一次命令 !! 技巧:调用上一条命令的最后一次参数 快捷键 ESC+. !$ 代表上一个命令最后一个参数 控制命令历史记录的方式: 环境变量:$HISTCONTROL echo $HISTCONTROL ignoredups:忽略重复命令ignorespace:忽略以空白字符开头的命令ignoreboth:以上两者同时生效 #设置使用以上其中一种方式来控制历史记录 HISTCONTROL=ignoreboth "},"pages/06.目录文本查看命令.html":{"url":"pages/06.目录文本查看命令.html","title":"06.目录文本查看命令","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 rmdir:remove empty directories 命令行展开 tree命令: 命令的执行状态结果 引用命令的执行结果 快捷键 文本查看类命令：cat,tac,head,tail,more,less stat命令: touch命令 mkdir: make directories mkdir [OPTION]... DIRECTORY...-p: 自动按需创建父目录-v:verbose,显示详细过程-m:MODE,直接给定权限注意:路径基名方为命令的作用对象;基名之前的路径必须得存在 rmdir:remove empty directories rmdir [OPTION]...DIRECTORY...-p:删除某目录后,如果其父目录为空,则一并删除之-v:显示过程 命令行展开 ~: 自动展开为用户的家目录,或指定的用户的家目录{}:可承载一个以逗号分隔的路径列表,并能够将其展开为多个路径例如: /tmp/{a,b} 相当于/tmp/a /tmp/b 问题1:如何创建/tmp/x/y1,/tmp/x/y2,/tmp/x/y1/a,/tmp/x/y1/b ? mkdir -pv /tmp/x/{y1/{a,b},y2} tree /tmp/x 问题2:如何创建a_c,a_d,b_c,b_d mkdir {a,b}_{c,d} -v 问题3:创建my和mybook两个文件夹 mkdir my{,book} 问题4:备份文件 #相当于mv httpd.conf httpd.conf.bak mv httpd.conf{,.bak} tree命令: tree [options] [directory]-L level:指定要显示的层级 tree /tmp tree -L 1 /tmp 命令的执行状态结果 bash通过状态返回值来输出此结果成功:0 失败:1-255 #输入一条命令后,使用echo $?来获取上一条命令的状态结果 ls echo $? #获取错误命令的状态结果 lssss echo $? 引用命令的执行结果 $(COMMAND)或COMMAND推荐使用$(COMMAND) #创建年月日格式的目录 mkdir $(date +%Y-%m-%d) mkdir `date +%H:%M:%S` 快捷键 Ctrl+a:跳转至命令行行首Ctrl+e:跳转至命令行行尾Ctrl+u:删除行首至光标所在处之间的所有字符Ctrl+k:删除光标所在处至行尾的所有字符Ctrl+l:清屏,相当于clear 文本查看类命令：cat,tac,head,tail,more,less tail命令-n #-# -f:查看文件尾部内容结束后不退出,跟随显示新增的行(比如监控新增的日志) tail -n5 -f stat命令: stat:显示文件或文件系统状态(查看元数据)stat FILE...文件:两类数据元数据:metadata数据: data stat /etc/sysconfig/network-scripts/ifcfg-ens33 最近访问(access time)：2019-06-28 08:07:28.421236593 +0800最近更改(modify time)：2019-05-08 16:25:37.268856681 +0800最近改动(change time)：2019-05-08 16:25:37.268856681 +0800注意:文件数据发生更改,文件元数据也会发生更改(比如文件的大小等),所以更改了文件的数据,modify time,change time,access time都会发生改变;如果只想change time发生修改,比如我们可以修改文件名mv a.txt b.txt,这样只修改了文件的元数据,就只有change time发生了改变理解:文件数据修改,access time,modify time,change time都会发生修改 文件元数据修改,只有change time会发生修改 touch命令 修改文件的时间戳(change file timestamps) touch a.txt 目录下a.txt不存在则会创建文件,a.txt存在会修改access time、modify time,change time为当前时间touch [OPTION]... FILE...-c:指定的文件路径不存在时不予创建-a:仅修改access time-m:仅修改modify time-t:修改文件为指定时间 [[CC]YY]MMDDhhmm[.ss] #修改文件为指定时间 touch -m -t 020522112223.13 "},"pages/07.文件管理命令.html":{"url":"pages/07.文件管理命令.html","title":"07.文件管理命令","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 cp命令:copy mv 操作基本和cp一样,区别就是mv移动完文件后将之前位置的文件给删除了 rm命令:remove 文件管理工具: cp,mv,rm cp命令:copy 单源复制:cp [OPTION]... [-t] SOURCE DEST如果DEST不存在:则实现创建此文件,并复制源文件的数据流至DEST中如果DEST存在:如果DEST是非目录文件:则覆盖目标文件如果DEST是目录文件:则现在DEST目录下创建一个与源文件同名的文件,并复制其数据流 多源复制cp [OPTION]... SOURCE... DIRECTORYcp [OPTION]... -t DIRECTORY SOURCE...如果DEST不存在:错误;如果DEST存在:如果DEST是非目录文件:错误;如果DEST是目录文件:分别复制每个文件至目标目录中,并保持原名 #多源复制 cp /root/aaa/aa.txt /root/aaa/cc.txt /tmp #或者使用扩展 cp /root/aaa/{aa.txt,cc.txt} /tmp 常用选项:-i:交互式复制,既覆盖之前提醒用户确认-f:强制覆盖目录文件-r,-R:递归复制目录-d:复制符号链接文件本身,而非其指向的源文件-a:复制时,尽可能保持文件的结构和属性.(但不保持目录 结构)等同于 -dpR。 cp -r /tmp/aaa /tmp/bbb mv 操作基本和cp一样,区别就是mv移动完文件后将之前位置的文件给删除了 使用mv还可以用来改文件名,需要在一个目录下操作 mv /tmp/a.txt /tmp/b.txt rm命令:remove rm [OPTIONS]... FILE...常用选项-i:交互式删除,既删除之前提醒用户确认-f:强制删除文件,不提醒-r:recursive;递归删除文件 删除目录:rm -rf /PATH/TO/DIR危险操作:rm -rf /*CentOS上rm -rf /是不被允许的 注意:所有不用的文件建议不要直接删除,而是移动至某个专用目录;(模拟回收站) "},"pages/08.glob通配及IO重定向.html":{"url":"pages/08.glob通配及IO重定向.html","title":"08.glob通配及IO重定向","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 IO重定向及管道 IO重定向: 输出重定向: 输入重定向 管道 tee命令:将COMMAND结果输出到屏幕上,同时保存到文件中 特殊设备:/dev/null cat globbing:文件名通配(整体文件名匹配,而非部分) 匹配模式:元字符:匹配任意长度的任意字符pa,pa,pa,p*a ?:匹配任意单个字符 pa?,??pa,p?a,p?a? #匹配pa开头 ls /etc/pa* #指定-d:代表不显示匹配文件夹下的文件 ls -d /etc/pa* #匹配pa后4个字符 ls -d /etc/pa???? #匹配。log结尾 ls /var/log/*.log []:匹配指定范围内的任意单个字符有几种特殊格式:[a-z],[A-Z],[0-9],[a-z0-9][[:upper:]]:所有大写字母[[:lower:]]:所有小写字母[[:alpha:]]:所有字母[[:digit:]]:所有数字[[:alnum:]]:所有字母和所有数字[[:space:]]:所有空白字符[[:punct:]]:所有的标点符号 #匹配p和a之间有标点符号的文件 ls p[[:punct:]]a #创建一个中间有空白字符的文件 touch p\\ a #匹配中间有空白字符的文件 ls ?[[:space:]]? [:upper:] 匹配非大写字母[0-9] 匹配非数字 [:alnum:] 匹配非正常字符 练习1:显示/var目录所有以l开头,以一个小写字母结尾,且中间出现一位任意字符都是文件或目录 ls -d /var/l?[[:lower:]] 练习2:显示/etc目录下,以任意一位数字开头,且以非数字结尾的文件或目录 ls -d /etc/[0-9]*[^0-9] 练习3:显示/etc/目录下,以非字母开头,后面跟一个字母及其他任意长度任意字符的文件或目录 touch /etc/1Ac /etc/2b777 ls -d /etc/[^a-z][a-z]* ls -d /etc/[^[:alpha:]][[:alpha:]]* 练习4:复制/etc目录下,所有一m开头,以非数字结尾的文件或目录至/tmp/abc.com目录 mkdir /tmp/abc.com cp -r /etc/m*[^0-9] /tmp/abc.com 练习5:复制/usr/share/man目录下,所有以man开头,后跟一个数字结尾的文件或目录至/tmp/man/目录下 mkdir /tmp/man cp -r /usr/share/man/man[0-9] /tmp/man #查看复制过去的文件占的硬盘空间 du -sh /tmp/man 练习6:复制/etc目录下,所有以.conf结尾,且以m,n,r,p开头的文件或者目录至/tmp/conf.d/目录下 mkdir /tmp/conf.d cp -r /etc/[mnrp]*.conf /tmp/conf.d IO重定向及管道 可用于输入的设备:文件键盘设备、文件系统上的常规文件、网卡等 可用于输出的设备:文件显示器、文件系统上的常规文件、网卡等 程序的数据流有三种:输入的数据流:输出的数据流:--> 标准输出(stdout),显示器错误输出流: --> 错误输出(stderr),显示器 fd:file descriptor,文件描述符标准输入:0标准输出:1错误输出:2 IO重定向: 输出重定向: 覆盖输出 >追加输出 >> cat /etc/issue > /tmp/issue.out 输出重定向到虚拟终端tty2上: cat /etc/issue > /dev/tty2 虚拟终端tty2的显示: set -C禁止覆盖输出重定向至已存在的文件此时可使用强制覆盖输出：>|强制覆盖输出 cat /etc/issue >| /tmp/issue.out set +C关闭禁止覆盖输出重定向至已存在的文件 错误输出流重定向: 2>, 2>>以下不存在的文件或目录的错误信息输出到了/tmp/abc.out文件中 合并正常输出流和错误输出流:&>,&>> #正常输出流 cat /etc/issue &>> /tmp/abc.out #错误输出流 cat /etc/issue1 &>> /tmp/abc.out 合并正常输出流和错误输出流另一种方式:COMMAND > /path/to/somefile 2>&1COMMAND >> /path/to/somefile 2>&1 #正常输出流 cat /etc/issue >> /tmp/issue5.out 2>&1 #错误输出流 cat /etc/issue5 >> /tmp/issue5.out 2>&1 输入重定向 tr [OPTION]... SET1 [SET2]把输入的数据当中的字符,凡是在SET1定义范围内出现的,通通对应转换为SET2出现的字符 用法1: tr SET1 SET2 #将输入/etc/issue文件内容所有小写字母转换为大写字母,并输入重定向到显示器 tr [a-z] [A-Z] 用法2: tr -d SET1 #这里-d指的是删除;这里是指删除所有大写字母,并输入重定向到显示器 tr -d '[A-Z]' 注意:tr命令不删除原文件 Here Document:cat cat abc > cde > jge > EOF cat > /PATH/TO/SOMEFILE #输入重定向到文件test1.out,且使用cat将文件信息打印到显示器 cat > /tmp/test1.out abc > cde > OF 使用tee也可以做到上面的效果(tee:从标准输入写往文件和标准输出) tee /tmp/test2.out hello > world > EOF 管道 连接程序,实现前一个命令的输出直接定向后一个程序当做输入COMMAND1 | COMMAND2 |COMMAND3 | ... #cat /etc/issue的输出结果作为tr 'a-z' 'A-Z'的输入 cat /etc/issue|tr 'a-z' 'A-Z' #只看登录的前2个用户 who|head -2 #只看登录的前2个用户,且将所有的小写字母转换为大写 who|head -2|tr 'a-z' 'A-Z' #接上条命令,加入删除0-9数字 who|head -2|tr 'a-z' 'A-Z'|tr -d '0-9' tee命令:将COMMAND结果输出到屏幕上,同时保存到文件中 COMMAND|tee /PATH/TO/SOMEFILE #将/etc/issue输出结果送给tee,让tee保存到issue.tee文件里,同时会再发一次数据流给tr cat /etc/issue|tee /tmp/issue.tee|tr 'a-z' 'A-Z' #如果想保存文件中,又打印到显示器 cat /etc/issue|tee /tmp/issue.tee 练习1:把/etc/passwd文件的前6行的信息转换为大写字符后输出; head -6 /etc/passwd|tr 'a-z' 'A-Z' 特殊设备:/dev/null 将来如果有些输出数据没有任何意义时,都可以输出重定向至/dev/null #假设我只关心命令成功和失败,不关心输出是什么的时候,使用合并重定向到/dev/null #在shell编程中经常用这种方式来获取它的状态,来判断是否继续执行某段程序代码.0:代表成功、1-255:代表失败 ls /var &> /dev/null #0代表成功 echo $? ls /varr &> /dev/null #1-255代表失败 echo $? cat 两个都是获取stdin,并在EOF处结束stdin，输出stdout。 但是 先来看man中的说明： If the redirection operator is 翻译过来的意思就是：如果重定向的操作符是 这可以解决由于脚本中的自然缩进产生的制表符。 通俗一点的解释： 在我们使用cat 比如,下面的语句就不会出错： cat 如果结束分解符EOF前有制表符或者空格，则EOF不会被当做结束分界符，只会继续被当做stdin来输入。而 cat 上面的写法，虽然最后的EOF前面有多个制表符和空格，但仍然会被当做结束分界符，表示stdin的结束。这就是 "},"pages/09.用户和组管理概念.html":{"url":"pages/09.用户和组管理概念.html","title":"09.用户和组管理概念","keywords":"","body":"用户、组 Multi-tasks,Multi-Users每个使用者:用户标示、密码: Authentication 认证 Authorization 授权 Audition 审计 组:用户组,用户容器 用户类别:管理员普通用户:系统用户、登录用户 用户标识:UserID,UID16bits二进制数字:0-65535管理员:0普通用户:1-65535系统用户:1-499(CentOS6),1-999(CentOS7)登录用户:500-60000(CentOS6),1000-60000(CentOS7)名称解析:名称转换 Username UID根据名称解析库进行:/etc/passwd 组:组类别1:管理员组普通用户组:系统组、登录组 组标识:GroupID,GID管理员组:0普通用户组:1-65535系统用户组:1-499(CentOS6),1-999(CentOS7)登录用户组:500-60000(CentOS6),1000-60000(CentOS7) 名称解析:groupname GID解析库:/etc/group 组类别2:用户的基本组用户的附加组 组类别3:私有组:组名同用户名,且只包含一个用户公共组:组内包含了多个用户 认证信息:通过比对事先存储的,与登录时提供的信息是否一致密码库存放在(password):用户密码库:/etc/shadow组密码库:/etc/gshadow 密码的使用策略:1.使用随机密码2.最短长度不要低于8位3.应该使用大写字母、小写字母、数字和标点符号四类字符中至少三类4.定期更换 加密算法:对称加密:加密和解密使用同一个密码 非对称加密:加密和解密使用的一对儿秘钥密钥对儿:公钥:public key私钥:private key 单向加密:只能加密不能解密;提取数据特征码定长输出雪崩效应算法:md5:message digest,128bitssha1: secure hash algorithm,160bitssha224、sha556、sha384、sha512对计算之时加salt,添加随机数 /etc/passwd:用户的信息库name:password:UID:GID:GECOS:directory:shellname:用户名password:可以是加密的密码,也可是占位符xUID:用户IDGID:用户所属的主组的ID号GECOS:注释信息directory:用户的家目录shell:用户的默认shell,登录时默认shell程序 /etc/shadow:用户密码用户名:加密的密码:最近一次修改密码的时间:密码最短使用期限:密码最长使用期限:警告期段:过期期限:保留字段 /etc/group:组信息库group_name:passwd:GID:user_listgroup_name:组名passwd:密码或占位符xGID:组IDuser_list:以此组为附加组的用户的用户列表 "},"pages/10.用户和组管理命令.html":{"url":"pages/10.用户和组管理命令.html","title":"10.用户和组管理命令","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 groupadd命令:添加组 groupmod命令:修改组属性 groupdel命令:删除组 useradd命令创建用户 创建用户 指明用户所属的附加组,多个组之间用逗号分隔 创建用户,并指定使用哪种shell的 useradd -D:用于显示创建用户的默认配置 useradd -D 选项:修改默认的选项值 还使用adduser也可以创建用户,它是useradd的软链接 usermod命令:修改用户属性 userdel命令:删除用户 练习1:创建用户gentoo,UID为4001,基本组为gentoo, 附加组为distro(GID为5000)和peguin(GID为5001); 练习2:创建用户fedora,其注释信息为\"Fedora Core\",默认shell为/bin/tcsh; 练习3:修改gentoo用户的家目录为/var/tmp/gentoo;要求其原有文件仍然能被访问; 练习4:为gentoo新增附加组netadmin; passwd命令 gpasswd命令 newgrp命令:临时切换指定基本组 change命令:更改用户密码过期信息 id命令:显示真实和有效的 UID 和 GID su命令:switch suer 其他几个命令,不常用 用户和组管理 安装上下文:进程以其发起者的身份运行进程对文件的访问权限,取决于发起此进程的用户的权限如果管理员使用命令cat /etc/shadow意味着访问以管理员身份来访问;管理员可以访问此文件如果以zhangsan普通用户的身份来运行cat /etc/shadow意味着访问以zhangsan普通用户的身份来访问;普通用户是不能访问该文件的系统用户:为了能够让后台进程或服务类进程以非管理员的身份运行,通常需要为此创建多个普通用户;这类用户从不用登陆系统称之为系统用户 groupadd命令:添加组 groupadd [OPTION] group_name-g:GID,指定GID;默认是上一个组的GID+1;-r:创建系统组; groupadd -r testgroup #可以看到系统组的ID是1-999之间 tail -n 2 /etc/group #-g用于指定组ID groupadd -g 2000 grp1 #指定系统组,并指定组ID为306 groupadd -r -g 306 mariadb groupmod命令:修改组属性 groupmod [OPTION] GROUP-g:GID,修改GID-n:new_name,修改组名 #将mariadb的GID修改为702 groupmod -g 702 mariadb #修改组名为perconserver groupmod -n perconserver mariadb groupdel命令:删除组 #删除组 groupdel grp1 groupdel perconserver useradd命令创建用户 -d:指定UID-g:指定基本组ID,此组得实现存在-G:指明用户所属的附加组,多个组之间用逗号分隔-c:指明注释信息-d,以指定的路径为用户的家目录;通过复制/etc/skel此目录并重命名实现;指定的家目录路径如果事先存在,则不会为用户复制环境配置文件-s,指定用户的默认shell,可用的所有shell列表存储在/etc/shells文件-r,创建系统用户 注意:创建用户时的诸多默认设定配置文件尾/etc/login.defs 创建用户 #创建用户docker useradd docker tail -1 /etc/passwd tail -1 /etc/group #指定UID为3000 useradd -u 3000 openstack #使用-c添加用户时添加注释信息 useradd -c \"我是只是\" mogilefs 指明用户所属的附加组,多个组之间用逗号分隔 #-G:指明用户所属的附加组,多个组之间用逗号分隔 useradd -G docker arclinux #使用此命令结果请看下图 tail /etc/group 指定用户的家目录/home/abc通过复制/etc/skel此目录并重命名实现 指定的家目录路径如果事先存在,则不会为用户复制环境配置文件(/etc/skel文件) 创建用户,并指定使用哪种shell的 useradd -s /bin/csh keystone tail -1 /etc/passwd useradd -D:用于显示创建用户的默认配置 useradd -D 选项:修改默认的选项值 修改的结果保存于/etc/default/useradd文件中GROUP:创建用户时用户同名的私有组HOME:家目录默认路径INACTIVE:非活动期限为禁用EXPIRE:过期期限为永不过期,(空为永不过期,一般为99999天,人一辈子也就3w多天)SHELL:默认shellSKEL:从哪去用户骨架信息CREATE_MAIL_SPOOL:邮件缓冲队列为yes表示每创建一个用户在/var/spool/mail/会给用户创建用户自己专用的邮桶 useradd -D -s /bin/csh #查看修改 useradd -D cat /etc/default/useradd 还使用adduser也可以创建用户,它是useradd的软链接 usermod命令:修改用户属性 usermod [选项] 登录名-u,--uid UID:修改用户ID;-g,--gid GROUP:修改用户所处的基本组;-G,--groups GROUP1[,GROUP2...[,GROUPN]]:修改用户所属的附加组;原来的附加组会被覆盖;-a,--append:与-G一同使用,用于为用户追加新的附加组;-c,--comment COMMENT:修改注释信息;-d,--home HOME_DIR:修改用户的家目录;用户原有的文件不会被转移至新位置;-m,--move-home:只能与-d选项一同使用,用于将原来的家目录移动为新的家目录;-l,--login NEW_LOGIN:修改用户名;-s,--shell SHELL:修改用户的默认shell;-L,--lock:锁定用户密码:即在用户原来的密码字符串之前增加一个\"!\";-U,--unlock:解锁用户的密码; usermod -c \"好了呵呵呵\" jesse userdel命令:删除用户 userdel [选项] 登录名-r:删除用户时一并删除其家目录; 练习1:创建用户gentoo,UID为4001,基本组为gentoo, 附加组为distro(GID为5000)和peguin(GID为5001); groupadd -g 5000 distro groupadd -g 5001 peguin useradd -u 4001 -G distro,peguin gentoo tail /etc/group 练习2:创建用户fedora,其注释信息为\"Fedora Core\",默认shell为/bin/tcsh; useradd -c \"Fedora Core\" -s /bin/tcsh fedora 练习3:修改gentoo用户的家目录为/var/tmp/gentoo;要求其原有文件仍然能被访问; usermod -m -d /home/zzx gentoo 练习4:为gentoo新增附加组netadmin; groupadd netadmin usermod -G netadmin gentoo tail /etc/group passwd命令 passwd [-k] [-l] [-u [-f]] [-d] [-e] [-n mindays] [-x maxdays] [-w warndays] [-i inactivedays] [-S] [--stdin] [username] (1) passwd:修改用户名自己的密码; passwd (2) passwd USERNAME:修改指定用户的密码,但仅root有此权限 passwd docker -l,Lock 锁定用户;-u,unlock 解锁用户;-d:清除用户密码;-e DATE:过期期限,日期;-i DAYS:非活动期限;-n DAYS:密码的最短使用期限;-x DAYS:密码的最常使用期限;-w DAYS:警告期限;--stdin:把改变用户密码的数据流的获取定向至标准输入;echo \"PASSWD\" | passwd -stdin USERNAME #清除密码 passwd jesse -d #查看清除后,jesse的密码字符串没有了 tail /etc/shadow #设置密码 passwd jesse #查看密码串 tail /etc/shadow 使用--stdin,把改变用户密码的数据流的获取定向至标准输入,echo \"123456\"标准输出流作为管道passwd的标准输入流,从而直接将密码给修改了 echo \"123456\"| passwd --stdin jesse 如果不想看结果可以重定向至/dev/null echo \"123456\"| passwd --stdin jesse &> /dev/null 查看是否更新成功 echo $? gpasswd命令 组密码文件:/etc/gshadow gpasswd [选项] group-a USERNAME:向组中添加用户-d USERNAME:从组中移除用户 newgrp命令:临时切换指定基本组 newgrp [-] [group] -:会摸你用户重新登录以实现重新初始化其工作环境; change命令:更改用户密码过期信息 使用man change查看帮助文档用法 id命令:显示真实和有效的 UID 和 GID id [OPTION]... [USERNAME]-u:仅显示有效的UID;-g:仅显示用户的基本组ID;-G:仅显示用户所属的所有组的ID;-n:显示名字而非ID; #显示当前登录用户信息 id #显示指定用户信息 id openstack #仅显示用户的基本组ID id -g openstack su命令:switch suer 登录式切换:会通过读取目标用户的配置文件来重新初始化su - USERNAMEus -l USERNAME非登录式切换:不会读取目标用户的配置文件进行初始化su USERNAME 注意:管理员可无密码切换至其他任何用户[选项]-c 'COMMAND':仅以指定用户的身份运行指定的命令; 其他几个命令,不常用 chsh:改变登录用户的shellfinger:显示关于系统用户的信息;需要yum -y install finger安装 finger dockerchfn:改变你的finger讯息whoami:当前用户是谁pwck:检查是否有用户异常grpck:检查组是否有异常 "},"pages/11.用户权限管理.html":{"url":"pages/11.用户权限管理.html","title":"11.用户权限管理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 mode:rwx 进程安全上下文 权限 权限管理命令: chmod命令 (1) chmod [OPTION]... MODE[,MODE]... FILE... MODE表示法: 赋权表示法:直接操作一类用户的所有权限位rwx; 授权表示法:直接操作一类用户的一个权限位r,w,x (2) chmod [OPTION]... OCTAL-MODE FILE... (3) chmod [OPTION]... --reference=RFILE FILE... 从属关系管理命令:chown,chgrp chown命令 chgrp命令: umask:文件的权限反向掩码,遮罩码: install命令:复制文件且设置文件属性 mktemp:create a temporary directory or file 权限管理 mode:rwx ls -lrwxrwxrwx:左三位:定义user(owner)的权限中三位:定义group的权限右三位:定义other的权限 进程安全上下文 进程对文件的访问权限应用模型:进程的属主与文件的属主是否相同,如果相同,则应用属主权限;否则,则检查进程的属主是否属于文件的属组:如果是,则应用属组权限;否则,就只能应用other的权限; 权限 r:readable,读w:writable,写x:excutable,执行 文件:r:可获取文件的数据;w:可修改文件的数据;x:可将此文件运行为进程; 目录:r:可使用ls命令获取其下的所有文件列表;但不能用ls -l;w:可修改此目录下的文件列表;即创建或删除文件;x:可cd至此目录中,且可使用ls -l来获取所有文件的详细属性信息; mode:rwxrwxrwxownership:user group 权限组合机制:--- 000 0--x 001 1-w- 010 2-wx 011 3r-- 100 4r-x 101 5rw- 110 6rwx 111 7 权限管理命令: chmod命令 三类用户:u:属主g:属组o:其它a:所有 (1) chmod [OPTION]... MODE[,MODE]... FILE... MODE表示法: 赋权表示法:直接操作一类用户的所有权限位rwx; u=g=o=a= cp /etc/fstab ./ pwd ll fstab #设置属组读写权限 chmod g=rw fstab #设置属主,属组读权限 chmod ug=r fstab #设置属主读写执行,属组读写,其它没有权限 chmod u=rwx,g=rw,o= fstab 授权表示法:直接操作一类用户的一个权限位r,w,x u+,u-g+,g-o+,o-a+,a- #去除属组的执行权限 chmod u-x fstab ll fstab #给其它加上读权限 chmod o+r fstab #给属主,属组加上执行权限 chmod ug+x fstab #给所有加上执行权限 chmod +x fstab #给所有去除执行权限 chmod -x fstab #给属主执行权限,属组写权限 chmod u+x,g+w fstab (2) chmod [OPTION]... OCTAL-MODE FILE... #属主和属组读写,其他无权限 chmod 660 fstab (3) chmod [OPTION]... --reference=RFILE FILE... #查看fstab权限 ll fstab #查看参考文件权限 ll /var/log/messages #指明参考文件来修改指定文件权限 chmod --reference=/var/log/messages fstab #再次查看fstab权限 ll fstab 选项:-R,--recursive 递归修改;如果不加-R选项,修改的是目录权限时,则表示仅修改目录自身的权限;加上-R则表示修改目录自身和目录下的所有子目录和子文件的权限;递归修改建议赋权和授权表示法,其他不建议使用; #设置/temp/abc/属主和属组为无权限,递归执行 chmod -R ug= /temp/abc/ 注意:用户仅能修改属主为自己的那些文件的权限; 从属关系管理命令:chown,chgrp chown命令 chown [OPTION]...[OWNER][:[GROUP]] FILE...chown [OPTION]... --reference=RFILE FILE...选项:-R:递归修改 #copy文件和使用ll查看 cp -r /etc/skel /tmp/ cd /tmp ll -ad /etc/skel ll /etc/skel -a #递归修改/etc/skel/的属组为docker chown -R docker /tmp/skel/ ll -d /tmp/skel ll -a /tmp/skel #递归修改设置属主:属组 chown -R archlinux:mygrp /tmp/skel/ ll -d /tmp/skel/ ll -a /tmp/skel/ #也可以用.号来隔开,如root.root chown -R root.root /tmp/skel/ #:递归修改设置属主不变,属组为mygrp chown -R :mygrp /tmp/skel/ #引用修改 chown -R --reference=/tmp/ssh-ZcL8QoJiIFGk/ /tmp/skel ll -d /tmp/skel/ ll -a /tmp/skel/ chgrp命令: chgrp [OPTION]... GROUP FILE...chgrp [OPTION]... --reference=RFILE FILE... 注意:仅管理员可修改文件的属主和属组; 思考:用户对目录有写权限,但对目录下的文件没有写权限时,能否修改此文件的内容?能否删除此文件?答:不能修改此文件内容,但是能删除此文件;同时可以在这个目录下创建文件 umask:文件的权限反向掩码,遮罩码: 文件:666-umask目录:777-umask注意:之所以文件用666去减,表示文件默认不能拥有执行权限;如果减得的结果中有执行权限,则需要将其加1umask:022666-022=644777-022=755 umask命令:umask:查看当前umaskumask:MASK:设置umask;默认只对当前shell进程有效 练习:1、新建系统组mariadb,新建系统用户mariadb,属于mariadb组,要求其没有家目录,且shell为/sbin/nologin;尝试root切换至用户,查看其命令提示符;2、新建GID为5000的组geedu,新建用户gentoo,要求其家目录为/users/gentoo,密码同用户名; 3、新建用户fedora,其家目录为/users/fedora,密码同用户名; 4、新建用户www,其家目录为/users/www;删除www用户,但保留其家目录; 5、为用户gentoo和fedora新增附加组geedu; 6、复制目录/var/log至/tmp/目录,修改/tmp/log及其内部的所有文件的属组为geedu,并让属组对目录本身拥有写权限; install命令:复制文件且设置文件属性 单源复制:install [option]... source dest多源复制：install [option]... source... directoryinstall [option]... -t directory source创建目录:install [option] [-d,--directory] directory... 常用选项:-m,--mode=MODE:设定目标文件权限,默认为755;-o,--owner=OWNER:设定目标文件属主;-g,--group=GROUP:设定目标文件属组;-d,--directory:用于创建目录 #什么选项也不加复制文件会被赋予755权限,而/etc/inittab权限为644 install /etc/inittab /root #先删除文件 rm -rf inittab #复制文件设置权限为640 install -m 640 /etc/inittab /root ll inittab #复制文件并设置权限、属主、属组 install -m 640 -o archlinux -g mygrp /etc/inittab /tmp/inittab ll /tmp/inittab #-d创建目录 install -d -m 640 hello ll -d hello mktemp:create a temporary directory or file mktemp [OPTION]... [TEMPLATE]常用选项:-d:创建临时目录注意:mktemp会将创建的临时文件名直接返回,因此,可直接通过命令引用保存起来; myfile=$(mktemp /tmp/abc.XXXXX) echo $myfile 一般临时文件路径放在/tmp/下,一个月后会自动删除,其他目录不确定会自动删除 #创建临时文件后面至少跟三个大写的X,表示随机值 mktemp /tmp/abc.XXX mktemp /tmp/abc.XXXX mktemp /tmp/abc.XXXXX "},"pages/12.shell变量,算数和逻辑运算及配置文件.html":{"url":"pages/12.shell变量,算数和逻辑运算及配置文件.html","title":"12.shell变量,算数和逻辑运算及配置文件","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 变量 本地变量: 环境变量: 只读变量:无法撤销,无法重新赋值,当前shell进程终止才会销毁 多命令执行: shell脚本编程: 如何写shell脚本: shell脚本是什么? 运行脚本 bash和脚本编程之算数运算 bash的配置文件: profile类: bashrc类 配置文件执行顺序 定义别名示例 定义java环境变量示例 命令hash:shell的内部命令 缓存此前命令的查找结果:key-value,保存了命令所在的路径;使用命令时会先调用这个缓存中的命令;key:搜索键value:值 hash命令:has:列出缓存列表hash -d COMMAND:删除某个命令的缓存 hash -r:清空缓存列表 #删除ls命令缓存 hash -d ls hash #删除所有缓存 hash -r hash 变量 变量名+指向的内存空间变量赋值:name=value变量类型:存储格式、表示数据范围、参与的运算 编程语言:强类型变量弱类型变量:bash把所有变量统统视作字符型;bash中的变量无需事先声明;相当于,把声明和赋值过程同时实现; 变量替换:把变量名出现的位置替换为其所指向的内存空间中的数据; 变量引用:${var_name},$var_name bash变量类型:本地变量:作用域范围仅为当前shell进程;环境变量:作用域为当前shell进程及其子进程;局部变量:作用域仅为某代码片段(函数上下文); 位置参数变量:当执行脚本的shell进程传递的参数;特殊变量:shell内置的有特殊功用的变量;如$?就是特殊变量:$?:上一个命令的执行状态结果;0:成功;1-255:失败 本地变量: 变量赋值:name=value变量引用:${name},$name\"\":变量名会替换为其值;'':变量名不会替换为其值;查看变量:set撤销变量:unset name 注意:此处非变量引用;所有不能使用$符 firstName=jesse echo $firstName unset firstName echo $firstName animal=sheep #变量的引用 echo \"There are some $animal\" #如果我们希望输出Thre are some sheeps echo \"There are some $animals\" #以上输出结果不是我们想要的,这时候就不能省略\"{}\"了 echo \"There are some ${animal}s\" 环境变量: 变量赋值:(1) export name=value(2) name=value    export name(3) declare -x name=valuedeclare是shell内嵌命令,内嵌命令使用help declare查看帮助(4) name=value    declare -x name 变量引用:${name},$name 注意:bash内嵌了许多环境变量(通常为全大写字符),用于定义bash的工作环境如:PATH、HISTFILE,HISTSIZE,HISTFILESIZE,HISTCONTROL,SHELL,HOME,UID,PWD,OLDPWD #查看环境变量PATH echo $PATH #给PATH附加:/usr/local/apache/bin PATH=\"$PATH:/usr/local/apache/bin\" #查看环境变量PATH echo $PATH #设置环境变量 declare -x name=ojbk echo $name #进入子shell bash echo $name 查看所有环境变量的命令: export declare -x printenv env 撤销环境变量:unset name 只读变量:无法撤销,无法重新赋值,当前shell进程终止才会销毁 declare -r name=valuereadonly name=value 多命令执行: COMMAND1;COMMAND2;COMMAND3;... 逻辑运算:运算数:真(true,yes,on,1)假(false,no,off,0) COMMAND1 && COMMAND2短路法则:COMMAND1为\"假\",则COMMAND2不会再执行;否则,COMMAND1为\"真\", 则COMMAND2必须执行; #/tmp/test.etc创建成功,将ls /etc结果重定向至/tmp/test.etc touch /tmp/test.etc && ls /etc > /tmp/test.etc more /tmp/test.etc #user1用户不存在,创建user1 id user1 || useradd user1 tail -1 /etc/passwd shell脚本编程: 面向过程解释运行依赖于外部程序文件运行利用系统上的命令及编程组件进行编程 如何写shell脚本: 脚本文件的第一行,顶格:给出shebang,解释器路径,用于指明解释器执行当前脚本的解释器程序文件常见的解释器:#!/bin/bash#!/usr/bin/python#!/usr/bin/perl 文本编辑器:行编辑器:sed全屏幕编辑器:nano,vi,vim shell脚本是什么? 命令的堆积;但很多命令不具有幂等性,需要用程序逻辑来判断运行条件是否满足,以避免其运行中发生错误 使用vim myfirst.sh常见shell文件编写shell脚本: #!/bin/bash id user3 || useradd user3 echo \"user3\" | passwd --stdin user3 mktemp -d /tmp/test.xxxxxx 使用chmod u+x myfirst.sh设置myfirst.sh为可执行使用./myfirst.sh执行所编写的shell脚本注:为什么执行脚本的前要加上./?以前我们说过,执行的命令是通过环境变量$PATH中的路径去查找的,因为当前路径并不在环境变量的路径中,所以需要指定shell文件为当前目录./或者绝对路径/root/myfirst.sh 运行脚本 (1) 赋予执行权限,并直接运行此程序文件;chmod+x /PATH/TO/SCRIPT_FILE/PATH/TO/SCRIPT_FILE./SCRIPT_FILE(2) 直接运行解释器,将脚本以命令行参数传递给解释器程序;bash /PATH/TO/SCRIPT_FILEbash SCRIPT_FILE #绝对路径执行 bash /root/myfirst.sh #如果文件就在当前目录下 bash myfirst.sh 注:使用bash命令执行脚本,即使脚本文件没有执行权限,也能被执行 chmod -x myfirst.sh ll myfirst.sh bash myfirst.sh 注意:脚本中的空白行会被解释器忽略,如果需要显示空白行,可以使用echo脚本中,除了shebang,余下所有以#开头的行,都会被视作注释行而被忽略;此即为注释行;shell脚本的运行是通过运行一个子shell进程实现的; 练习1:写一个脚本,实现如下功能;(1) 显示/etc/目录下所有以大写P或者小写p开头的文件或目录本身;(2) 显示/var目录下的所有文件或者目录本身,并将显示结果中的小写字母转换为大写后显示;(3) 创建临时文件/tmp/myfile.XXXX; #!/bin/bash ls -d /etc/[pP]* #这个echo当换行使用 echo ls -d /var/* | tr 'a-z' 'A-Z' echo mktemp /tmp/myfile.XXXX bash和脚本编程之算数运算 let是内嵌命令,可以使用help let来查看帮助 +,-,,/,*,%注:是几次幂 算数运算格式:(1) let VAR=算数运算表达式 (2) VAR=$[算数运算表达式] (3) VAR=$((算数运算表达式)) echo $(($num2+$num3)) #赋值写法 sum=$(($num2+$num3)) echo $sum (4) VAR=$(expr $ARG1 $OP $ARG2) 注意:乘法符号在有些场景中需要使用转义符; 增强型赋值(需要使用let):变量做某种算数运算后回存至此变量;+=,-=,*=,/=,%= i=1 let i=$i+1 let i+=1 自增:VAR=$[$VAR+1]let VAR+=1let VAR++ 自减:VAR=$[$VAR-1]let VAR-=1let VAR-- i=1 i=$[$i+1] let i+=1 let i++ echo $i 练习:1、写一个脚本,完成如下功能:添加三个用户;求此三个用户的UID之和; #!/bin/bash id user1 &> /dev/null || useradd user1 echo \"user1 id:$(id -u user1)\" id user2 &> /dev/null || useradd user2 echo \"user2 id:$(id -u user2)\" id user3 &> /dev/null || useradd user3 echo \"user3 id:$(id -u user3)\" id_user1=$(id -u user1) id_user2=$(id -u user2) id_user3=$(id -u user3) id_sum=$[id_user1+id_user2+id_user3] echo \"The id sum:$id_sum\" 2、写一个脚本计算/etc/passwd文件中的第10个用户和第20个用户的id号之和; #!/bin/bash id1=$(head -10 /etc/passwd | tail -1 | cut -d: -f3) echo \"id1:$id1\" id2=$(head -20 /etc/passwd | tail -1 | cut -d: -f3) echo \"id2:$id2\" idsum=$[$id1+$id2] echo \"The id sum:$idsum\" 3、写一个脚本 计算/etc/passwd文件中的最大的两个id号之和; #!/bin/bash max1=$(cut -d: -f3 /etc/passwd | sort -n | tail -1 | head -1) max2=$(cut -d: -f3 /etc/passwd | sort -n | tail -1) echo \"最大两个id号之和:$[$max1+$max2]\" 4、写一个脚本计算/etc/rc.d/init.d/functions和/etc/inittab文件的空白行数之和; #!/bin/bash wcl1=$(grep \"^[[:space:]]*$\" /etc/rc.d/init.d/functions | wc -l) wcl2=$(grep \"^[[:space:]]*$\" /etc/inittab | wc -l) echo \"空白行之和:$[$wcl1+$wcl2]\" bash的配置文件: 两类:profile类:为交互式登录的shell进程提供配置bashrc类:为非交互式登录的shell进程提供配置 登录类型:交互式登录shell进程:直接通过某终端输入的账号和密码后登录打开的shell进程;使用su命令:su - USERNAME,或者使用si -l USERNAME执行的登录切换; 非交互式登录的shell进程:su USERNAME执行的登录切换;图形界面下打开的终端;运行脚本如:bash script_file;之前说过shell脚本的运行是通过运行一个子shell进程实现的; profile类: 全局:对所有用户都生效;/etc/profile/etc/profile.d/*.sh 用户个人:仅对当前用户有效;~/.bash_profile 功用:1.用于定义环境变量;2.运行命令或脚本; bashrc类 全局:对所有用户都生效;/etc/bashrc 用户个人:~/.bashrc 功用:1.定义本地变量;2.定义命令别名; 注意:仅管理员可修改全局配置文件; 配置文件执行顺序 交互式登录shell进程:/etc/profile --> /etc/profile.d/* --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc 非交互式登录的shell进程:~/.bashrc --> /etc/bashrc --> /etc/profile.d/* 命令行中定义的特性,例如变量的作用域为当前shell进程的生命周期;配置文件定义的特性,只对随后新启动的shell进程有效; 让通过配置文件定义的特性,至对随后新启动的shell进程生效:(1) 通过命令行重复定义一次;(2) 让shell进程重读配置文件;source /PATH/FROM/CONF_FILE. /PATH/FORM/CONF_FILE 这里的\".\"就代表source 定义别名示例 #到用户家目录 cd ~ #编辑.bashrc配置文件,打开文件如下图 vim .bashrc 由于配置文件定义的特性,只对随后新启动的shell进程有效;如果要立即生效需要使用source命令: #\".\"相当于source命令 . /root/.bashrc #使用alias查看cls别名已经存在 alias 定义java环境变量示例 vim /etc/profile.d/java.sh 在文件中加入: #使用source使配置文件立即生效 . /etc/profile.d/java.sh #在环境变量中查找JAVA_HOME变量 export|grep JAVA_HOME 问题1:定义对所有用户都生效的命令别名,例如:lftps='lftp 172.16.0.1/pub' 问题2:让centos用户登录时,提供其已经登录,并显示当前系统时间? "},"pages/13.grep和基本正则表达式.html":{"url":"pages/13.grep和基本正则表达式.html","title":"13.grep和基本正则表达式","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 linux上文本处理三剑客: 正则表达式:Regular Expression,REGEXP grep:Global search Regular expression and pint out the line. 基本正则表达式元字符 字符匹配: 匹配次数:用在要指定其出现的次数的字符的后面,用于限制其前面字符出现的次数;默认工作于贪婪模式 位置锚定 分组及引用 后向引用:引用前面的分组括号中的模式所匹配到的字符; egrep fgrep:不支持正则表达式元字符;任何字符都当做字符本身的意义; 文本查看及处理工具:wc,cut,sort,uniq,diff,patch wc命令:word count,显示某个文件中行首、字节数、单词数 cut命令:文本截取 :指定的单个字段; -#:指定连续的多个字段; ,#：离散的多个字段; sort命令：排序 uniq命令:报告或移除重复的行 diff命令:逐行比较文件的不同内容 patch:向文件打补丁 文本处理工具 linux上文本处理三剑客: grep、egrep、fgrep: 文本过滤工具(模式:pattern)工具;grep:支持基本正则表达式;使用-E选项,支持扩展正则表达式;-F选项不支持正则表达式;egrep:默认支持扩展正则表达式;使用-G选项,可以支持基本正则表达式;-F选项不支持正则表达式;fgrep:不支持正则表达式;使用-E选项,支持扩展正则表达式;使用-G选项,可以支持基本正则表达式; set:stream editor,流编辑器;文本编辑工具;awk:linux上的实现为gawk,文本报告生成器(格式化文本); 正则表达式:Regular Expression,REGEXP 由一类特殊字符及文本字符所编写的模式,其中有些字符不表示其字面意义,而是用于表示控制或通配的功能;分两类:基本正则表达式:BRE (Basic Regular Expression)扩展正则表达式:ERE (Extension Regular Expression) grep:Global search Regular expression and pint out the line. 作用:文本搜索工具,根据用户指定的\"模式(过滤条件)\"对目标文本逐行进行匹配检查;打印匹配到的行;模式:由正则表达式的元字符及文本字符所编写出的过滤条件; grep [OPTIONS] PATTERN [FILE...]grep [OPTIONS][-e PATTERN | -f FILE][FILE...] OPTIONS:--color=auto:对匹配到的文本着色后高亮显示;-i:ignorecase,忽略字符的大小写;-o:仅显示匹配到的字符串本身;-v,--invert-match:显示不能被模式匹配到的行;-E:支持使用扩展的正则表达式元字符;-q,--qulet,--sllent:静默模式,即不输出任何内容;用于判断是否匹配成功-A #:after,后#行-B #:before,前#行 -C #:context, 前后各#行 grep \"UUID\" /etc/fstab #grep在CentOS7中有别名 alias|grep \"alias grep=\" #仅显示匹配到的文本 grep -o \"UUID\" /etc/fstab #显示不能被模式匹配到的行 grep -v \"UUID\" /etc/fstab #匹配到存在mail的行和后2行 grep -A 2 'mail' /etc/passwd #匹配到存在mail的行和前2行 grep -B 2 'mail' /etc/passwd #匹配到存在mail的行和前后2行 grep -C 2 'mail' /etc/passwd 基本正则表达式元字符 字符匹配: .:匹配任意单个字符;[]:匹配指定范围内的任意单个字符;[^]:匹配指定范围外的任意单个字符;[[:digit:]]、[[:lower:]]、[[:upper:]]、[[:alpha:]]、[[:alnum:]]、[[:punct:]]、[[:space:]] #匹配r和t之间任意2个字符 grep \"r..t\" /etc/passwd #匹配r和t之间任意2个字母 grep \"r[[:alpha:]][[:alpha:]]t\" /etc/passwd 匹配次数:用在要指定其出现的次数的字符的后面,用于限制其前面字符出现的次数;默认工作于贪婪模式 *:匹配其前面的字符任意此:0,1,多次;.*:匹配任意长度的任意字符;\\?:匹配其前面的字符0次或1次;即其前面的字符是可有可无的;\\+:匹配其前面的字符1次或多次;即其前面的字符要出现至少1次;\\{m\\}：匹配其前面的字符m次;\\{m,n\\}:匹配其前面的字符至少m次,至多n次;特殊用法:\\{0,n\\}:至少n次,\\{m,\\}:至少m次 位置锚定 ^:行首锚定;用于模式的最左侧;$:行尾锚定;用于模式的最右侧;特定写法:^$:这样写代表空白行;(空白行代表这行中包含任意字符,包括空白字符)^[[:space:]]*$:包含空白字符的行 #以root开头,以root结尾,因此该行只能包含root字符串 grep \"^root$\" /etc/passwd 单词:非特殊字符组成的连续字符(字符串)都称为单词;\\或\\b:词首锚定,用于单词模式的左侧;\\>或\\b:词尾锚定,用于单词模式的右侧;\\:匹配完整单词; #\"root\"左侧非特殊字符 grep \"\\\" /etc/passwd #\"root\"左右侧非特殊字符 grep \"\\\" /etc/passwd 练习:1、显示/etc/passwd文件中不以/bin/bash结尾的行; grep -v \"/bin/bash$\" /etc/passwd 2、找出/etc/passwd文件中两位数或三位数; grep \"\\\" /etc/passwd 3、找出/etc/grub2.cfg文件中,以至少一个空白字符开头,且后面非空白字符的行; grep \"[[:space:]]\\+[^[:space:]]\" /etc/grub2.cfg 4.找出\"netstat -tan\"命令的结果中以\"LISTEN\"后跟0、1或多个空白字符结尾的行; netstat -tan|grep \"LISTEN[[:space:]]*$\" 分组及引用 \\(\\):将一个或多个字符捆绑在一起,当做一个整体进程处理;如:\\(xy\\)*ab:代表xy可以出现一次或多次; 后向引用:引用前面的分组括号中的模式所匹配到的字符; Note:分组括号中的模式匹配到的结果会被正则表达式引擎自动记录于内部的变量中,这些变量为:\\1:模式从左侧起,第一个左括号以及与之匹配的右括号之间的模式所匹配到的字符;\\2:模式从左侧起,第二个左括号以及与之匹配的右括号之间的模式所匹配到的字符;... 示例1:文本:love.abc: He loves his lover. He likes his lover. She likes her liker. She loves her liker. #匹配到第一个分组的结果通过`\\1`引用该分组的结果 grep \"\\(l..e\\).*\\1\" ~/love.abc 示例2 \"^\\(r..t\\).*\\1\" /etc/passwd egrep 支持扩展的正则表达式;实现类似于grep文本过滤功能:grep -E使用扩展正则表达式的好处就是把\"\\\"转义符给去了,所有很多模式使用扩展正则表达式来写更易于理解 选项-G:支持基本正则表达式 扩展正则表达式的元字符:字符匹配: .:任意单个字符;[]:指定范围内的任意单个字符;[^]:指定范围外的任意单个字符; 次数匹配:*:任意次,0,1或多次;?:0次或1次,其前的字符是可有可无的;+:其前字符至少1次;{m}:其前的字符m次;{m,n}:至少m次,至多n次;可以表示:{0,n}、{m,} 位置锚定^:行首锚定;用于模式的最左侧;$:行尾锚定;用于模式的最右侧;\\:词首锚定;\\>,\\b:词尾锚定; 分组及引用():分组;后向引用:\\1,\\2,... 或:a|b:表示a或者b;C|cat:表示C或cat;(c|C)at:表示cat或Cat; #扩展正则表达式除了词首锚定和词尾锚定需要用到转义`\\`,其他的元字符都不需要使用 egrep \"\\\" /etc/passwd #与上面意义相同 grep -E \"\\\" /etc/passwd 1.找出/proc/meminfo文件中,所有在大写或小写S开头的行;至少有三种实现方式; grep -i -E \"^s\" /proc/meminfo grep -E \"^[sS]\" /proc/meminfo grep -E \"^(s|S)\" /proc/meminfo 2.显示当前系统上root、centos或user1用户的相关信息; grep -E \"^(root|centos|user1)\\>\" /etc/passwd 3.找出/etc/rc.d/init.d/functions文件中某单词后面跟一个小括号的行; #-o:代表只匹配字符串本身而不是整行;[_[:alnum:]]:匹配字母或数字,可以在外层\"[]\"中加入任意想匹配的字符,这里加入\"_\" grep -E -o \"\\\\(\\)\" /etc/rc.d/init.d/functions 4.使用echo命令输出一绝对路径,使用egrep取出基名; #匹配行尾非\"/\"的字符 echo \"/etc/sysconfig\" | grep -E -o \"[^/]+$\" #行尾的\"/\"可有可无的 echo \"/etc/sysconfig/\" | grep -E -o \"[^/]+/?$\" echo \"/etc/sysconfig\" | grep -E -o \"[^/]+/?$\" 5.找出ifconfig命令结果中的1-255之间的数值; ifconfig | grep -E -o \"[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-5]{2}\" 6.找出ifconfig命令结果中的IP地址; 7.添加用户bash,testbash,basher以及nologin(其shell为/sbin/nologin);而后找出/etc/passwd文件中用户名同shell名的行; useradd bash useradd -s /sbin/nologin nologin grep -E \"^([^:]+\\>).*\\1$\" /etc/passwd 8.使用echo命令输出一绝对路径,使用egrep取出路径名;类似于对其执行dirname命令的结果; fgrep:不支持正则表达式元字符;任何字符都当做字符本身的意义; 当无需要用到元字符去编写模式时,使用fgrep性能更好; 文本查看及处理工具:wc,cut,sort,uniq,diff,patch wc命令:word count,显示某个文件中行首、字节数、单词数 选项-l:line,仅显示行数-w:words,仅显示单词数-c:byyes,仅显示字节数 cut命令:文本截取 OPTION:-d CHAR:以指定的字符为分隔符;如分隔符为|则使用-d|;-f FiELDS:挑选出来的字段 :指定的单个字段; -#:指定连续的多个字段; ,#：离散的多个字段; #只保留用户名和shell类型 cut -d: -f1,7 /etc/passwd #获取1,3-5,7字段 cut -d: -f1,3-5,7 /etc/passwd #取出wc中的行号 wc -l /etc/rc.d/init.d/functions | cut -d' ' -f1 sort命令：排序 sort [OPTION]... [FILE]...-n:根据数值大小排序而非字符排序;-t CHAR:指定分隔符;-k #:用于排序比较的字段;-r:降序,默认是升序;-f:忽略字符大小写;-u:重复的行只保留一份;(连续且相同的行) sort /etc/passwd #取/etc/passwd文件中的用户ID,默认是根据字符来排序的 cut -d: -f3 /etc/passwd | sort #加上-n就会根据数值大小排序 cut -d: -f3 /etc/passwd | sort -n #-t指定分隔符为:,-k指定为filed3来进行排序,-n根据数值排序 sort -t: -k3 -n /etc/passwd #-r使用降序 sort -t: -k3 -n -r /etc/passwd #获取所有用户中一共有几种shell cut -d: -f7 /etc/passwd | sort -u | wc -l uniq命令:报告或移除重复的行 uniq [OPTION]...[INPUT[OUTPUT]]OPTION-c:显示每行的重复次数;-u:仅显示未曾重复过的行;-d:仅显示重复过的行; #移除重复的行 cut -d: -f7 /etc/passwd | sort | uniq #统计所有shell的用户使用数 cut -d: -f7 /etc/passwd | sort | uniq -c #统计只有一个用户使用的shell类型 cut -d: -f7 /etc/passwd | sort | uniq -u #所有大于一个用户使用的shell类型 cut -d: -f7 /etc/passwd | sort | uniq -d diff命令:逐行比较文件的不同内容 diff [OPTION]... FILES-u:使用unfied机制,即显示要修改的行的上下文,默认为3行; diff /PATH/TO/OLDFILE /PATH/TO/NEWFILE > /PATH/TO/PATCH_FILE patch:向文件打补丁 patch [OPTIONS] -i /PATH/TO/PATCH_FILE /PATH/TO/OLDFILEpatch /PATH/TO/OLDFILE cp /etc/fstab ./fstab cp fstab fstab.new #随意在新文件里加入点文字 vim fstab.new #查看差异 diff fstab fstab.new #将差异重定向到fstab.patch文件 diff fstab fstab.new > fstab.patch #打补丁到老文件 patch -i fstab.patch fstab #再次比较两个文件就没有什么不同的了 diff fstab fstab.new 还可以使用-R选项还原到补丁前的状态 patch -R -i fstab.patch fstab "},"pages/14.vim编辑器.html":{"url":"pages/14.vim编辑器.html","title":"14.vim编辑器","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 光标跳转 COMMAND:跳转由#指定的个数的字符 COMMAND:跳转由#指定的个数的单词 G:跳转至由#指定的行; vim的编辑命令: x:删除光标所在处起始的#个字符; dd:删除光标所处的行起始的#行; yy:复制n行,如:5yy; 其他编辑操作 u:操作此前#个的操作;如4u,撤销此前的4次操作; vim末行模式: vim的多文件功能: 定制vim的工作特性 vim vim [options] [file...]+#:打开文件后,直接让光标处于第#行的行首;+/PATTERN:打开文件后,直接让光标处于第一个被PATTERN匹配到的行行首; #打开文件并定位到第5行,第一列 vim +5 fstab #copy文件 cp /etc/rc.d/init.d/functions ./ #直接让光标处于第一个被\"if\"匹配到的行行首 vim +/if functions #光标定位在尾行打开 vim + functions 模式转换:编辑模式:默认模式编辑模式-->输入模式:i:insert,在光标所在处输入;a:append,在光标所在处后方输入;o:在光标所在处的下方打开一个新行;I:在光标所在行的行首输入;A:在光标所在行的行尾输入;O:在光标所在处的上方打开一个新行; 输入模式-->编辑模式:ESC 编辑模式-->末行模式:: 末行模式-->编辑模式:ESC 关闭文件:ZZ:保存并退出; :q 退出;:q! 强制退出不保存;:wq 保存并退出;:x 保存并退出;:w /PATH/TO/SOMEFILE 另存为; 光标跳转 字符间跳转h:左j:下k:上i:右 COMMAND:跳转由#指定的个数的字符 例如:10h; 单词间跳转w:下一个单词的词首;e:当前或后一个单词的词尾;b:当前或前一个单词的词首; COMMAND:跳转由#指定的个数的单词 行首行尾跳转^:跳转至行首的第一个非空白字符;0:跳转至行首;$:跳转至行尾; 行间跳转 G:跳转至由#指定的行; 1G,gg:第一行; G:最后一行; 句间跳转:() 段间跳转:{} 翻屏:Ctrl+f:向文件尾部翻一屏Ctrl+b:向文件首部翻一屏Ctrl+d:向文件首部翻半屏Ctrl+u:向文件首部翻半屏Enter:按行向后翻 vim的编辑命令: 字符编辑：x:删除光标所在处的字符; x:删除光标所在处起始的#个字符; xp:交换光标所在处的字符与其后面的字符的位置; 替换命令(replace)：r:替换光标所在处的字符;(输入r+键盘上的字符) 删除命令:d:删除命令、可结合光标跳转字符,实现范围删除;d$:从光标所在处删除到行尾;d^:从光标所在处删除到行首;dd:删除光标所在行的一整行； dd:删除光标所处的行起始的#行; 粘贴命令p:缓冲区中的内容如果为整行,则粘贴在当前光标所在行的下方;否则,则粘贴至当前光标所在处的后方;P: 缓冲区中的内容如果为整行,则粘贴在当前光标所在行的上方;否则,则粘贴至当前光标所在处的前方; 复制命令(yank,y)y:复制,工作行为相似于d命名;yy:复制一整行;y$:复制从光标到行尾;y^:复制光标到行首;y0:复制到行首,行首部有空格包含空格,Tab等一起复制; yy:复制n行,如:5yy; 改变命令(change,c)c操作完后编辑模式转换为输入模式,实现删除操作和d命令一样,区别是会转换为输入模式比如:cc删除整行后,就可以输入内容了 其他编辑操作 可视化模式v:按字符选定;V:按行选定; 结合编辑命令使用:d,c,y 撤销(undo)操作:u:撤销此前的操作; u:操作此前#个的操作;如4u,撤销此前的4次操作; 恢复此前的撤销操作:Ctrl+r 重复执行前一个编辑操作. vim自带的练习教程,使用命令:vimtutor vim末行模式: 内建的命令行接口 (1) 地址定界:start_pos[,end_pos]#:特定的第#行,例如5即第5行;.:当前行;$:最后一行;#,#:指定行范围,左侧为起始行,右侧为结束行;#,+#:指定行范围,左侧为起始行绝对编号,右侧为相对左侧行号的偏移量;例如:3+7.,$-1:从当前行到倒数第二行1,$:全文%:全文/pattern/:从光标所在处起始向文件尾部第一次被模式所匹配到的行;/first/,$:比如匹配光标所在处起始带有first的行之后的所有行;例如删除操作::/first/,$d/pat1/,/pat2/:从光标所在处起始,第一次由pat1匹配到的行开始,至第一次由pat2匹配到的行结束之间的所有行; 可同编辑命令一同使用,实现编辑操作:dycw /PATH/TO/SOMEFILE:将范围内的文本保存至指定的文件中;r /PATH/FORM/SOMEFILE:将指定的文件中的文本读取并插入至指定位置;例如将text.txt的5行加入到某文件::5r /root/test.txt (2) 查找/PATTERN:从当前光标所在处向文件尾部查找能够被当前模式匹配到的所有字符串;?PATTERN:从当前光标所在处向文件首部查找能够被当前模式匹配到的所有字符串;n:下一个,与命令方向相同;N:上一个,与命令方向相反; (3) 查找并替换$:末行模式的命令;使用格式:s/要查找的内容/替换为的内容/修饰符要查找的内容:可使用正则表达式;替换为的内容:不能使用正则表达式,但可以引用;如果\"要查找的内容\"部分在模式中使用分组符号:在\"替换为的内容\"中使用后向引用;如果\"要查找的内容\"部分在模式中没有使用分组符号:在\"替换为的内容\"中可以直接引用查找模式匹配到的全本文本;要使用&符号;修饰符:i:忽略大小写;g:全局替换,意味着一行中如果匹配到多次,则替换;(不使用全局替换,默认只替换匹配到每一行中的第一次出现) 末行模式下搜索全文所有的this替换成This且使用全局替换忽略大小写::%s/this/This/ig末行模式下搜索1,20行所有的this替换成This且使用全局替换忽略大小写::1,20s/this/This/ig 可把分隔符替换为其它非常用字符:s@@@s### 将/run/systemd替换为/etc/sysconfig:%s/\\/run\\/systemd\\/system/\\/etc\\/sysconfig/gi其中的\"/\"要用转义看起来可读性很差,我们可以用@或者#来表示分隔符:%s@/run/systemd/system@/etc/sysconfig@gi 替换文件中所有以小写t开头的单词,将t替换成大写的T:%s@\\@T\\1@g将所有t开头的单词后加上er,这里使用了直接引用::%s@\\@&er@g将以#开头的行首替换成空串:%s@^#@ 练习:1、复制/etc/grub2.cfg文件至/tmp目录中,用查找替换命令删除/tmp/grub2.cfg文件中以空白字符开头的行的行首的空白字符; :%s@^[[:space:]]\\+@ 2、复制/etc/rc.d/init.d/functions文件至/tmp目录中,用查找替换命令为/tmp/functions文件的每个以空白字符开头的行的行首加上#; :%s@^[[:space:]]@#& #如果不希望空白行前加#,可以如下写法 :%s@^[[:space:]]\\+[^[:space:]]@#& 3、为/tmp/grub2.cfg文件的前三行的行首加上#号; :1,3s@.\\+@#& 4、将/etc/yum.repos.d/CentOS-Base.repo文件中的所有的enabled=0替换为enabled=1,所有的gpgcheck=0替换为gpgcheck=1; %s@\\(enabled\\|gpgcheck\\)=0@\\1=1@g vim的多文件功能: 多文件:vim FILE1 FILE2 ...vim grub2.cfg functions storage.log 末行模式下多个打开的文件中切换：:next 切换到下一个文件:prev 切换到上一个文件:last 切换到最后一个文件:first 切换到第一个文件:wqall 保存所有文件并退出:wall 保存所有文件:qall 退出所有文件 多窗口:-o:水平分割窗口-O:垂直分割窗口 在窗口间切换:Ctrl+w,松开Ctrl单独按上、下、左、右键 注意:单个文件也可以分割为多个窗口进行查看:Ctrl+w,松开Ctrl单独按s:水平分割窗口Ctrl+w,松开Ctrl单独按v:垂直分割窗口 #水平分割窗口 vim -o grub2.cfg functions storage.log #垂直分割窗口 vim -O grub2.cfg functions storage.log 定制vim的工作特性 注意:在末行模式下的设定,仅对当前vim进程有效有效;永久有效:全局:/etc/vimrc用户个人:~/.vimrc1、行号显示:set number,简写为set nu取消显示:set nonumber,简写为set nonu 2、自动缩进启用:set autoindent,set ai禁用:set noautoindent,set noai 3、高亮搜索启用:set hlsearch禁用:set nohlsearch 4、语法高亮启用:syntax on禁用:syntax off 6、忽略字符大小写启用:set ic禁用:set noic 获取末行模式的帮助:只需要在末行模式下::help:help subject 比如::help:help set 7、搜索完关键字,去除关键字高亮显示在Vim里面如果要搜索某个关键字,只要键入/xxx就可以了,比如,搜索一个函数,键入/snprintf,然后回车,一个文件中,所有出现这个字样的地方都会被高亮显示。按n键，就可以自动把光标跳到下一个.但是,用好这个功能,怎么消除高亮呢?只需要末行模式下输入:noh即可; "},"pages/15.文件查找find和特殊权限及facl.html":{"url":"pages/15.文件查找find和特殊权限及facl.html","title":"15.文件查找find和特殊权限及facl","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 locate find Linux系统上的特殊权限 facl:访问控制列表(file access control lists) 对属组设置权限列表 设置指定用户权限列表没有权限 文件查找 在文件系统上查找符合条件的文件;实现工具:locate,find locate 依赖于事先构建好的索引库;系统自动实现(周期性任务计划):一般每天晚上空闲时间自动更新数据库;手动更新数据库(updatedb); 工作特性:查找速度快;模糊查找;非实时查找; locate [OPTION]... PATTERN...-b:只匹配路径中的基名;-c:统计出共有多少个符合条件的文件件;-r:基于基本正则表达式来编写模式; 注意:索引构建过程需要遍历整个根文件系统,极消耗资源; #只匹配路径中的基名,依然会模糊查找 locale -b passwd #只有基名中包含passwd的文件有多少个 locate -b -c passwd find 实时查找工具,通过遍历指定起始路径下文件系统层级结构完成文件查找; 工作特性:查找速度略慢;精确查找;实时查找; 用法:find [OPTIONS] [查找起始路径] [查找条件] [处理动作]查找起始路径:指定具体搜索目标起始路径;默认为当前目录;查找条件:指定的查找标准,可以根据文件名、大小、类型、从属关系、权限等等标准进行;默认为找出指定路径下的所有文件;处理动作:对符合查找条件的文件做出操作,例如删除等操作;默认为输出至标准输出; 查找条件:表达式:选项和测试 测试:结果通常为布尔型(\"true\",\"false\") 根据文件名查找:-name \"glob\"-iname \"glob\"支持glob通配符:*、?、[]、 -regex pattern:基于正则表达式模式查找文件,撇配是整个路径,而非其名; #精确查找passwd文件名的文件 find /etc -name \"passwd\" #在当前路径下查找所有文件,find和find./是一样的,默认查找当前目录所有文件; find find ./ #文件名不区分大小写查找和使用glob通配符 mkdir /etc/test touch /etc/test/Passwd touch /etc/test/MPASSWD.txt find /etc -iname \"passwd\" find /etc -iname \"*passwd*\" 根据文件从属关系查找:-user USERNAME:查找属主指定用户的所有文件;-group GRPNAME:查找属组指定组的所有文件;-uid:查找属主指定UID的所有文件;-gid:查找属组指定的GID的所有文件;-nouser:查找没有属主的文件;-nogroup:查找没有属组的文件; #根据属主查找 find /tmp -user \"archlinux\" #根据属组查找 find /tmp -group \"mygrp\" 根据属主,属组查找 find /tmp -user \"archlinux\" -group \"mygrp\" #根据用户id查找 id archlinux find /tmp -uid 4003 根据文件类型查找:-type TYPE:f:普通文件d:目录文件l:符号链接文件b:块设备文件c:字符设备文件p:管道文件s:套接字文件 #查找/dev,块设备文件,-ls代表的是处理动作,如果不加默认是-print find /dev -type b -ls #查找/etc,符号链接文件 find /etc -type l -ls 组合测试:与: -a,默认组合逻辑;或: -o;非: -not,!; 注意:组合测试加在两个测试之间; #默认是与,所以不加-a和加-a结果是一样的 find /tmp -user jesse -type f -ls find /tmp -user jesser -a -type f -ls , #查找属组为jesse或者为archlinux的文件,两边都要加-ls,只加一边的-ls,只显示那一边的列表;感觉-a并不存在此问题 find /tmp -user jesse -ls -o -user archlinux -ls #或者可以这么写 find /tmp \\( -user jesse -o -user archlinux \\) -ls #不是普通文件的列表 find /tmp -not -type f -ls 练习:1、找出/tmp目录下属主为非root的所有文件; find /tmp ! -user root -ls 2、找出/tmp目录下文件名不包含fstab字符串的文件; find /tmp ! -iname \"*fstab*\" -ls 3、找出/tmp目录下属主为非root,而且文件名不包含fstab字符串的文件;!A -a !B =!(A -o B)!A -o !B =!(A -a B) find /tmp ! -iname \"*fstab*\" -a ! -user root -ls #或者可以这么写 find /tmp ! \\( -iname \"*fstab*\" -o -user root \\) -ls 根据文件的大小查找:-size [+|-] #UNIT常用单位:k,M,G ls -lh /tmp #查找大小为35k的文件 find /tmp -size 35k #查找小于35k的文件,-35K的范围是0k-34k之间,34.1k也不在此范围内 find /tmp -size -35k #查找大于35k的文件,不包含35k find /tmp -size +35k 根据时间戳查找:atime:访问时间、mtime:修改时间、ctime:改变时间以\"天\"为单位:-atime-mtime-ctime 以\"分钟\"为单位:-amin-mmin-cmin #7天之前未访问过的文件,可以使用stat path/filename查看文件时间戳信息 find /tmp -atime +7 -ls #1天之内曾今修改过的文件 find /tmp -mtime -1 -ls 根据权限查找-perm [/|-] modemode:精确权限匹配;/mode:任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足;9位权限之间存在\"或\"关系;-mode:每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足;9位权限之间存在\"与\"关系; #精确权限匹配,查找当前目录下权限为644的文件 find ./ -perm 644 -ls #任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足 find ./ -perm /666 -ls #至少有一类用户有写权限的文件 find ./ -perm /222 -ls #至少有一类用户有执行权限的文件 find ./ -perm /111 -ls #查找其他用户有执行权限的文件 find ./ -perm /001 -ls #查找所有用户(u,g,o)都要有写权限的文件 find ./ -perm -222 -ls #至少有一个用户没有写权限的文件 find ./ -not -perm -222 -ls 处理动作:-print:输出至标准输出;默认的动作;-ls:类似于对查找到的文件执行ls -l命令,输出文件的详细信息;-delete:删除查找到的文件;-fls /PATH/TO/SOMEFILE:把查找到的所有文件的长格式信息保存至指定文件中;-ok COMMAND {} \\; :对查找到的每个文件执行由COMMAND表示的命令;每次操作都由用户进行确认;-exec COMMAND {} \\; :对查找到的每个文件执行由COMMAND表示的命令;不需要由用户进行确认; 注意:find传递查找到的文件路径至后面的命令时,是先查找出所有符合条件的文件路径,并一次性传递给后面的命令;但是有些命令不能接受过长的参数,此时命令执行会失败;另一种方式可以规避此问题;find | xargs COMMAND useradd centos #给c和e两个设置属主和属组为centos chown centos:centos c e #删除用户 userdel -r centos #将没有属主和属组的用户设置为root;其中{}是占位符表示引用找到文件的列表;其中的\\;是固定格式 find ./ -nouser -a -nogroup -exec chown root:root {} \\; #将其他用户有写权限的文件加上后缀.danger find ./ -perm /002 -exec mv {} {}.danger \\; 练习:1、查找/var目录下属主为root,且属组为mail的所有文件或目录; find /var -user root -group mail -ls 2、查找/usr目录下不属于root,bin或hadoop的所有文件或目录；用两种方法; find /usr ! -user root -a ! -user bin -a ! -user hadoop -ls find /usr ! \\( -user root -o -user bin -o -user hadoop \\) -ls 3、查找/etc目录下最近一周内其内容修改过,且属主不是root的用户也不是hadoop用户的文件或目录; find /etc -mtime -7 -a ! \\( -user root -o -user hadoop \\) -ls 4、查找当前系统上没有属主或属组,且最近一周内曾被访问过的文件或目录; find / \\( -nouser -o -nogroup \\) -a -atime -7 -ls 5、查找/etc目录下大于1M且类型为普通文件的所有文件; find /etc -size +1M -a -type f -ls #也可以使用-exec来执行ls -lh命令 find /etc -size +1M -a -type f -exec ls -lh {} \\; 6、查找/etc目录下所有用户都没有写权限的文件; find /etc -not -perm /222 -a -type f -exec ls -lh {} \\; 7、查找/etc目录至少有一类用户没有执行权限的文件; find /etc -not -perm -111 -a -type f -exec ls -lh {} \\; 8、查找/etc/init.d/目录下,所有用户都有执行权限,且其他用户有写权限的所有文件; find /etc/init.d/ -perm -113 -a -type f -exec ls -lh {} \\; Linux系统上的特殊权限 特殊权限:SUID、SGID、STICKY 安全上下文:1、进程以某用户的身份运行;进程是发起此进程用户的代理,因此以此用户的身份和权限完成所有操作;2、权限匹配模型:(1) 判断进程的属主,是否为被访问的文件属主;如果是,则应用属主的权限;否则进入第2步;(2) 判断进程的属主,是否属于被访问的文件属组;如果是,则应用属组的权限;否则进入第3步;(3) 应用other的权限; SUID:默认情况下:用户发起的进程,进程的属主是其发起者;因此,其以发起者的身份在运行;SUID的功用:用户运行某程序时,如果此程序拥有SUID权限,那么程序运行此进程时,进程的属主不是发起者,而是程序文件自己的属主; 管理文件的SUID权限:chmod u+|-s FILE... 展示位置:属主的执行权限位如果属主原本有执行权限,显示为小写s;否则,显示为大写S; #复制cat命令 cp /usr/bin/cat /tmp #查看权限 ll /tmp/cat #设置cat未SUID chmod u+s /tmp/cat #查看权限 ll /tmp/cat #从root切换用户至hadoop su - hadoop #使用SUID权限的cat,就可以查看/etc/shadow文件了,因为它会使用程序文件自己的属组 /tmp/cat /etc/shadow SGID:功用:当目录属组有写权限,且有SGID权限时,那么所有属于此目录的属组,且以属组身份在此目录中新建文件或目录时,新文件的属组不是用户的基本组,而是此目录的属组; 管理文件的SGID权限:chmod g+|-s FILE... 展示位置:属组的执行权限位如果属组原本有执行权限,显示为小写的s;否则为大写的S; #添加fedora和centos useradd fedora useradd centos #设置附加组为mygrp usermod -a -G mygrp centos usermod -a -G mygrp fedora #查看附加组 id centos id fedora #创建文件夹 mkdir /var/temp/test #设置该文件夹属组为mygrp且有写权限 chown :mygrp /var/tmp/test chmod g+w /var/tmp/test/ #设置SGID chmod g+s /var/tmp/test #查看该文件夹权限 ll -d /var/tmp/test #切换用户 su - centos #创建文件 touch /var/tmp/test/a.centos #切换用户 su - fedora #创建文件 touch /var/tmp/test/b.fedora #查看文件的属组为mygrp,而非自己的基本组(默认是自己的基本组) ll /var/tmp/test/ Stlcky:功用:对于属组或全局可写的目录,组内的所有用户或系统上的所有用户对在此目录中都能创建新文件或删除所有已有文件;如果为此类目录设置stlcky权限,则每个用户能创建新文件,且只能删除自己的文件; 管理文件的stlcky权限:chmod o+|-t FILE... 展示位置:其他用户的执行权限位如果其他用户原本有执行权限,显示为小写的T;否则为大写的T; 系统上的/tmp和/var/tmp目录默认均有stlcky权限;如:/tmp默认777权限,但是加了stlcky权限,用户可以在此文件夹内创建文件,只能删除自己创建的文件,不能删除别人创建的文件; 管理特殊权限的另一方式:基于八进制方式赋权时,可于默认的三位八进制数字左侧再加一位八进制数字;例如:chmod 1777;设置777且有stlcky权限; facl:访问控制列表(file access control lists) 文件的额外赋权机制:在原来的u,g,o之外,另一层让普通用户能控制赋权给另外的用户或组的赋权机制; getfacl命令:getfacl FILE...user:USERNAME:MODEgroup:GROUPNAME:MODE setfacl命令:赋权给用户:setfacl -m u:USERNAME:MODE FILE...赋权级组:setfacl -m g:GROUPNAME:MODE FILE... 撤销赋权:setfacl -x u:USERNAME FILE...setfacl -x g:GROUP FILE... #切换centos用户 su - centos cd /tmp #创建文件 touch test.centos #查看属主和属组都是centos ll test.centos #切换fedora用户 su - fedora #提示权限不够 echo hello > /tmp/test.centos #普通用户fedora想给其他用户附加权限需要使用facl,#切换用户至centos su - centos #请看下图，设置额外权限 #切换用户至fedora su - fedora #将hello重定向到test.centos文件 echo hello > /tmp/test.centos cat /tmp/test.centos 对属组设置权限列表 设置指定用户权限列表没有权限 登录hadoop用户,没有就没有读的权限了取消hadoop权限列表的权限hadoop用户就可以正常读取了,这时他使用的是其他用户的权限 "},"pages/16.磁盘及文件系统管理.html":{"url":"pages/16.磁盘及文件系统管理.html","title":"16.磁盘及文件系统管理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 设备类型: mknod命令 磁盘: 分区: 磁盘分区:MBR,GPT fdisk命令:用于管理磁盘分区表 1、查看磁盘的分区信息: 2、管理分区 其他分区创建工具:parted,sfdisk; 创建文件系统: 文件系统分:元数据区,数据区 VFS:Virtual File System 链接文件:访问同一个文件不同路径; 文件系统工具: 内核级文件系统的组成部分: ext系统文件系统的管理工具: xfs ext系列文件系统专用管理工具:mke2fs e2label可以用于查看和设置卷标(无需重新格式化修改) tune2fs命令:查看或者修改ext系列文件系统的某些属性(无需重新格式化修改) dumpe2fs命令:显示ext系列文件系统的属性信息 fsck命令:用于实现文件系统检测工具 ext系列文件系统的专用工具: blkid命令 swap文件系统 window无法识别Linux的文件系统 文件系统的使用: mount命令: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #或者设置文件类型拥有acl权限 - umount命令: - 一个使用技巧: - 查看当前系统所有已挂在的设备: - 挂载光盘 - 挂载U盘 - 正在访问的挂载点无法被卸载 - 挂载本地回环设备 - 交换分区的启用和禁用: - 设定除根文件系统以外的其它文件系统能够开机时自动挂载:/etc/stab文件 - df命令:查看磁盘的使用状态 - du命令:显示文件大小 - 练习: Linux磁盘及文件系统管理 CPU,Memory(RAM),I/O I/O:Disks,EhtercardDisks:持久存储数据 接口类型:IDE(ata):并口,133MB/SSCSI:并口,Ultrascsi320,320MB/S,Ultrascsi640,640MB/SSATA:串口,6gbpsSAS:串口,6gbpsUSB:串口,480MB/S 并口:同一线缆可以接多块设备;IDE:两个,有主设备和从设备SCSI:宽带:可以接16-1个设备窄带:8-1个设备 串口:同一个线缆只可以接1个设备 iops:io per second 硬盘:机械硬盘,固态; 机械硬盘:track:磁道sector:扇区,512bytescylinder:柱面分区划分基于柱面; 平均寻道时间:5400rpm,7200rpm,10000rpm,15000rpm linux哲学思想:一切皆文件 设备类型: 块(block):随机访问,数据交换单位是\"块\";字符(character):线性访问,数据交换单位\"字符\"; 设备文件:FHS/dev设备文件:关联至设备的驱动程序;设备的访问入口;设备号:major:主设备号,区分设备类型;用于标明设备所需要的驱动程序;minor:次设备号,区分同种类下的不同的设备;是特定设备的访问入口; mknod命令 创建块或字符设备,(make block or character special files)-m MODE:创建后的设备文件的访问权限; 磁盘: IDE:/dev/hd[a-z]例如:/dev/hda,/dev/hdbSCSI,SATA,USB,SAS:/dev/sd[a-z] 分区: /dev/sda#: 如:/dev/sda1,sda2... 注意:CentOS6和7统统将硬盘设备文件标识为/dev/sd[a-z]# 引用设备的方式:设备文件名卷标UUID 磁盘分区:MBR,GPT MBR:0编号号扇区(0 sector)主引导记录或者叫主引导扇区(Master Boot Record)分为三部分:446bytes:bootloader程序,引导启动操作系统的程序;64bytes:分区表,每16bytes标识一个主分区,一共只能有4个主分区;3主1扩展:扩展分区又可以划分n个逻辑分区;这就是为什么操作系统可以分超过4个分区的原因2bytes:MBR区域的有效性标识;55AA为有效,否则为无效; 主分区和扩展分区的标识:1-4逻辑分区:从5开始 fdisk命令:用于管理磁盘分区表 1、查看磁盘的分区信息: fdisk -l [-u] [device ...]:列出指定磁盘设备上的分区情况; #查看分区信息 fdisk -l #查看某一块硬盘可以跟上硬盘的设备文件名 fdisk -l /dev/sda1 2、管理分区 fdisk device提供一个交互式接口来管理分区,它有许多子命令,分别用于不同的管理功能;所有的操作均在内存中完成,没有直接同步到磁盘；直到使用w命令保存至磁盘上;常用命令:n:创建新分区d:删除已有分区t:修改分区类型i:查看所有已知IDw:保存并退出q:不保存退出m:查看帮助信息p:显示现有分区信息l:列出已知分区类型 fdisk /dev/sda 注意:在已经分区并且已经挂载其中某个分区的磁盘设备上创建的新分区,内核可能在创建完成后无法直接识别;使用:cat /proc/partitions查看是否识别;通知内核强制重读磁盘分区表:CentOS5:partprobe [device]CentOS6,7:partx,kpartxpartx -a [device]kpartx -a [device] #这个命令可能要执行两次才能成功 partx -a /dev/sda partx -a /dev/sda 其他分区创建工具:parted,sfdisk; 创建文件系统: 格式化:低级格式化(分区之前进行,划分磁道)、高级格式化(分区之后对分区进行,创建文件系统) 文件系统分:元数据区,数据区 元数据区:文件元数据,inode(index node),inode table:用于存放大小、权限、属主属组、时间戳、数据块指针(它指向了哪些编号的数据块(data blocks),是属于该文件的)、...; 符号链接文件:存储数据块指针的空间当中存储的是真实文件的访问路径;权限:lrwxrwxrwx; 硬链接:指向同一个inode; 设备文件:存储数据块指针的空间当中存储的是设备号(major,minor); bitmap index:位图索引:元数据区存储着二进制位的空间,每一位对应一个数据块,0表示数据块是空闲的,1表示数据块已分配; 数据块和inode都有位图索引:通过扫描inode或数据块的位图索引,来获取哪些数据块(已分匹配或空闲; linux中文件名是存放在它的上级目录中; 删除文件:将此文件指向的所有data block标记为未使用状态;将此文件的inode标记为未使用; 复制和移动文件:复制:新建文件;移动文件:在同一文件系统:改变的仅是其路径;在不同文件系统:复制数据至目标文件,并删除原文件; #查看inode的编号 ls -i #使用stat查看inode中存放的元数据 stat fstab VFS:Virtual File System Linux的文件系统:ext2(无日志功能),ext3,ext4,xfs,relserfs,btrfs光盘:iso9660网络文件系统:nfs,cifs集群文件系统:gfs2,ocfs2内核级分布式文件系统:cephwindows的文件系统:vfat,ntfs伪文件系统:proc,sysfs,tmpfs,hugepagefsUnix的文件系统:UFS,FFS,JFS交换文件系统:swap用户控件的分布式文件系统:mogilefs,moosefs,glusterfs 链接文件:访问同一个文件不同路径; 硬链接:指向同一个inode的多个文件路径;特性:(1) 目录不支持硬链接;(2) 硬链接不能跨文件系统;(3) 创建硬链接会增加inode引用计数; 符号链接:指向一个文件路径的另一个文件路径;特性:(1) 符号链接与源文件是两个各自独立的文件,各有自己的inode;对原文件创建符号链接不会增inode加引用计数;(2) 支持对目录创建符号链接,可以跨文件系统;(3) 删除符号链接文件不影响原文件;但删除原文件,符号链接指定的路径即不存在,此时会变成无效链接; 注意:符号链接文件的大小是其指定的文件的路径字符串的字节数; 文件系统工具: 创建文件系统的工具mkfsmkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.xfs,mkfs.vfat,.... 检测及修复文件系统的工具fsckfsck.ext2,fsck.ext3,fsck.xfs,... 查看其属性的工具dumpe2fs,tune2fs 调整文件系统特性:tune2fs 内核级文件系统的组成部分: 文件系统驱动:由内核提供文件系统管理工具:由用户控件的应用程序提供 ext系统文件系统的管理工具: mkfs.ext2,mkfs.ext3,mkfs.ext4命令还可以使用选项-t: #两个命令一样 mkfs.ext2 /dev/sda3 mkfs -t ext2 /dev/sda3 xfs 创建使用:mkfs.xfs检测使用:fsck.xfs CentOS6使用xfs需要安装,使用yum -y install xfsprogs ext系列文件系统专用管理工具:mke2fs mke2fs [OPTIONS] device-t {ext2|ext3|ext4}:指明要创建的文件系统类型;-b {1024|2048|4096}:指明文件系统的块大小;-L LABEL:指明卷标;-j:创建有日志功能的文件系统;-i #:byte-per-inode,指明Inode与字节的比率;即每多少字节创建一个inode;-N #:直接指明要给此文件系统创建的inode的数量;-O FEATURE:以指定的特性创建目标文件系统;-m #:指定预留的空间,百分比;(默认给管理员预留的空间百分比为5%;) #指明文件系统的块大小为2048 mke2fs -b 2048 /dev/sda3 #指明卷标名称为MYDATA,块大小1024;文件系统使用ext3 mke2fs -t ext3 -b 1024 -L MYDATA /dev/sda3 #这里指定特性为加入日志,所以没指定文件系统类型,默认会使用ext3(ext3类型开始有日志) mke2fs -O has_journal /dev/sda3 e2label可以用于查看和设置卷标(无需重新格式化修改) tune2fs命令:查看或者修改ext系列文件系统的某些属性(无需重新格式化修改) 注意:块大小创建后不可修改; tune2fs [OPTIONS] device-l:查看超级块的内容; 修改指定文件系统的属性:-j:ext2-->ext3;-L LABEL:修改卷标;-m #:调整预留空间百分比;-O FEATHER:开启或关闭某种特性;-o mount_options:开启或关闭某种默认挂载选项; #设置文件系统为ext2 mke2fs -t ext2 /dev/sda3 #查看 blkid /dev/sda3 #设置文件系统为ext3 tune2fs -j /dev/sda3 #查看 blkid /dev/sda3 #调整空间预留百分比为2% tune2fs -m 2 /dev/sda3 #关闭jornal日志功能 tune2fs -O ^has_journal /dev/sda3 #然后发现文件系统类型变成了ext2 blkid /dev/sda3 #开启jornal日志功能 tune2fs -O has_journal /dev/sda3 #文件系统类型变成了ext3 blkid /dev/sda3 #加入默认挂载选项acl tune2fs -o acl /dev/sda3 #查看Default mount options里加入了acl tune2fs -l /dev/sda3 dumpe2fs命令:显示ext系列文件系统的属性信息 dumpe2fs [-h] device #ext系列文件系统的属性信息 dumpe2fs /dev/sda3 #只显示超级块信息 dumpe2fs -h /dev/sda3 fsck命令:用于实现文件系统检测工具 因进程意外终止或者系统崩溃等原因导致写入操作非正常终止时,可能会造成文件损坏;此时,应该检测并修复文件系统;建议离线进行;fsck:check and repair a linux file system-t stype:指明文件系统类型;fsck -t ext4 = fsck.ext4-a:无需交互而自动修复所有错误;-r:交互式修复; fsck -t ext4 /dev/sda3 ext系列文件系统的专用工具: e2fsck:check a Linux ext2/ext3/ext4 file systeme2fsck [OPTIONS] device-y:对所有问题自动回答为yes;-f:即使文件系统处于clean状态,也要强制进行检测; e2fsck -f /dev/sda3 blkid命令 blkid deviceblkid -L LABEL:根据LABEL定位设备blkid -U UUID:根据UUID定位设备 #设置卷标 e2label /dev/sda3 MYDATA #通过卷标查找某个卷标所对应的设备 blkid -L MYDATA swap文件系统 Linux上的交换分区必须使用独立的文件系统;且文件系统的System ID必须为82; 创建swap设备:mkswap命令mkswap [OPTIONS] device-L LABEL:指明卷标-f:强制创建 window无法识别Linux的文件系统 因此,存储设备需要两种系统之间交叉使用时,应该使用windows和linux同时支持的文件系统:fat32(vfat);mkfs.vfat device 文件系统的使用: 首先要\"挂载\":mount命令和unmount命令 根文件系统之外的其它文件系统要想能够被访问,都必须通过\"关联\"至根文件系统上的某个目录来实现,此关联操作即为\"挂载\";此目录即为\"挂载点\";挂载点:mount_point,用于作为另一个文件系统的访问入口;(1) 事先存在;(2) 应该使用未被或不会被其他进程使用到的目录;(3) 挂载点下原有的文件将会被隐藏; mount命令: mount [-nrw] [-t vfstype] [-o options] device dir 命令选项:-r:readonly,只读挂载;比如光驱;-w:read and write,读写挂载;默认值;-n:默认情况下,设备挂载或卸载的操作会同步更新至/etc/mtab文件中;-n用于禁止此特性; -t vfstype:指明要挂载的设备上的文件系统类型;多数情况下可省略,此时mount会通过blkid来判断要挂载的设备的文件系统类型; -L LABEL:挂载时以卷标的方式指明设备; mount -L MYDATA /media -U UUID:挂载时以UUID方式指明设备; mount -U fa3a9607-558a-4148-94ff-da25f0432de4 /mnt -o options:挂载选项(挂载时的文件系统特性)sync/async:同步/异步操作;进程每一次所访问的数据默认应该是在磁盘上的,进程不可能操作磁盘数据,需要把数据装到内存中,在内存中执行读写操作异步:先在内存中写完,过一会再写到磁盘上同步:在内存中一写,立即写到磁盘上 atime/noatime:文件或目录在被访问时是否更新其访问的时间戳;atime:某个文件或目录被访问时,立即更新其访问时间戳noatime:不更新其访问时间戳;某个文件或目录被访问就更新其访问的时间戳,会给系统带来IO压力;尤其是WEB服务器上的文件,一秒访问上万次; diratime/nodirname:目录在被访问时是否更新其访问的时间戳;remount:重新挂载;acl:支持使用facl功能;ro:只读;rw:读写;dev/nodev:此设备上是否允许创建设备文件;exec/noexec:是否允许运行此设备上的程序文件;auto/noauto:是否允许自动挂载;user/nouser:是否允许普通用户挂载此文件系统;suid/nosuid:是否允许程序文件上的suid和sgid特殊权限生效;relatime/norelatime:是否参考修改后的改变时间,来更新inode的访问时间;如果你的文件更新时间没有修改,则访问时间就不修改;defaults:Use default options: rw, suid, dev, exec, auto, nouser, and async;(默认使用的选项) #显示当前所有已挂载的文件系统 mount #显示当前所有已挂载的文件系统,和mount效果一样 cat /etc/mtab #将/dev/sda3挂载到到/mnt mount /dev/sda3 /mnt #查看挂载信息 mount|grep \"/dev/sda3\" #拷贝文件到/mnt下 cp /etc/fstab /mnt #查看可以看到fstab文件 ls /mnt #卸载 unmout /mnt #fatab文件就没有了 ls /mnt #你把它挂到哪就能通过哪访问,比如挂载到media mount /dev/sda3 /media #查看 ls /media #重新挂载,并使其用用facl权限特性;xfs文件类型不支持一下命令 mount -o remount,acl /dev/sda3 /mnt/ #复制文件 cp /etc/fstab /mnt #设置acl权限 setfacl -m u:centos:rw- /mnt/fstab #查看acl权限 getfacl /mnt/fstab ################################################### #或者设置文件类型拥有acl权限 tune2fs -o acl /dev/sda3 #查看其Default mount options选项里有acl权限 tune2fs -l /dev/sda3 #设置acl权限 setfacl -m u:fedora:rw- /mnt/fstab #查看acl权限 getfacl /mnt/fstab 只读挂载: 通过卷标挂载 umount命令: umount device | dir 注意:正在被进程访问到的挂载点无法被卸载;比如cd到挂载目录就无法卸载; 一个使用技巧: 可以实现将目录绑定至另一个目录上,作为其临时访问入口;mount -bind 源目录 目标目录 #将/etc绑定到/mnt目录 mount --bind /etc /mnt ls /mnt umount /mnt ls /mnt 查看当前系统所有已挂在的设备: mount cat /etc/mtab cat /proc/mounts 挂载光盘 mount -r /dev/cdrom mount_point光盘设备文件:/dev/cdrom,/dev/dvd mount -r /dev/cdrom /media 挂载U盘 事先识别U盘的设备文件; 正在访问的挂载点无法被卸载 查看被哪个或那些进程所占用lsof MOUNT_POINTfuser -v MOUNT_POINT 终止所有正在访问某挂载点的进程:fuser -km MOUNT_POINT #一个shell进程cd到挂载目录,就占用了此挂载,用unmount卸载会提示被占用 cd /mnt #显示哪一个进程占用此挂载 lsof /mnt fuser -v /mnt #终止所有/mnt挂载点的进程 fuser -km /mnt 挂载本地回环设备 回环文件比如:.iso、.img文件mount -o loop /PATH/TO/SOME_LOOP_FILE MOUNT_POINT mount -r -o loop ~/CentOS-6.8-x86_64-bin-DVD1.iso /mnt ls /mnt 交换分区的启用和禁用: 创建交换分区的命令:mkswap 启用:swaponswapon [OPTION] [DEVICE]-a:定义在/etc/fstab文件中的所有swap设备; 禁用:swapoffswapoff DEVICE 设定除根文件系统以外的其它文件系统能够开机时自动挂载:/etc/stab文件 每行定义一个要挂载的文件系统的相关属性:6个字段:(1) 要挂载的设备;设备文件;LABEL;UUID;伪文件系统:如:sysfs,proc,tmpfs等; (2) 挂载点swap类型的设备的挂载点为swap; (3) 文件系统类型; (4) 挂载选项defaults:使用默认挂载选项;如果要同时指明多个挂载选项,彼此间以逗号分隔;例如:defaults,acl,noatime,noexec (5) 转储频率0:从不备份;1:每天备份;2.每隔一天备份; (6) 自检次序(设备的自检分先后)0:从不备份;1:每天备份,通常只能是根文件系统可用1;2:次级自检... vim编辑/etc/fstab文件 #创建上图中挂载点的文件夹 mkdir /mydata #表示能够把/etc/fstab文件中所有定义的支持自动挂载的设备都给挂载上来 mount -a #查看挂载的信息 mount|grep \"/dev/sda3\" 也可以通过卷标来挂载,vim编辑/etc/fstab文件 df命令:查看磁盘的使用状态 df [OPTIONS]... [FILE]...-l:仅显示本地文件的相关信息;-h:human-readble,人类易于理解的格式;-i:显示inode的使用状态而非blocks; df -h du命令:显示文件大小 du [OPTIONS]... [FILE]...-s:summary-h:human-readable #ll -dh /etc只能显示etc目录本身占用的大小 ll -dh /etc #用于显示/etc下所有文件的大小列表 du /etc #/etc下所有文件大小合计 du -s /etc #/etc下所有文件大小合计,并human readble的方式显示 du -sh /etc 练习: 1、创建一个10G的分区,并格式化为ext4文件系统;(1) block大小为2048;预留空间为2%,卷标MYDATA;(2) 挂载至/mydata目录,要求挂载时禁止程序自动运行,且不更新文件的访问时间戳,默认要有acl挂载选项；(3) 可开机自动挂载; 先用fdisk创建1个10G的分区 #为分区格式化创建文件系统 mke2fs -t ext4 -b 2048 -m 2 -L MYDATA /dev/sda3 #查看 blkid /dev/sda3 #挂载 mount -o noexec,noatime,acl /dev/sda3 /mydata 在/etc/fstab文件中加入以下行:shell LABEL=MYDATA /mydata ext4 defaults 0 0 2、创建一个大小为1G的swap分区,并启动之 "},"pages/17.shell条件测试,逻辑判断,参数传递.html":{"url":"pages/17.shell条件测试,逻辑判断,参数传递.html","title":"17.shell条件测试,逻辑判断,参数传递","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 向脚本传递参数 特殊变量 选择执行: 用户交互:通过键盘输入数据,从而完成变量赋值操作; 检测脚本中的语法错误 调试执行 练习 条件测试 判断某需求是否满足,需要由测试机制来实现; 如何编写测试表达式以实现所需的测试:(1) 执行命令,并利用命令状态返回值来判断;0:成功1-255:失败 #判断是否有空白行 grep \"^$\" /etc/rc.d/init.d/functions &> /dev/null #查看命令状态返回值 echo $? #判断登录用户名为centos的用户 who | grep \"^centos/>\" #查看命令状态返回值 echo $? (2) 测试表达式test EXPRESSION[ EXPRESSION ][[ EXPRESSION ]] 注意:EXPRESSION两端必须有空白字符,否则为语法错误; bash的测试类型:数值测试字符串测试文件测试 数值测试:数值比较-eq:是否等于; [ $num1 -eq $num2 ]-ne:是否不等于;-gt:是否大于;-ge:是否大于等于;-lt:是否小于;-le:是否小于等于; test 2 -eq 3 echo $? test 2 -ne 3 echo $? 字符串测试:==:是否等于; :是否大于;!=:是否不等于;=~:左侧字符串是否能够被右侧的PATTERN所匹配;-z \"STRING\": 判断指定的字符串是否为空;空则为真,不空则假;-n \"STRING\": 判断指定的字符串是否不为空;不空为真,不空为假; [ tom == Tom ] echo $? [ tom == tom ] echo $? #判断是否为空 [[ -z \"\" ]] echo $? #判断是否为空 [[ -z \"abc\" ]] echo $? 注意:变量做比较,万一某个变量的值为空就麻烦了;使用变量作比较记得给变量加双引号; 字符串比较,要使用[[ ]] name=tom #匹配字符串中是否有o这个字符 [[ $name =~ o ]] echo $? name=jerry [[ $name =~ o ]] echo $? 文件测试存在性测试:存在则为真,否则则为假;-a和-e都用于表示文件存在性测试,一般使用-e-a /PATH/FILE-e /PATH/FILE #查看文件是否存在 [ -e /etc/fstab ] echo $? 存在性及类型测试-b FILE:是否存在并且为块设备文件;-c FILE:是否存在并且为字符设备文件;-d FILE:是否存在并且为目录文件;-f FILE:是否存在并且为普通文件;-h FILE或-L FILE:是否存在并且为符号链接文件;-p FILE:是否存在且为命名管道文件;-S FILE:是否存在且为套接字文件; #判断是否存在且是块设备 [ -b /dev/sda ] echo $? #查看文件类型 file /dev/sda [ -b /dev/sdb ] echo $? 文件权限测试:-r FILE:是否存在并且对当前用户可读;-w FILE:是否存在并且对当前用户可写; -x FILE:是否存在并且对当前用户可执行; 特殊权限测试： -u FILE:是否存在并且拥有suid权限;-g FILE:是否存在并且拥有sgid权限;-k FILE:是否存在并且用用stlcky权限; #是否存在并且拥有suid权限 [ -u /usr/bin/passwd ] echo $? 文件是否有内容:-s FILE:是否有内容; touch /tmp/hello #新建的文件肯定没有内容 [ -s /tmp/hello ] echo $? 文件时间戳测试:-N FILE:文件自从上一次读操作后是否被修改过; 从属关系测试:-O FILE:当前用户是否为文件的属主;-G FILE:当前用户是否属于文件的属组; 双目测试:FILE1 -ef FILE2:测试FILE1与FILE2是否为指向同一个文件系统的相同inode的硬链接;FILE1 -nt FILE2:FILE1更新时间是否新于FILE2;FILE1 -ot FILE2:FILE1更新时间是否旧于FILE2; 组合测试条件:逻辑运算:第一种方式:COMMAND1 && COMMAND2COMMAND1 || COMMAND2!COMMAND 测试文件是否为属主,并且可读[ -O FILE ] && [ -r FILE ] [ -O /etc/fstab ] && [ -r /etc/fstab ] echo $? 第二种方式:[ EXPRESSION1 -a EXPRESSION2 ][ EXPRESSION1 -o EXPRESSION2 ][ ! EXPRESSION1 ] [ -O /etc/fstab -a -x /etc/fstab ] echo $? 练习:将当前主机名称保存至hostName变量中;主机名如果为空,或者为localhost.localdomain,则将其设置为www.abc.com; hostName=$(hostname) [ -z \"$hostName\" -o \"$hostName\" == \"localhost.localdomain\" ] && hostname www.abc.com hostname 脚本的状态返回值:默认是脚本中执行的最后一条命令的状态返回值;自定义状态退出状态码;exit [n]:n为自己指定的状态码; 0:成功,1-255:失败;注意:shell进程遇到exit时,即会终止,因此,整个脚本执行即为结束; id user1 &> /dev/null && exit 0 || useradd user1 向脚本传递参数 #像/etc,/var传递给命令的参数,称之为位置参数 ls /etc /var 位置参数变量myscript.sh argu1 argu2引用方式:$1,$2,....,${10},${11},... 给shell脚本传递参数以下使用vim编辑器编写sum.sh文件如下: #!/bin/bash echo $[$1+$2] 执行以上脚本 bash sum.sh 10 20 轮替:shift [n]:位置参数轮替;shift.sh文件创建 #/bin/bash echo \"First pos args:$1\" #踢掉了第一个参数 shift echo \"First pos args:$1\" 执行以上脚本 bash shift.sh one two 修改shift.sh文件 #/bin/bash echo \"First and second pos args:$1,$2\" #踢掉前两个参数 shift 2 echo \"Third pos args:$1\" 执行以上脚本 bash shift.sh one two three 练习:写一个脚本,通过命令传递两个文本文件路径给脚本,计算其空白行数之和;lines.sh文件: #!/bin/bash linecount1=$(grep \"^$\" $1 | wc -l) linecount2=$(grep \"^$\" $2 | wc -l) echo \"total black lines:$[$linecount1+$linecount2]\" 执行以上脚本 bash lines.sh /etc/fstab /etc/rc.d/init.d/functions 特殊变量 $0:脚本文件路径本身;$#:脚本参数的个数;$*:所有参数;(\"hello\" \"hi\" \"toyou\")$@:所有参数;(\"hello hi toyou\") pos.sh文件如下: #!/bin/bash echo \"脚本文件本身:$0\" echo \"只取脚本文件名:$(basename $0)\" echo $1,$2 echo \"脚本参数个数:$#\" echo $* echo $@ 执行以上脚本: chmod +x pos.sh ./pos.sh hello hi toyou 修改之前lines.sh文件如下: #!/bin/bash [ $# -lt 2 ] && echo \"至少需要两个参数\" && exit 1 linecount1=$(grep \"^$\" $1 | wc -l) linecount2=$(grep \"^$\" $2 | wc -l) echo \"total black lines:$[$linecount1+$linecount2]\" 执行以上脚本: chmod +x lines.sh ./lines.sh /etc/fstab 选择执行: 单分支语句:if 测试条件; then代码分支fi 双分支的if语句:if 测试条件;then条件为真时执行分支else条件为假时执行的分支fi 示例:通过参数传递一个用户名给脚本,此用户不存在时,则添加之;创建useradd.sh文件: #!/bin/bash if [ $# -lt 1 ];then echo \"请输入需要创建的用户名\" exit 2 fi if ! grep \"^$1\\>\" /etc/passwd &> /dev/null; then useradd $1 echo $1 | passwd --sdtin $1 &> /dev/null echo \"Add user $1 finished.\" else echo \"用户已经存在!\" fi ~ 执行以上脚本 chmod +x useradd.sh ./useradd.sh zhangsan echo $? 用户交互:通过键盘输入数据,从而完成变量赋值操作; read [option]... [name]...-p 'PROMPT'-t TIMEOUT #read是一个内嵌命令,它也有外部命令的实现 type read #read后面的name是个变量,会等待接收用户键盘输入内容赋值给name变量 read name #输出变量信息 echo $name #使用-p代表PROMPT提示信息 read -p \"请输入用户名:\" name echo $name #-t 5代表5秒钟不操作,则自动退出输入 read -t 5 -p \"请输入用户名:\" name 示例 #!/bin/bash read -p \"请输入用户名:\" name [ -z \"$name\" ] && echo \"请输入用户名!\" && exit 2 read -p \"请输入密码(默认为123456):\" pwd [ -z \"$pwd\" ] && pwd=\"123456\" if id $name &> /dev/null;then echo \"$name 已经存在!\" else useradd $name echo $pwd | passwd --stdin $name echo \"Add User $name finished.\" fi 检测脚本中的语法错误 bash -n /path/to/some_script 调试执行 bash -x /path/to/some_script例如下面的练习1使用调试执行 练习 1、通过命令行参数给定两个数字,输出其中较大的数值; #!/bin/bash declare -i max if [ $# -lt 2 ]; then echo \"至少要两个参数!\" fi if [ $1 -gt $2 ];then max=$1 else max=$2 fi echo \"max number:$max.\" #调试执行 bash -x big.sh 5 10 2、通过命令行参数给定一个用户名,判断其ID号是偶数还是奇数; 3、通过命令行参数给定两个文本文件名,如果某文件不存在,则结束脚本执行; 都存在时返回每个文件的行数,并说明其中行数较多的文件; 4、写一个脚本,完成如下功能:(1) 列出当前系统识别到的所有磁盘设备;(2) 如磁盘数量为1,则显示其空间使用信息;否则,则显示最后一个磁盘上的空间使用信息; #!/bin/bash disks=$(fdisk -l /dev/[sh]d[a-z] | grep -o \"磁盘 /dev/[hs]d[a-z]\" | wc -l) if [ $disks -eq 1 ];then fdisk -l /dev/[hs]da else fdisk -l /dev/[sh]d[a-z] | grep -o \"磁盘 /dev/[hs]d[a-z]\" | tail -1 | cut -d' ' -f2 fi 5、接收用户输入磁盘名称,获取磁盘名称的信息 #!/bin/bash read -p \"请输入磁盘名称:\" diskfile [ -z $diskfile ] && echo \"必须输入磁盘名称!\" && exit 2 if fdisk -l | grep \"磁盘 $diskfile\" &> /dev/null;then fdisk -l $diskfile else echo \"错误的磁盘名称\" exit 2 fi "},"pages/18.RAID技术.html":{"url":"pages/18.RAID技术.html","title":"18.RAID技术","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 watch命令: 示例:创建一个4G可用空间的RAID5 练习: RAID: Redundant Arrays of Independent Disks 独立冗余磁盘阵列 提高IO能力:磁盘并行读写;提高耐用性:磁盘冗余来实现; RAID实现方式:外接式磁盘阵列:通过扩展卡提供适配能力内接式RAID:主板集成RAID控制器Software RAID 级别 level:多块磁盘组织在一起的工作方式有所不同;RAID-0: 0,条带卷,strip;RAID-1: 1,镜像卷,mirror;RAID-2...RAID-5RAID-6组合RAID-0和RAID-1的两种级别:RAID10RAID01 RAID-0:读、写性能提升;可用空间:N*min(S1,S2,...)无容错能力最少磁盘数:2,2+ RAID-1:读性能提升、写性能略有下降;可用空间:1*min(S1,S2,...)有冗余能力最少磁盘数:2,2+ RAID-4:1101,0110,1011 RAID-5:读、写性能提升可用空间:(N-1)*min(S1,S2,...)有容错能力:1快磁盘最少磁盘数:3,3+ RAID-6:读、写性能提升可用空间:(N-2)*min(S1,S2,...)有容错能力:2块磁盘最少磁盘数:4,4+ 混合类型RAID-10:读、写性能提升可用空间:N*min(S1,S2,...)/2有容错能力:每组镜像最多只能块一块最少磁盘数:4,4+ RAID-01、RAID-50、RAID7 JBOD:Just a Bunch Of Disks功能:将多块磁盘的空间合并一个大的连续空间使用;可用空间:sum(S1,S2,...) 常用级别:RAID-0,RAID-1,RAID-5,RAID-10,RAID-50,JBOD 软件实现方式(了解即可,没有硬件做实验)CentOS6上的软件RAID实现:结合内核中的md(multi devices) mdadm:模式化工具命令的语法格式:mdadm [mode] [options] 支持的RAID级别:LINEAR,RAID0,RAID1,RAID4,RAID5,RAID6,RAID10; 模式:创建:-C 装配:-A (主机坏了,还可以使多个硬盘装配成RAID使用)监控:-F 管理:-f,-r,-a :/dev/md# :任意块设备 -C:创建模式-n #:使用#个块设备来创建此RAID;-l #:指明要创建的RAID的级别;-a {yes|no}:自动创建目标RAID设备的设备文件;-c CHUNK_SIZE:指明块大小;-x #:指明空闲盘的个数; -D:显示RAID的详细信息;mdadm -D /dev/md# 管理模式:-f:标记指定磁盘为损坏;-a:添加磁盘;-r:移除磁盘; 查看所有md类型的状态:cat /proc/mdstat 停止md设备:mdadm -S /dev/md# watch命令: -n #:刷新间隔 #每间隔一秒刷新网卡信息,-n1代表秒数 watch -n1 'ifconfig ens33' 示例:创建一个4G可用空间的RAID5 首先先创建4个4G的逻辑分区要想使用软RAID:分区需要使用fd这种类型,即:linux raid auto;所以将4个分区调整为fd类型;使用cat /proc/mdstat查看所有md设备的状态;也可用ls /dev | grep \"md\"查看是否用md设备,以免名字重复;创建RAID5:mdadm -C /dev/md0 -a yes -n 3 -x 1 -l 5 /dev/sda{5,6,7,8}使用watch cat /proc/mdstat查看4个磁盘按位对齐的进度做格式化:mke2fs -t ext4 /dev/md0创建目录:mkdir /mydata挂载:mount /dev/md0 /mydata 并使用mount | grep /dev/md0查看挂载的信息查看磁盘信息:df -lh查看设备md0的详细信息:mdadm -D /dev/md0标记某个磁盘为损坏:mdadm /dev/md0 -f /dev/sda5使用watch -n 1 cat /proc/mdstat可以看到它会重新做同步操作再次查看设备md0的信息:mdadm -D /dev/md0,发现/dev/sda5被标记为faulty(损坏),空闲磁盘/dev/sda8自动启用,数据会自动修复完成再标记某个磁盘为损坏mdadm /dev/md0 -f /dev/sda6使用mdadm -D /dev/md0查看发现状态变为:State:degraded了,代表降级使用,磁盘还是可以进行操作,只是性能差了些我们也可以用命令移除损坏的磁盘:mdadm /dev/md0 -r /dev/sda5 /dev/sda6再次查看mdadm -D /dev/md0,损坏(faulty)损坏的磁盘已经不在了假设新买了2块硬盘要加入到RAID中,可以使用mdadm /dev/md0 -a /dev/sda5 /dev/sda6 查看加入的磁盘mdadm -D /dev/md0等recovering完后,RAID恢复到State:Clean(完整)状态 练习: 1、创建一个可用空间为10G的RAID1设备,要求其chunk大小为128k,文件系统为ext4,有一个空闲盘,开机可自动挂载至/backup目录;2、创建一个可用空间为10G的RAID0设备,要求其chunk大小为256k,文件系统为ext4,开机可自动挂载至/mydata目录; "},"pages/19.LVM2.html":{"url":"pages/19.LVM2.html","title":"19.LVM2","keywords":"","body":""},"pages/20.btrfs文件系统.html":{"url":"pages/20.btrfs文件系统.html","title":"20.btrfs文件系统","keywords":"","body":""},"pages/21.压缩工具.html":{"url":"pages/21.压缩工具.html","title":"21.压缩工具","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 gzip/gunzip/zcat bzip2/bunzip2/bzcat xz/unxz/xzcat 注意:以上三款压缩工具只能用来压缩文件,不能用于压缩目录 tar zip 练习: 压缩和解压缩工具 压缩比:根据算法好坏,压缩效果有所差异目的:时间换空间CPU的时间 --> 磁盘空间 .z compress/uncompress(了解,目前没人用).gz gzip/gunzip.bz2 bzip2/bunzip2.xz xz/unxz.lzma lzma/unlzma.zip zip/unziptar,cpio gzip/gunzip/zcat gzip [OPTION]... FILE...-d:解压缩,相当于gunzip;-#:指定压缩比,默认是6;数字(1-9)越大压缩比越大,意味着所需要消耗的CPU时间周期越多,节约的空间也越多;一般默认压缩比是比较优秀的设定;-c:将压缩结果输出至标准输出; cp /var/log/messages /tmp cd /tmp #压缩,压缩会删除源文件 gzip message #使用zcat直接查看压缩后的文本文件内容,如果文件非常大,建议不要使用zcat来查看.适合查看小文件 zcat message.gz #解压 gunzip message.gz #压缩,指定压缩比为9 gzip -9 message #解压 gzip -d messages.gz #保留源文件,并将压缩文件从定向在当前目录 gzip -c messages > messages.gz bzip2/bunzip2/bzcat bzip2 [OPTION]... FILE...-d:解压缩-#:指定压缩比,默认是6;数字(1-9)-k:keep,压缩保留源文件 #压缩,压缩会删除源文件 bzip2 messages #解压缩 bzip2 -d messages.bz2 #压缩,保留源文件 bzip2 -k messages #查看压缩后的文本文件内容 bzcat messages.bz2 xz/unxz/xzcat xz [OPTION]... FILE...-d:解压缩-#:指定压缩比,默认是6;数字(1-9)-k:keep,压缩保留源文件 #压缩,压缩会删除源文件 xz messages 注意:以上三款压缩工具只能用来压缩文件,不能用于压缩目录 cd /tmp mkdir test cd test cp /var/log/*.log ./ cp /etc/rc.d/init.d/functions ./ cp /var/log/messages ./ 接上面指令,看下图压缩目录的,三种命令都不支持 tar tar用于归档,可以理解为打包tar [OPTION]... FILE...tar命令的选项可以不加- 创建归档、展开归档、查看附档都要使用-f选项,它用于创建、展开、查看归档所指定的文件 (1) 创建归档-c -f /PATH/TO/SOMEFILE.tar FILE... -cf /PATH/TO/SOMEFILE.tar FILE... (2) 展开归档-xf /PATH/FROM/SOMEFILE.tar-xf /PATH/FROM/SOMEFILE.tar -C /PATH/TO/SOMEDIR (3) 查看归档文件的列表-tf /PATH/FROM/SOMEFILE.tar #注意f要在c的后面,用于指定创建的归档的文件(因为/tmp/mylog.tar是-f的参数,所以必须卸载-c后);归档并不会删除源文件 tar -cf /tmp/mylog.tar *.log #展开归档,tar的选项可以不带\"-\" tar xf mylog.tar #使用-C指定展开归档文件路径 tar xf mylog.tar -C /tmp/newtest/ #查看归档文件的列表 tar -tf mylog.tar #对归档文件进行压缩,会删除mylog.tar源文件 xz mylog.tar 归档完成后通常需要压缩,结合此前的压缩工具,就能实现压缩多个文件了;(4) 归档并压缩-z:使用gzip2来进行压缩 创建归档并压缩:-zcf /PATH/TO/SOMEFILE.tar.gz File...展开归档并解压缩:-zxf /PATH/TO/SOMEFILE.tar.gztar命令可以在展开时,通过后缀名自动识别使用什么类型的压缩,所以展开归档时,可以省略-z-xf /PATH/TO/SOMEFILE.tar.gz -j:使用bzip2来进行压缩-jcf-jxf 可以省略j -J:使用xz来进行压缩-Jcf-Jxf 可以省略J #创建归档并使用gzip2压缩 tar -zcvf mylog2.tar.xz test #以上是对文件夹进行压缩归档,所以解压出来也带文件夹;这里省略了-z选项 tar -xf mylog2.tar.xz zip zip/unzip #打包压缩 zip mylog.zip ./test #解压 unzip mylog.zip 练习: 下载redis-3.0.2.tar.gz,展开至/tmp目录;而后重新归档压缩为xz格式; "},"pages/22.Liunx任务计划crontab.html":{"url":"pages/22.Liunx任务计划crontab.html","title":"22.Liunx任务计划crontab","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 本地电子邮件服务 mail命令: at命令 batch命令 crontab cron 周期性任务计划 Linux任务计划、周期性任务执行 未来的某个时间点执行一次某任务:at,batch周期性运行某任务:crontab执行结果:会通过邮件发送给用户邮筒:比如用户tom存放在:/var/spool/mail/tom #以下两个命令查看25端口是否启用,如果存在则代表本地邮件启用 ss -tnl netstat -tnlp 本地电子邮件服务 smtp:simple mall transmission protocolpop3:post office procotolimap4:intenet mail access protocol mail命令: mailx send and receive internet mallMUA:Mail User Agent,用户收发邮件的工具程序; mail [-s 'SUBJECT'] username[@hostname](1) 交互式输入: \".\"单独成行可以表示正文结束;Ctrl+d提交亦可;(2) 通过输入重定向;(3) 通过管道;一般使用管道将命令的结果,当做邮件发送给用户; 比如centos给root回邮件: #将fstab文件内容做输入重定向,作为邮件的正文.你可以切换root用户用mail命令查看邮件 mail -s 'fstab file' root at命令 未来的某个时间点执行一次某任务;at命令有自己的运行环境,并不会在你的终端中显示;at [OPTION]... TIMETIME:HH:MM [YYYY-mm-dd]noon,midnight,teatimetomorrownow+#    UNIT:minutes,hours,days,OR weeks at的作业有队列,用单个字母表示,默认都使用a队列; 常用选项:-l:查看作业列表,相当于atq;-f /PATH/FROM/SOMEFILE:从指定文件中读取作业任务,而不用再交互式输入;-d:删除指定的作业,相当于atrm;-c:查看指定作业的具体内容;-q QUEUE:指明队列; 注意:作业执行结果是以邮件发送给提交作业的用户;使用mail命令查看是否执行; 下图中单位使用min时minutes的简写如果执行完毕,可以使用mail找到执行过的信息 还可以使用at命令读取的命令文件:vim at.tasks cat /etc/initab echo \"hello at command\" #指定5分钟后执行at.tasks文件中的命令 at -f at.tasks now+5min #查看 atq 可以使用at -d #删除某个作业队列中的任务 at -d 5 atq #atrm也可用于删除某个作业队列中的任务 atrm 6 atq batch命令 batch会让系统自行选择在系统资源较空闲时间去执行指定的任务;所有batch不用指明时间,它指明任务的方式,使用各细节与at都一样; crontab cron 周期性任务计划 该命令的服务程序:cronld:主程序包,提供了crond守护进程及相关辅助工具; 查看crond.service服务是否正常命令:CentOS7:systemctl status crond.service 显示Active:active (running)则表示服务是正常的;CentOS6、CentOS7:service crond status CentOS6中只会显示一句话:crond (pid xxxx) is running...表示服务正常运行; 向crond提交作业的方式不同于at,它需要使用专用的配置文件,此文件有固定的格式,不建议使用文本编辑器直接编辑此文件;要使用crontab命令;cron任务分为两类:系统cron任务:主要用于实现系统自身的维护；手动编辑:/etc/crontab文件;用户cron任务:使用命令:crontab; 系统cron的配置格式:/etc/crontab使用cat /etc/crontab查看: SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 注意:(1) 每一行定义一个周期性任务;* * * * *:定义周期性时间user-name:运行任务的用户身份command to be executed:任务(2) 此处的环境变量不同于用户登录后获得的环境,因此,建议命令使用绝对路径,或者自定义PATH环境变量;(3) 执行结果邮件发送给MAILTO指定的用户 用户cron的配置格式:/var/spool/cron/USERNAME 时间表示法:(1) 特定值:给定时间点有效取值范围内的值;注意:day of week和day of month一般不同时使用; (2) * 给定时间点上有效取值范围内的所有值;表示\"每..\" (3) 离散取值:,在时间点上使用逗号分隔的多个值;#,#,#; (4) 连续取值:-在时间点上使用-链接开头和结束;#-#; (5) 在指定时间点上,定义步长:/#:#即步长;如:*/2; 注意:(1) 指定的时间点不能被步长整除时,其意义将不复存在;(2) 最小时间单位为:\"分钟\",想完成\"秒\"级任务,得需要额外借助于其他机制;可以定义成每分钟任务,然后利用脚本实现在每分钟之内,循环执行多次; 示例:(1) 3 :每小时的第3分钟执行1次;(2) 3 4 5:每个周五周的4点03分执行任务;每周执行一次任务;(3) 5 6 7 :每个月7号6点05分执行;每月执行一次任务;(4) 7 8 9 10 :每年10月9日7点08分执行;每年执行一次任务;(5) 3,9 4,8 3,7:每周三和周日8点09分和4点03分执行一次任务;(6) 0,8,20 3,7:每周三和周日8点和20点0分执行一次任务;这里容易写成` 8,20 3,7`这样是表示每周三和周日8点和20点每分钟执行一次;(7) 0 9-18 1-5:工作时间内的每小时执行一次,这里是周一至周五,9点至18点整每小时执行一次;(8) /5 :每5分钟执行一次任务;(9) /7 :这个定义是错误的,因为不能被60整除,不能没7分钟执行一次; 使用:crontab [-u user] [-l | -r | -e] [-i] -e:编辑任务;-l:列出所有任务;-r:移除所有任务;即删除/var/spool/cron/USERNAME文件;-i:在使用-r选项移除所有任务时提示用户;-u user:root用户可为指定用户管理cron任务; 注意:运行结果以邮件通知给当前用户;如果拒绝接受邮件:(1) 发生错误的时候发邮件:COMMAND > /dev/null(2) 无论执行成功还是错误都不发送邮件:COMMAND &> /dev/null 注意:定义COMMAND时,如果命令需要用到%,需要对其转义;或者将%放置于单引号中则无需转义; 思考:某任务在指定的时间因关机未能执行,下次开机会不会自动执行?答:不会如果期望某时间因故未能按时执行,下次开机后无论是否到了时间点都要执行一次,可使用anacron实现; 使用crontab -e编辑计划任务,它自动使用vim编辑器,加入内容如下: #每分钟执行一次echo \"howdy!\" * * * * * /bin/echo \"howdy!\" #可以使用mail查看任务的执行情况 mail #列出所有当前用户的计划任务 crontab -l #查看到就是你刚才创建计划任务的配置文件 cat /var/spool/cron/root 练习:1、每12小时备份一次/etc目录至/backups目录中,保存文件名称格式为:\"etc-yyyy-mm-dd-hh.tar.xz\"2、每周2、4、7备份/var/log/secure文件至/logs目录中,文件名格式为:\"secure-yyyymmdd\"3、每两小时取出当前系统/proc/meminfo文件中以S或M开头的行信息追加至/tmp/meminfo.txt文件中 "},"pages/23.软件包管理rpm.html":{"url":"pages/23.软件包管理rpm.html","title":"23.软件包管理rpm","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 获取程序包的途径: CentOS系统上rpm命令管理程序包: 安装: 升级: 卸载: 查询: 校验: 包来源合法性验证和完整性验证: 验证: 数据库重建: 程序包管理器 源代码--> 目标二进制格式 (二进制程序、库文件、配置文件、帮助文件) --> 组织成为一个或有限几个\"包\"文件;安装、升级、卸载、查询、校验 debian:dpt,dpkg,\".deb\"redhat:redhat package manager,rpmS.u.S.E:rpm,\".rpm\"GentooArchLinux 源代码:name-VERSION.tar.gzVERSION:major.minor.release rpm包命名格式:name-VERSION-release.arch.rpmVERSION:major.minor.releaserelease.arch:rpm包的发行号release.os:2.el7.i386.rpmarchetecuture:i386,x64(amd64),ppc,noarch redis-3.0.2.tar.gz --> redis-3.0.2-1.el7.x64.rpm 拆包: 主包和支包主包:name-VERSION-release.arch.rpm支包:name-function-VERSIONfunction:devel,utils,libs,... 依赖关系:包与包之间存在依赖关系; 前端工具:自动解决依赖关系;yum:rhel系列系统上rpm包管理器的前端工具;apt-get (apt-cache):deb包管理的前端工具;zypper:suse的rpm管理器前端工具;dnf:Fedora 22+系统上rpm包管理器的前端工具; 程序包管理器:功能:将编译好的应用程序的各组成文件打包成一个或几个程序包文件,从而更方便地实现程序包的安装、升级、卸载和查询等管理操作; 1、程序包的组成清单 (每个程序包都单独实现);文件清单安装或卸载时运行的脚本 2、数据库 (公共)程序包的名称和版本;依赖关系;功能说明;安装生成的各文件的文件路径及校验码信息;等等等 /var/lib/rpm/ 获取程序包的途径: (1) 系统发行版的光盘或官方的文件服务器(或镜像站点):http://mirrors.aliyun.comhttp://mirrors.sohu.comhttp://mirrors.163.com(2) 项目的官方站点(3) 第三方组织:(a) EPEL(b) 搜索引擎http://pkgs.orghttp://rpmfind.nethttp://rpm.pbone.net(4) 自动动手 CentOS系统上rpm命令管理程序包: 安装、升级、卸载、查询和校验、数据库维护 rpm命令: rpm [OPTIONS] [PACKAGE_FILE]安装: -i,--install升级: -U,--update,-F,--freshen卸载: -e,--erase查询: -q,--query校验: -V,--verify数据库维护: --builddb,--initdb 安装: rpm [-i|--install] [install-options] [package_file]... rpm -ivh PACKAGE_FILE ... GENERAL OPTIONS:-v:verbose,详细信息-vv:更详细的过程输出 [install-options]:-h:hash marks输出进度条;50#号,每个#表示2%的进度;--test:测试安装,检查并报告依赖关系及冲突消息等--nodeps:忽略依赖关系;不建议--replacepkgs:重新安装--nosignature:不检查包签名信息及不检查来源合法性;--nodigest:不检查包完整性信息; 注意:rpm可以自带脚本;四类: --noscripts:不执行任何脚本preinstall:安装过程开始之前运行的脚本,%pre; --nopre:不执行安装过程开始之前运行的脚本;postinstall:安装过程完成之后运行的脚本,%post; --nopost:不执行安装过程完成之后运行的脚本;preuninstall:卸载过程真正开始执行之前运行的脚本,%preun; --nopreun:不执行卸载过程真正开始执行之前运行的脚本;postuninstall:卸载在过程完成之后运行的脚本,%postun; --nopostun:不执行卸载在过程完成之后运行的脚本; mkdir /media/cdrom #挂载光盘 mount -r /dev/cdrom /media/cdrom #进入存档rpm文件的目录 cd /media/cdrom/Packages/ #查找zsh的rpm包 ls | grep \"zsh\" #安装zsh rpm -ivh zsh-5.0.2-28.el7.x86_64.rpm #可以查看到/bin/zsh了 cat /etc/shells #查看安装所生成的文件 rpm -ql zsh | less #查看安装的apm包版本信息 rpm -q zsh #卸载 rpm -e zsh # 安装时更详细的过程输出 rpm -ivvh zsh-5.0.2-28.el7.x86_64.rpm #--test用于测试安装,检查并报告依赖关系及冲突消息等 rpm -ivh --test php-common-5.4.16-42.el7.x86_64.rpm #忽略依赖关系安装 rpm -ivh --nodeps php-common-5.4.16-42.el7.x86_64.rpm #重新安装 rpm -ivh --replacepkgs zsh-5.0.2-28.el7.x86_64.rpm 升级: rpm [-U|--upgrade] [install-options] [package_file]...rpm [-F|--freshen] [install-options] [package_file]...-U:升级或安装;-F:升级;rpm -Uvh PACKAGE_FILE ...rpm -Fvh PACKAGE_FILE ... --oldpackage:降级;--force:强制升级; 注意:(1) 不要对内核做升级操作; Linux支持多内核版本并存,因此,直接安装新版本内核;(2) 如果某原程序包的配置文件安装后曾被修改过,升级时,新版本的程序提供的同一配置文件不会覆盖原有版本的配置文件,而是把新版本的配置文件重命名(FILENAME.rpmnew)后提供; #升级 rpm -Uvh zsh-5.0.2-7.el7_1.2.x86_64.rpm #查看zsh版本信息 rpm -q zsh 卸载: rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts] [--test] PACKAGE_NAME ... --allmatches:卸载所有匹配指定名称的程序包的各版本;--nodeps:忽略依赖关系;--test:测试卸载,dry run模式; 查询: rpm {-q|--query} [select-options] [query-options] [select-options]PACKAGE_NAME:查询指定的程序包是否已经安装,及其版本;-a,--all:查询所有已经安装过的包;-f FILE:查询指定的文件由哪个程序包安装生成;-p,--package:用于实现对未安装的程序包执行查询操作;--whatprovides CAPABILITY:查询指定的CAPABILITY由哪个程序包提供;--whatrequires CAPABILITY:查询指定的CAPABILITY被哪个包所依赖; [query-options]--changelog:查询rpm包的changelog;-l,--list:程序包安装生成的所有文件列表;-i,--info:程序包相关的信息,版本号、大小、所属的包组,等;-c,--configfiles:查询指定的程序提供的配置文件;-d,--docfiles:查询指定的程序包提供的文档;--provides:列出指定的程序包提供的所有的CAPABILITY;-R,--requires:查询指定的程序包的依赖关系;--scripts:查看程序包自带的脚本片段; #查询指定的程序包是否已经安装,及其版本 rpm -q zsh #查询所有已经安装过的包 rpm -qa #管道查询某个包 rpm -qa | grep \"^z\" #查询指定的文件由哪个程序包安装生成 rpm -qf /etc/fstab #查询rpm包的changelog rpm -q --changelog zsh | less #程序包安装生成的所有文件列表 rpm -ql bash #程序包安装生成的文件数 rpm -ql bash | wc -l #程序包相关的信息,版本号、大小、所属的包组,等 rpm -qi bash #查询bash的配置文件 rpm -qc bash #列出指定的程序包提供的所有的CAPABILITY rpm -q --provides bash #查询指定的CAPABILITY由哪个程序包提供 rpm -q --whatprovides bash #查询指定的CAPABILITY被哪个包所依赖 rpm -q --whatrequires bash #查询bash的依赖关系 rpm -q -R bash #查询bash安装时有哪些脚本 rpm -q --scripts bash #查询指定的程序包提供的文档 rpm -qd bash #安装zsh-5.0.2-28.el7.x86_64.rpm这个包所需要的程序包相关的信息,版本号、大小、所属的包组,等 #另外-qp和[query-options]的选项组合,如:-qpl、-qpc、-qpd等,使用-qpx来组合需要指定详细的rpm包名 rpm -qpi zsh-5.0.2-28.el7.x86_64.rpm 校验: rpm [--verify|-V] [select-options] [verifyoptions] S file size differs:文件大小发生改变M Mode differs(Includes permissions and file type): 权限发生改变5 digest (formerly MD5 sum) differs: MD5码发生了改变D Device major/minor number mismatch: 主次设备号不匹配L readLink(2) path mismatch: readLink路径不匹配U User ownership differs: 属主不匹配G Group ownership differs: 属组不匹配T mTime differs:最近一次修改时间发生了改变P caPabillties differ:它的caPabillties发生了改变 #校验文件,如果没有结果就是校验成功 rpm -V zsh 上图中修改了/usr/share/zsh/5.0.2/scripts/newuser文件,可以看出文件大小，md5编码和最近一次修改时间发生了改变 包来源合法性验证和完整性验证: 来源合法性验证;完整性验证; 获取并导入新人的包制作者的密钥:光盘安装包,在/etc/pki/rpm-gpg/下也有RPM-GPG-KEY-CentOS-7这个包制作者密钥对于CentOS发行版来说:rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 或者指定光盘挂载的路径中RPM-GPG-KEY-CentOS-7文件如果是互联网上的安装包,正规途径,一般也会有提供包制作者秘钥,下载导入即可 验证: (1) 安装此组织签名的程序时,会自动执行验证;(2) 手动验证:rpm -K PACKAGE_FIle即可; rpm -K zsh-5.0.2-28.el7.x86_64.rpm 下图中提示NOKEY,因为没有导入包制作者密钥： 数据库重建: rpm管理器数据库路径: /var/lib/rpm查询操作:通过此处的数据库进行; 获取帮助:CentOS6:man rpmCentOS7:man rpmdb rpm {--initdb|-rebuilddb} [--dbpath DIRECTORY]--initdb:初始化数据库,当前无任何数据库可初始化一个新的;当前有时不执行任何操作;--rebuilddb:重新构建,通过读取当前系统上所有已经安装过的程序包进行重新创建; mkdir /tmp/rpm #在/tmp/rpm目录下创建rpm管理器数据库 rpm --initdb --dbpath=/tmp/rpm ls /tmp/rpm #通过读取当前系统上所有已经安装过的程序包进行重新创建 rpm --rebuilddb --dbpath=/tmp/rpm ls /tmp/rpm "},"pages/24.软件包管理yum.html":{"url":"pages/24.软件包管理yum.html","title":"24.软件包管理yum","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 yum客户端: yum命令的用法: 使用本地光盘的yum仓库 yum的命令行选项: yum的repo配置文件中可用的变量: 创建yum仓库 程序包编译安装: 开源程序源代码的获取: YUM yellow dog,Yellowdog Update Modifier yum repository:yum repo存储了:众多rpm包包的相关的元数据文件(放置于特定目录下:repodata) 文件服务器:ftp://http://nfs://file:/// yum客户端: 配置文件:/etc/yum.conf:为所有仓库提供公共配置,如缓存文件放哪里等.../etc/yum.repos.d/*.repo:为每一个仓库提供特有配置; 仓库的定义:[repositoryID]name=Some name for this repositorybaseurl=url://path/to/repository/enabled={1|0}:是否启用此仓库;默认为1(启用),不写为启用;gpgcheck={1|0}:对于此仓库中的所有程序包,在安装之前是否做完整性验证和来源合法性;gpgkey=URL:用于指明密钥文件,使用此密钥文件来做完整性验证和来源合法性enablegroups={1|0}:默认为1(是),是否在此仓库上使用组来批量管理程序包failovermethod={roundrobin|priority}:故障转移方法;当baseurl指定多个url时,如果来挑选;默认为:roundrobin,意为随机挑选;priority:优先级,至上而下的挑选 cost=1000:代表开销,如果希望访问此仓库开销小一点,可以调低一些;默认为1000 yum命令的用法: yum [options] [command] [package ...] repolist [all|enabled|disabled]:显示仓库列表的命令;默认显示启用的仓库即:yum repolist相当于yum repolist enabledlist:显示程序包yum list [all | glob_exp1] [glob_exp2] [...] :显示匹配指定glob通配符的所有程序包yum list available [glob_exp1] [...]:显示匹配指定glob通配符,仓库中有尚未安装的程序包(即可用的安装包)yum list updates [glob_exp1] [...]:可用的升级包yum list installed [glob_exp1] [...]:已安装的包yum list extras [glob_exp1] [...]:额外的安装包yum list obsoletes [glob_exp1] [...]:废弃的安装包 #列出所有可用仓库 yum repolist #显示所有程序包 yum list | less #显示php开头的所有程序包,这里使用了glob通配符 yum list php* 安装程序包:install package1 [package2] [...] yum install gcc yum -y install gcc 重新安装(覆盖的方式进行安装):reinstall package1 [package2] [...] 升级程序包:update package1 [package2] [...] 降级程序包:downgrad package1 [package2] [...] 检查可用升级: check-update yum update gcc 卸载指定程序包:remove | erase package1 [package2] [...] yum remove gcc 查看程序包information:info package1 [...] yum info gcc 查看指定的特性(可以是某文件)是由那个程序包所提供的:provides | whatprovides feature1 [feature2] [...] yum provides /bin/ls yum provides /bin/ls /bin/cat 清空本地缓存:clean [packages | metadata | expire-cache | rpmdb | plugins | all] 构建缓存:(这部一般不需要手工做,在我们每一次使用yum安装时,它会自动去找所有的yum仓库,并把它们相关的文件缓存在本地)makecahe 一般在配置完新的yum仓库后可以做以下操作: #清空所有本地缓存 yum clean all #构建缓存 yum makecache #显示yum仓库列表 yum repolist 搜索:以指定的关键字搜索程序包名及summary信息search string1 [string2] [...] yum search bash 显示程序包的依赖关系deplist package1 [package2] [...] yum deplist gcc history [info | list | packages-info | summary | addon-info | redo | undo | rollback | new | sync | stats ]查看yum事务历史(每一次yum命令执行都是启动了一次yum事务,如安装、升级、卸载才会启动事务,查询不会启动事务) yum history yum history stats 安装及升级本地程序包假设yum仓库没有想要的包,从网络上下载下来的rpm包,我们通过rpm -ivh rpm包名来安装,问题这个包有很多依赖怎么办呢?如果被它依赖的包在yum仓库里,这个时候我们就可以使用yum localinstall rpm包名来安装本地的rpm包,可以解决该包的依赖问题.localinstall安装本地包时能解决本地包的依赖关系;localinstall rpmfile1 [rpmfile2] [...](maintained for legacy reasons only - use install)localupdate rpmfile1 [rpmfile2] [...](maintained for legacy reasons only - use update)注意:在CentOS6、CentOS7以后,本地安装rpm也可以不用localinstall了,直接使用yum install rpm包名即可;目前localinstall和localupdate仅仅为了兼容才保留例如:yum install /usr/local/src/testapp-3.2.1-1.el7.x86_64.rpm 包组管理的相关命令:groupinstall group1 [group2] [...]groupupdate group1 [group2] [...]grouplist [hidden] [groupwilcar] [...]groupremove group1 [group2] [...]groupinfo group1 [...] #查看包组列表 yum grouplist #安装包组 yum groupinstall \"开发工具\" #查看包组信息 yum groupinfo \"开发工具\" 使用本地光盘的yum仓库 mount -r /dev/cdrom /media/cdrom cd /media/cdrom ls 下图查看以上命令的信息: #备份系统自带的yum源 mv CentOS-Base.repo CentOS-Base.repo.bak cd /etc/yum.repos.d/ vim local.repo local.repo文件如下: [base] name=CentOS 7 Release baseurl=file:///media/cdrom enable=1 gpgcheck=0 yum repolist yum的命令行选项: --nogpgcheck:禁止进行gpg check;-y:自动回答为\"yes\";-q:静默模式;--disablerepo=repoidglob:临时禁涌此处指定的repo;--enablerepo=repoidglob:临时启用此处指定的repo;--noplugins:禁用所有插件; yum的repo配置文件中可用的变量: $releaserver:当前OS的发行版的主版本号;$arch:CPU架构平台CPU架构平台:i386 32位操作系统i686 是i386的一个子集x86_64 64位操作系统noarch 跨平台$basearch:基础平台;$YUM0-$YUM9:自定义变量; 如:http://mirrors.abc.com/centos/$releasever/$basearch/os 创建yum仓库 createrepo用于组织和管理rpm包,创建相关的repodata目录的文件 yum install createrepo createrepo [options] mkdir -p /yum/repo #拷贝php-开头的rpm文件 cp /media/cdrom/Packages/php-* /yum/repo cd /yum/repo #创建repodata目录的文件 createrepo ./ 有了repodata文件就能指定yum源了 cd /etc/yum.repos.d/ vim local.repo local.repo文件如下: [php-centos] name=CentOS 7 php baseurl=file:///yum/repo/ enable=1 gpgcheck=0 #查看并获取新的yum源 yum repolist 程序包编译安装: 源代码的rpm包格式:testapp-VERSION-release.src.rpm --> 安装后,使用rpmbuild命令制作成二进制格式的rpm包,而后再安装; 源代码 --> 预处理 --> 编译(gcc) --> 汇编 --> 链接 --> 执行 源代码组织格式:多文件:文件中的代码之间,很可能存在跨文件依赖关系; C、C++: make (configure --> Makefile.in --> makefile)java:maven C代码,编译安装三步骤:./configure:(1) 通过选项传递参数,指定启用特性、安装路径等;执行时会参考用户的指定以及Makefile.in文件生成makefile;(2) 检查依赖到的外部环境; make:根据makefile文件,构建应用程序; make install 开发工具:autoconf:生成configure脚本automake:生成Makefile.in文件 建议:安装前查看INSTALL、README文件 开源程序源代码的获取: 官方自建站点:apache.org (ASF)mariadb.org...代码托管:SourceForgeGithub.comcode.google.com c/c++:gcc (GNU C Complier) 编译C源代码:前提:提供开发工具及开发环境开发工具:make,gcc等开发环境:开发库,头文件glibc:标准库 通过\"包组\"提供开发组件\"Development Tools\",中文版叫\"开发工具\" yum groupinstall 开发工具 rpm -q make rpm -q gcc gcc --version 第一步:configure脚本选项:指定安装位置、指定启用的特性--help:获取其支持使用的选项选项分类:安装路径设定:--prefix=/PATH/TO/SOMEWHERE:指定默认安装位置;不指定通常默认为/usr/local/--sysconfdir=/PATH/TO/SOMEWHERE:配置文件的安装路径; 可选特性(Optional Features):--disable-FEATURE--enable-FEATURE[=ARG] 可选程序包(Optional Packages):--with-PACKAGE[=ARG]--without-PACKAGE 第二步:make 第三步:make install #上传源码包使用rz选择httpd-2.2.29.tar.bz2上传 #解压源码包 tar jxf httpd-2.2.29.tar.bz2 cd httpd-2.2.29/ #指定安装路径和配置文件安装路径 ./configure --prefix=/usr/local/apache2 --sysconfdir=/etc/httpd2 make make install #切换到apache的bin目录 cd /usr/local/apache2/bin #启动apache ./apachectl start #查看80端口是否启用且是否是httpd进程 netstat -tnlp #关闭防火墙后就可以通过ip地址访问了 systemctl stop firewalld 安装后配置(如果没有指定/usr/local/目录,以下文件需要导出,否则无法全局使用):(1) 导出二进制程序目录至PATH环境变量中:编辑文件/etc/profile.d/NAME.shexport PATH=/PATH/TO/BIN:$PATH (2) 导出库文件路径编辑/etc/ld.so.conf.d/NAME.conf添加新的库文件所在目录至此文件中; 让系统重新生成缓存:ldconfig [-v] (3) 导出头文件基于链接的方式实现:ln -sv (4) 导出帮助手册编辑/etc/man.config文件添加一个MANPATH "},"pages/25.shell多分支if和for循环.html":{"url":"pages/25.shell多分支if和for循环.html","title":"25.shell多分支if和for循环","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 示例:脚本参数传递一个文件路径给脚本,判断此文件的类型 练习: for循环 for循环的特殊用法 多分支的if语句 if CONDITION1; then 条件1为真分支elif CONDITION1; then 条件2为真分支...elif CONDITIONn; then 条件n为真分支else 所有条件均不满足的分支fi 注意:即便多个条件可能同时都满足,分支只会执行其中一个,首先测试为\"真\"的; 示例:脚本参数传递一个文件路径给脚本,判断此文件的类型 filetype.sh文件如下: #!/bin/bash if [ $# -lt 1 ];then echo '请输入一个路径!' exit 1 fi if ! [ -e $1 ];then echo '文件不存在!' exit 2 fi if [ -f $1 ];then echo 'Common file' elif [ -c $1 ];then echo 'Character special file' elif [ -b $1 ];then echo 'Block sepcial file' elif [ -L $1 ];then echo 'Symbol link file' elif [ -S $1 ];then echo 'Socket file' elif [ -d $1 ];then echo 'Direstory file' else echo 'Unkown file' fi 执行脚本: bash -x filetype.sh /etc bash -x filetype.sh /etc/inittab bash -x filetype.sh /dev/sda 练习: 1、写一个脚本(1) 传递一个参数给脚本,此参数为用户名;(2) 根据其ID号来判断用户类型:0:管理员1-999:系统用户1000-65535:登录用户usertype.sh文件如下: #!/bin/bash [ $# -lt 1 ] && echo '请输入用户名' && exit 1 ! id $1 &> /dev/null && echo '用户名不存在' && exit 2 #获取用户id #userid=$(id -u $1) #练习命令,使用下面复杂的方式取id userid=$(cat /etc/passwd | grep \"^$1\\>\" | cut -d : -f3) if [ $userid -eq 0 ];then echo \"用户:$1为管理员\" elif [ $userid -ge 1 -a $userid -le 999 ];then echo \"用户:$1为系统用户\" elif [ $userid -ge 1000 -a $userid -le 65535 ];then echo \"用户:$1为登录用户\" else echo \"未知的用户\" fi 2、写一个脚本(1) 列出如下菜单给用户:input disk:show disk info; fdisk -linput mem:show memory info; free -minput cpu:show cpu info; lscpu或者cat /proc/cpuinfoinpu *:quit;(2) 根据用户给出自己的选择,而后显示对应其选择的响应系统信息; sysinfo.sh文件如下: #!/bin/bash cat for循环 循环执行:将一段代码重复执行0、1或多次;进入条件:条件满足时才进入循环;退出条件:每个循环都应该有退出条件,以有机会退出循环; bash脚本:for循环while循环until循环 for循环:两种格式:(1) 遍历列表(2) 控制变量 遍历列表:for VARAIBLE in LIST;do循环体done 进入条件:只要列表又元素,即可进入循环;退出条件:列表中元素遍历完成; LIST的生成方式:(1) 直接给出; (2) 整数列表(a) {start..end} echo {1..10} (b) seqseq [OPTION]... LASTseq [OPTION]... FIRST LASTseq [OPTION]... FIRST INCREMENT LAST seq 10 seq 5 10 #1-10的奇数,这里步长为2 seq 1 2 10 #1-10的偶数,这里步长为2 seq 2 2 10 (3) 返回列表命令 ls /var #文本里的换行,空格符都可以作为列表的分隔符 cat /etc/issue (4) glob ls -d /etc/p* (5) 变量引用$*:所有参数;(\"hello\" \"hi\" \"toyou\")$@:所有参数;(\"hello hi toyou\")..... 示例:循环创建3个用户 #!/bin/bash for username in user31 user32 user33;do if id $username &> /dev/null;then echo \"Username is exists\" else useradd $username && echo \"Add user $username finished.\" fi done 示例:循环创建10个文件,在tmp目录下,取名f1-f10 #!/bin/bash for filename in {1..10};do name=/tmp/f$filename if ! [ -e $name ];then touch $name else echo \"$name已经存在!\" fi done 示例:求1-100正整数之和 #!/bin/bash declare -i sum=0 for num in $(seq 1 100);do echo \"\\$sum is $sum,\\$num is $num\" sum=$[$sum+$num] done echo \"1-100之和为:$sum\" 示例:判断/var/log目录下的每一个文件的内容类型,使用file /var/log/*,也可以查看,这里我们使用循环 #!/bin/bash for filename in /var/log/*;do if [ -f $filename ];then echo 'Common file' elif [ -d $filename ];then echo 'Dirctory file' elif [ -c $filename ];then echo 'Character special file' elif [ -b $filename ];then echo 'Block special file' elif [ -L $filename ];then echo 'symbolic file' elif [ -S $filename ];then echo 'Socket file' else echo 'Unkown file' fi done for循环的特殊用法 for ((控制变量初始化;条件判断表达式;控制变量的修正语句));do循环体done 控制变量初始化:仅在循环代码开始运行时执行一次;控制变量修正语句;每轮循环结束会先进行控制变量修正运算,而后再做条件判断;示例:求100以内所有正整数之和 #!/bin/bash declare -i sum=0; for((i=0;i 示例:99乘法表 #!/bin/bash for((i=1;i 练习:1、分别求100以内所有偶数之和,以及所有奇数之和;2、计算当前系统上的所有用户的id之和;3、通过脚本参数传递一个目录给脚本,而后计算此目录下所有文本文件的行数之和;并说明此类文件的总数; "},"pages/26.文本处理神器sed.html":{"url":"pages/26.文本处理神器sed.html","title":"26.文本处理神器sed","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 :指定行; ,#: ,+#: ,/pattern1/ 高级编辑命令(不常用,了解) sed命令 文本处理三剑客:grep,egrep,fgrep:文本过滤器sed:Stream Editor:流编辑器,行awk:文本格式化工具,报告生成器 sed文本处理方式: sed [OPTION]... 'script' [input-file]...script:地址定界编辑命令 常用选项:-n:不输出模式空间中的内容至屏幕;-e script, --expression=script:多点编辑;-f /PATH/TO/SED_SCRIPT_FILE:将编辑命令保存在一个文件中,每行一个编辑命令;-r, --regexp-extended:支持使用扩展正则表达式;-i[SUFFIX], --in-place[=SUFFIX]:直接编辑源文件,操作的结果直接保存源文件中; 地址定界:(1) 空地址:对全文进行处理; (2) 单地址: :指定行; /pattern/:被此模式所匹配到的每一行; (3) 地址范围 ,#: ,+#: ,/pattern1/ /pattern1/,/pattern2/$:最后一行 (4) 步进(可以理解为自增):~1~2:表示所有的奇数行2~2:表示所有的奇数行 编辑命令:d:删除;p:显示模式空间中的内容;a \\text:在行后面追加文本\"text\",支持使用\\n实现多行追加;i \\text:在行前面插入文本\"text\",支持使用\\n实现多行插入;c \\text:把匹配到的行替换为此处指定的文本\"text\"(整行替换);w /PATH/TO/SOMEFILE:保存模式空间匹配到的行至指定的文件中;r /PATH/FORM/SOMEFILE:读取指定文件的内容至当前文件被模式匹配到的行后后面;文件合并;=:为模式匹配到的行打印行号;!:条件取反;地址定界!编辑命令如:'/^#/!p';s///:查找替换,其分隔符可自行指定,常用的有s@@@,s###等;替换标记:g:全局替换;w /PATH/TO/SOMEFILE:将替换成功的结果保存至指定文件中;p:显示替换成功的行; #删除1-5行并输出,sed默认不修改源文件 sed '1,5d' /etc/fstab #删除UUID开头的所有行 sed '/^UUID/d' /etc/fstab #删除#开头所有行 sed '/^#/d' /etc/fstab #删除第3行 sed '3d' /etc/fstab #显示偶数行,这里删除了奇数行 sed '1~2d' /etc/fstab #奇数行会输出两遍,第一遍是本身编辑前输出,第二遍是p的作用是匹配的行输出,这个时候就需要加上-n,静止默认输出 sed '1~2p' /etc/fstab #静止默认输出,只保留编辑命令的行为,这里的编辑命令是p,这样就只输出匹配到的行了 sed -n '1~2p' /etc/fstab #在第三行之前插入一行new line的文本,`\\`后的文本即使有空格也不需要加双引号 sed '3i \\new line' /etc/fstab #在第三行之后插入一行new line的文本 sed '3a \\new line' /etc/fstab #通过\\n分隔在第三行后添加两行 sed '3a \\new line\\nanother new line' /etc/fstab #给UUID的行前添加注释行 sed '/^UUID/i \\# 通过UUID添加设备' /etc/fstab #将UUID开头的行郑航替换为指定文本 sed '/^UUID/c \\# 通过UUID添加设备' /etc/fstab #将非#号开头的文本保存至/tmp/fstab.new sed -n '/^[^#]/w /tmp/fstab.new' /etc/fstab cat /tmp/fstab.new #在/etc/fstab的第三行后添加/etc/issue中所有文本内容 sed '3r /etc/issue' /etc/fstab #在/etc/fstab的UUID开头的行后添加/etc/issue中所有文本内容 sed '/^UUID/r /etc/issue' /etc/fstab #UUID开头的行前加入行号 sed '/^UUID/=' /etc/fstab #显示出不是#开头的行 sed -n '/^#/!p' /etc/fstab -f选项的使用:脚本命令文件:sed.script: s/hello/A/ s/world/B/ #使用-f指定编辑命令的文件sed.script echo hello world | sed -f sed.script 注意:-n(不输出模式空间中的内容至屏幕),d(删除)不能同时使用,同时使用就不会有任何输出了.如: sed -n '1~2d' /etc/fstab 练习1:删除/etc/grub2.cfg文件中所有以空白字符开头的行的行首的所有空白字符; #将行首的一个或多个空白替换为空字符 sed 's@^[[:space:]]\\+@@' /etc/grub2.cfg 练习2:删除/etc/fstab文件中所有以#开头行的行首的#号及#后面的所有空白字符; #注shell正则中*代表0次或一次或多次是不需要加\\的,这是我经常犯的错误是\\*; sed 's@^#[[:space:]]*@@' /etc/fstab #删除UUID开头的行并替换所有以#开头行的行首的#号及#后面的所有空白字符 sed -e '/^UUID/d' -e 's@^#[[:space:]]*@@' /etc/fstab 练习3:输出一个绝对路径给sed命令,取出其目录,其行为类似于dirname; #非/字符,结尾的文本替换为空 echo /var/log/messages | sed 's@[^/]\\+$@@' #对于最后有\"/\"的路径处理 echo /var/log/messages/ | sed 's@[^/]\\+/\\?$@@' #用扩展正则表达式来写 echo /var/log/messages/ | sed -r 's@[^/]+/?$@@' #匹配UUID开头的行,后添加一行new line的字符,并修改源文件;-r选项应该在测试后,确认无误后使用;任何修改或删除操作前建议先做拷贝 sed -i '/^UUID/a \\new line' fstab 高级编辑命令(不常用,了解) h:把模式空间中的内容覆盖至保持空间中;H:把模式空间中的内容追加至保持空间中;g:把保持空间中的内容覆盖至模式空间中;G:把保持空间中的内容追加至模式空间中;x:把模式空间中的内容与保持空间中的内容互换;n:覆盖读取匹配到的行的下一行至模式空间中;N:追加读取匹配到的行的下一行至模式空间中;d:删除模式空间中的行;D:删除多行模式空间中的所有行; 示例:sed -n 'n;p' FILE:显示偶数行;sed '1!G;h;$!d' FILE:逆序显示文件的内容;sed '$!d' FILE:取出最后一行;sed '$!N;$!D' FILE:取出文件后两行;sed '/^$/d;G' FILE:删除原有的所有空白行,而后为所有的非空白行后添加一个空白行;sed 'n;d' FILE:显示奇数行;sed 'G' FILE:在原有的每行后方添加一个空白行; #显示偶数行;n:覆盖读取匹配到的行的下一行至模式空间中,然后这里关闭默认输出,使用p就只输出模式空间中的行了 sed -n 'n;p' /etc/fstab #逆序显示文件的内容,累不累?tac /etc/fstab就能解决的事情.呵呵哒 sed '1!G;h;$!d' /etc/fstab "},"pages/27.计算机网络基础.html":{"url":"pages/27.计算机网络基础.html","title":"27.计算机网络基础","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 MAC:Media Access Control 介质访问控制 交换机(switch): IP地址分类； 路由器:router 通信时,进程的数字标识端口: 小结: 将Linux主机接入到网络中: 动态分配:依赖于本地网络中有DHCP服务 网络接口命名方式: 计算机网络 TCP/IP:协议栈(使用)OSI(Open System Interconnection):协议栈(学习) 下图中左边为OSI七层,右边为TCP/IP四层 OSI七层:Physical Layer:用来定义各设备的物理规范,例如:通信支持距离、接口大小等;Data Link Layer:基于MAC地址通信时,数据报文的封装和响应方式;Network Layer:基于IP地址通信过程的实现;进行逻辑地址寻址,实现不同网络之间的路径选择;协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP;Transport Layer:定义传输数据的协议端口号,以及流控和差错校验;主要负责向两个主机中进程之间的通信提供服务;协议有：TCP UDP;Session Layer:建立、管理、终止会话;对应主机进程,指本地主机与远程主机正在进行的会话;Presentation Layer:数据的表示格式;例如:数据是否压缩,加密等;格式有，JPEG、ASCll、DECOIC、加密格式等;Application Layer:网络服务与最终用户的一个接口;协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP; TCP/IP四层:物理层:以太网帧,MTU,Maximum Transmission Unit (1500bytes)互联网层:IP,(IP报文)传输层:TCP,UDP应用层:http,https,ftp,ldap,... MAC:Media Access Control 介质访问控制 48bits:ICANN:24bits,2^24地址块:2^24 交换机(switch): MAC地址表静态指定动态学习:根据原地址学习; IP(Internet protocol)地址:网络号+主机号IPV4:32bits8bits.8bits.8bits.8bits0-2550.0.0.0-255.255.255.255 IP地址分类； A类:第一段为网络号,后三段为主机号网络号:0 000 0000 - 0 111 1111 : 1-127网络数量:126,这里需要减去127如:127.0.0.1,回环地址,所以是126个每个网络中的主机数量:2^24-2,去除一下2个IP:0.0.0.0,主机本身,用作服务端,表示本机上的任意IPV4地址.一台服务器多个网卡多个ip;代表本网络中的本机1,1,1,1,所有主机,广播地址默认子网掩码:255.0.0.0,/8 (/8代表二进制8个1,24个0)用于与IP地址按位进行\"与\"运算,从而取出其网络地址;1.3.2.1/255.0.0.0=1.0.0.01.3.2.1/255.255.0.0=1.3.0.0私网地址:10.0.0.0-10.255.255.255 B类:前两段为网络号,后两段为主机号网络号:10 00 0000 - 10 11 1111:128-191网络数:2^14每个网络中的主机数量:2^16-2,/16默认子网掩码:255.255.0.0私网地址:172.16.0.0-172.31.255.255 C类:前三段为网络号,最后一段为主机号网络号:110 0 0000-110 1 1111:192-223网络数:2^21每个网络中的主机数量:2^8-2默认子网掩码:255.255.255.0, /24私网地址:192.168.0.0-192.168.255.255 D类:组播1110 0000-1110 1111:224-239 E类:科研240-255 IPV6:128bits 路由器:router 路由表:静态指定动态学习:rip2,ospf协议 路由条目：目标地址 下一跳(nexthop),下一跳都可以叫网关(注意:不是叫默认网关)目标地址的类别:主机:主机路由网络:网络路由0.0.0.0/0.0.0.0:默认路由 通信时,进程的数字标识端口: 16bits:0-65535:实际使用1-655351-1023:固定分配,而且只有管理员有权限启用;1024-4w:半固定;4w+:临时; 进程地址:IP:PORT,socket 小结: MAC:本地通信;范围:本地局域网;IP:界定通信主机,源和目标;范围:互联网;Port:界定进程;范围:主机; 将Linux主机接入到网络中: IP/NETMASK:本地通信路由(网关):跨网络通信DNS服务器地址:基于主机名的通信主DNS服务器地址备用DNS服务器地址第二备用DNS服务器地址 配置方式:静态指定:命令:ifcfg家族:ifconfig:配置IP,NETMASKroute:路由netstat:状态及统计数据查看 iproute2家族:ip OBJECT:  addr:地址和掩码;  link:接口;  route:路由;ss:状态及统计数据查看; CentOS7:nm(Network Manager)家族nmcli:命令行工具nmtui:text window工具 注意:(1) DNS服务器指定:编辑配置文件:/etc/resolv.conf(2) 本地主机名配置hostname配置文件:/etc/sysconfig/networkCentOS7:hostnamectl 配置文件(RHEL系列):/etc/sysconfig/network-scripts/ifcfg-NETCARD_NAME 动态分配:依赖于本地网络中有DHCP服务 DHCP:Dynamic Host Configure Procotol 网络接口命名方式: 传统命名:以太网:ethX,[0,∞],例如eth0,eth1,...PPP网络:pppX,[0,∞],例如,ppp0,ppp1,... 可预测命名方案(CentOS):支持多种不同的命名机制:Fireware,拓扑结构 (1) 如果Fireware或BIOS为主板上集成的设备提供的索引信息可用,则根据此索引进行命名,如eno1,eno2,...(2) 如果Fireware或BIOS为PCI-E扩展槽所提供的索引信息可用,且可预测,则根据此索引进行命名,如ens1,ens2,...(3) 如果硬件接口的物理位置信息可用,则根据此信息命名,如enp2s0,...(4) 如果用户显示定义,也可根据MAC地址命名,例如enx122161ab2e10,...上述均不可用,则仍使用传统方式命名; 命名格式的组成:en:ethernetwl:wlanww:wwan 名称类型:o:集成设备的设备索引号;s:扩展槽的索引号;x:基于MAC地址的命名;ps:基于总线及槽的拓扑结构进行命名; "},"pages/28.Linux网络属性配置.html":{"url":"pages/28.Linux网络属性配置.html","title":"28.Linux网络属性配置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 ifconfig命令:网卡接口及地址查看和管理 route命令:路由查看及管理 指定删除 netstat命令 ifup/ifdown命令: 配置主机名 hostname命令: hostnamectl命令(CentOS7): 配置文件:/etc/sysconfig/network 配置DNS服务器指向 iproute命令家族 ip命令: ip link:网络设备的配置 ip netns:管理网络的名称空间 ip address 管理网卡接口的ip地址 ip route 路由表管理 ss命令: 网卡接口配置文件 ifcfg-IFACE配置文件参数: 路由的配置文件 给网卡接口配置多个地址: nmcli命令 ifcfg命令家族:ifconfig,route,netstat ifconfig命令:网卡接口及地址查看和管理 ifconfig [INTERFACE]ifconfig -a:显示所有网卡接口,包括inactive状态的网卡接口; ifconfig INTERFACE [aftype] options | address ...ifconfig INTERFACE IP/MASK [up|down]ifconfig INTERFACE IP netmask NETMASK options:[-]promisc:混杂模式 flags:标志位;UP:网卡处于启用状态;BROADCAST:表示支持广播功能;MULTICAST:组播(多播)功能;RUNNING:表示运行当中;mtu(Maximum Transmission Unit):最大传输单元;inet(Internet Address):IP地址;netmask:子网掩码;broadcast 192.168.147.255:广播地址;inet6:IPV6地址;ether:以太网地址;txqueuelen:传输队列长度;RX packets 158476:这次网卡激活后接收到的报文的数量;bytes 158456927 (151.1 MiB):接收报文的总大小是多少;RX errors 0:接收时的错误个数; dropped 0:丢包的数量;overruns 0:溢出的数量;frame 0:帧;TX packets 73688:传出的个数;collisions 0:冲突的个数; #修改ip和子网掩码 ifconfig ens33 192.168.147.147/24 up ifconfig ens33 192.168.147.101 netmask 255.255.255.0 混杂模式: 注意:ifconfig命令修改立即送往内核中的TCP/IP协议栈,并生效 管理IPv6地址:add address/prefixlendel address/prefixlen route命令:路由查看及管理 路由条目类型:主机路由:目标地址为单个IP;网络路由:目标地址为IP网络;默认路由:目标为任意主机,0.0.0.0/0.0.0.0 查看:route -n route -n 添加:route add [-net|-host] target netmask Nm [[dev] If]-net:网络路由-host:主机路由target:ip地址netmask Nm:子网掩码 [[dev] If]:指定自己的哪个网卡接口 route add -net 10.0.0.0/8 gw 192.168.147.101 dev ens33 #添加默认路由 route add -net 0.0.0.0/0 gw 192.168.147.102 dev ens33 route add default gw 192.168.147.104 删除: 指定删除 route del [-net|-host] target [gw Gw] [netmask Nm] [[dev] If] route del -net 10.0.0.0/8 gw 192.168.147.101 #删除默认路由 route del default netstat命令 显示网络连接、路由表、网卡接口统计数据、伪装连接、多播(组播)成员关系 显示路由信息: netstat -rn-r:显示内核路由表-n:数字格式(IP格式) netstat -rn 显示网络连接:netstat [--tcp|-t] [--udp|-u] [--raw|-w] [--udplite|-U] [--sctp|-S] [--listening|-l] [--all|-a] [--numeric|-n] [--extend|-e[--extend|-e]] [--program|-p] -t:TCP协议的相关连接,连接均有其状态;FSM(Finite State Machine)-u:UDP相关的连接-w:raw socket相关连接-l:处于监听状态的连接-a:所有状态-n:以数字格式显示IP和Port-e:扩展格式-p:显示相关的进程及PID 传输层协议:tcp:面向连接的协议;通信开始之前,要建立一个虚链路;通信完成后还要拆除连接;udp:无连接协议;直接发送数据报文; 常用组合:-tan、-uan、-tnl、-unl、-tunlp #tcp连接的LISTEN状态连接,并显示数字格式IP和Port及进程及PID netstat -tlnp #tcp连接的所有状态连接,包括LISTEN、ESTABLISHED等所有状态连接,并显示数字格式IP和Port及进程及PID netstat -tanp 显示网卡接口的统计数据: netstat {--interfaces|-i} [iface] #显示所有网卡接口统计数据 netstat -i #显示指定网卡接口统计数据,注-I和网卡接口名之间没有空格 netstat -Iens33 ifup/ifdown命令: 注意:通过配置文件/etc/sysconfig/network-scripts/ifcfg-IFACE来识别接口并完成配置; ifdown ens33 ifup ens33 配置主机名 hostname命令: 查看:hostname配置:hostname HOSTNAME #设置主机名当前系统有效,重启则无效 hostname abc.com hostname hostnamectl命令(CentOS7): #显示当前主机名信息 hostnamectl status #设定主机名,永久有效 hostnamectl set-hostname localhost.localdomain1 配置文件:/etc/sysconfig/network HOSTNAME= 注意:此方法的设置不会立即生效;但重启以后会一直有效; vim /etc/sysconfig/network: HOSTNAME=localhost.abc 配置DNS服务器指向 配置文件:/etc/resolv.conf,例如以下在配置文件中指定了dns的ip地址 nameserver 192.168.147.2 如何测试(host/nslookup/dig): 将域名转换为ipdig -t A FQDNFQDN-->IP 将ip反解析为域名,互联网上大部分服务器都不支持反解dig -x IPIP-->FQDN #这里的A代表要指定的域名 dig -t A www.baidu.com #将ip反解析为域名,互联网上大部分服务器都不支持反解 dig -x 180.101.49.11 iproute命令家族 ip命令: 查看及管理路由、设备、策略路由及隧道ip [OPTIONS] OBJECT {COMMAND | help}OBJECT:={link | addr | route | netns} ip OBJECT: ip link:网络设备的配置 ip link set:修改设备属性dev NAME(default):指明要管理的设备,dev关键字可省略;up和down;multicast on或multicast off:启用或禁用多播功能;name NAME:重命名接口;mtu NUMBER:设置MTU的大小,默认为1500;netns PID:ns为namespace,用于将网络接口移动到指定的网络名称空间; ip link show:显示设备属性 #显示设备属性 ip link show #禁用ens33网卡 ip link set ens33 down #启用ens33网卡 p link set ens33 up #启用和禁用多播(组播) link set ens33 multicast off ip link show ens33 ip link set ens33 multicast on ip link show ens33 #修改网卡接口名称 ip link set ens33 down ip link set ens33 name ens333 ip link show #显示简要使用帮助 ip link help ip netns:管理网络的名称空间 ip netns list:列出所有的netns ip netns add NAME:创建指定的netnsip netns del NAME:删除指定的netnsip netns exec NAME COMMAND:在指定的netns中运行命令 #添加名为mynet的名称空间 ip netns add mynet #将ens33添加到netns下 ip link set ens33 netns mynet #查看ens33网卡接口没有了 ip link show #在mynet名称空间中查看网卡接口 ip netns exec mynet ip link show #删除mynet名称空间 ip netns del mynet #查看ens33网卡接口又回来了 ip link show ip address 管理网卡接口的ip地址 ip address add 添加ip地址:ip addr add IFADDR dev IFACE [scope SCOPE_VALUE]:global:全局可用;(本机自己ping自己可以的,这个地址和其他主机通信也是可以的)link:接口可用;(本机自己ping自己可以的,别人ping这个地址ping不通;这个地址不用于和别人通信)host:仅本机内部可用;(出了本机别人看不见) ip address delete 删除ip地址ip address flush 清空所有ip地址ip address show 显示所有网卡接口ip地址 #设置ens33网卡接口ip为无 ifconfig ens33 0 #添加ens33网卡接口ip地址 ip addr add 192.168.147.153/24 dev ens33 #可以添加多个ip地址发到同一个网卡接口 ip addr add 192.168.147.154/24 dev ens33 #可以看到ens33上的多个ip地址 ip addr show ens33 #ifconfig看不到多个ip地址,只看到添加的第一个地址 ifconfig #添加带别名的,使用label指定别名,ifconfig就能看到新添加的ip地址了 ip addr add 192.168.147.155/24 dev ens33 label ens33:0 #再次查看 ifconfig #删除指定网卡接口下的指定ip ip addr del 192.168.147.155/24 dev ens33 #查看192.168.147.155这个地址已经被删除 ip addr show #清空该网卡接口的所有ip地址 ip addr flush dev ens33 #查看地址已被清空 ip addr show ens33 ip route 路由表管理 ip route add:add new routeip route add TYPE PREFIX via GW [dev IFACE] [src SOURCE_IP] ip route change:change routeip route replace:change or add new oneip route delete:delete routeip route del TYPE PREFIX ip route [show | list]:list routesip route flush:flush routing tablesip route get:get a single route #查看路由表 ip route list #为ens33网卡接口添加2个ip ip addr add 10.0.10.100/8 dev ens33 ip addr add 10.0.20.100/8 dev ens33 ip addr list ens33 #要到达192.168.0.0这个网络,需要通过网关10.0.0.1 ip route add 192.168.0.0/24 via 10.0.0.1 dev ens33 #要到达192.168.1.0/24这个网络,需要通过网关10.0.0.1 ip route list #要到达172.16.0.0/16这个网络,需要通过网关10.0.0.1并指定源地址10.0.20.100 ip route add 172.16.0.0/16 via 10.0.0.1 dev ens33 src 10.0.20.100 ip route list #添加默认路由 ip route add default via 192.168.147.2 dev ens33 ip route list #删除路由 ip route del 10.0.0.0/8 ip route del default via 192.168.147.2 dev ens33 ip route del 192.168.0.0 #显示路由,显示src为192.168.122.1的路由,ip route show和ip route list意义一样 ip route show src 192.168.122.1 ip route list src 192.168.122.1 #显示到达192.168.147.0/24这个网络的路由信息 ip route get 192.168.147.0/24 #清空所有网络号为10/8的路由信息 ip route flush 10/8 ip route show ss命令: ss [options] [ FILTER ]选项:-t:TCP协议的相关连接-u:UDP相关的连接-w:raw socket相关的连接-l:监听状态的连接-a:所有状态的连接-n:数字格式-p:相关的程序及其PID-e:扩展格式信息-m:内存用量-o:计时器信息 状态过滤和表达式过滤FILTER := [ state STATE-FILTER ] [ EXPRESSION ] TCP的常见状态:TCP FSM(Finite State Machine):LISTEN:监听ESTABLISHED:已建立的连接FIN_WAIT_1:FIN_WAIT_2:SYN_SENT:SYS_RECV:COLOSED: EXPRESSION:dport=sport=示例:'( dport = :22 or sport = :22 )' #查找tcp状态为ESTABLISHED的 ss -tan state ESTABLISHED #查找目标端口和端口为22的 ss -tan '( dport = :22 or sport = :22 )' 网卡接口配置文件 注:我们之前使用的ifconfig或ip命令所修改的网络属性,重启以后都将会失效;想永久有效需要写在配置文件中; IP/NETMASK/GW/DNS等属性的配置文件:/etc/sysconfig/network-scripts/ifcfg-IFACEIFACE:网卡接口名称; 配置文件/etc/sysconfig/network-scripts/ifcfg-IFACE通过大量参数来定义接口的属性;其可通过vim等文本编辑器直接修改,也可以使用专用的命令的进行修改(CentOS6:system-config-network(setup),CentOS7:nmtui) ifcfg-IFACE配置文件参数: DEVICE:此配置文件对应的设备的名称;需要与IFACE保持一致;ONBOOT:在系统引导过程中,是否激活此接口;UUID:此设备的唯一标识;IPV6INIT:是否初始化IPV6;BOOTPROTO:激活此接口时使用什么协议来配置接口属性,常用的有dhcp、bootp、static、none(注none也表示静态地址和static一样);TYPE:接口类型,常见的有Ethernet、Bridge;DNS1:第一个DNS服务器指向;DNS2:备用DNS服务器指向;DNS3:备用DNS服务器指向;DOMAIN:DNS搜索域;GATEWAY:默认网关;IPADDR:IP地址;NETMASK:子网掩码;CentOS7支持使用PREFIX以长度方式指明子网掩码;注:CentOS7中NETMASK和PREFIX只需指定一个;PREFIX:子网掩码短格式,值有:8、16、24、32;CentOS6、7都支持;USERCTL:是否允许普通用户控制此网卡设备;PEERDNS:如果BOOTPROTO的值为\"dhcp\",是否允许dhcp server分配的dns服务器指向覆盖本地手动指定的DNS服务器指向;默认为yes;值[yes|no];HWADDR:设备的MAC地址;NM_CONTROLLED:是否使用NetworkManager服务来控制网卡接口;网络服务:networkNetworkManager 管理网络服务:CentOS6:service SERVICE {start|stop|restart|status} 配置文件修改后,如果要生效,需要重启网络服务 #查看network服务状态 service network status #重启服务 service network restart CentOS7:systemctl {start|stop|restart|status} SERVICE[.service] systemctl restart network.service systemctl restart network 增加新网卡设备: cd /etc/sysconfig/network-scripts cp ifcfg-ens33 ifcfg-ens37 使用vim ifcfg-ens37编辑配置文件: TYPE=Ethernet BOOTPROTO=none NAME=ens37 DEVICE=ens37 ONBOOT=yes IPADDR=192.168.147.158 PREFIX=24 GATEWAY=192.168.147.2 DNS1=192.168.147.2 最后systemctl restart network.service使配置文件生效,可以使用新配置的网卡做ssh连接,并ping或者使用curl http://www.baidu.com测试网络是否通畅; 路由的配置文件 路由配置文件网卡重启后会永久生效网卡接口指定了默认网关,当用到非默认网关路由时,需要配置路由的相关配置文件:/etc/sysconfig/network-scripts/route-IFACE 支持两种配置方式,但不可混用:(1) 每行一个路由条目:TARGET via GW cd /etc/sysconfig/network-scripts/ #创建对应的路由文件这里的网卡设备名叫ens33所以文件名为route-ens33 vim route-ens33 route-ens33文件如下: 要到达10.0.0.0/8这个网络,通过下一跳地址192.168.147.2 10.0.0.0/8 via 192.168.147.2 dev ens33 #重启使配置永久生效 systemctl restart network #查看路由表 ip route list (2) 每三行一个路由条目:ADDRESS#=TARGETNETMASK#=MASKGATEWAY#=NEXTHOP 编辑route-ens33文件,清空所有内容,然后编写一下第二种配置方式: ADDRESS0=20.0.0.0 NETMASK0=255.0.0.0 GATEWAY0=192.168.147.178 #重启使配置永久生效 systemctl restart network #查看路由表 ip route list 给网卡接口配置多个地址: ip addr之外,ifconfig或配置文件都可以; (1) ifconfig IFACE_LABEL IPADDR/NETMASKIFACE_LABEL: ens0:0,ens0:1,... #为ens33新增ip,指定别名为ens33:0 ifconfig ens33:0 192.168.147.212/24 #查看 ifconfig #重启即失效 systemctl restart network #查看 ifconfig (2) 配置文件配置(永久生效)DEVICE=IFACE_LABELBOOTPROTO:别名网卡不支持动态获取地址;值只能是:static、none cd /etc/sysconfig/network-scripts #复制网卡接口配置文件 cp ifcfg-ens33 ifcfg-ens33:0 编辑ifcfg-ens33:0文件如下: BOOTPROTO=none NAME=ens33:0 DEVICE=ens33:0 ONBOOT=yes IPADDR=192.168.147.212 PREFIX=24 GATEWAY=192.168.147.2 DNS1=192.168.147.2 重启 #重启即失效 systemctl restart network #查看 ifconfig nmcli命令 #网卡设备显示 nmcli device show #查看网卡设备状态 nmcli device status #禁用ens37网卡设备 nmcli device disconnect ens37 #查看状态 nmcli device status #启用ens37网卡设备 nmcli device connect ens37 #查看状态 nmcli device status #查看网卡设备连接状态 nmcli connect show #禁用ens37设备 nmcli connect down ens37 #查看网卡设备连接状态 nmcli connect show #为ens37添加新ip地址 nmcli conn modify ens37 +ipv4.address 192.168.147.188 #重启网卡 nmcli conn down ens37 nmcli conn up ens37 #查看 nmcli device show ens37 ip addr show ens37 #为ens37减去ip地址 nmcli conn modify ens37 -ipv4.address 192.168.147.188 #重启网卡 nmcli conn down ens37 nmcli conn up ens37 #查看 nmcli device show ens37 ip addr show ens37 "},"pages/29.Linux进程及作业管理.html":{"url":"pages/29.Linux进程及作业管理.html","title":"29.Linux进程及作业管理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Linux系统上的进程查看及管理工具 pstree命令 ps命令 ps [options] 常用组合之一: aux 选项为Unix风格有- 常用组合二: -ef 常用组合之三: -eFH 常用组合之四: -eo,axo pgrep、pkill命令: pidof命令: top命令: uptime命令:显示系统时间、运行时长及平均负载; Linux进程及作业管理 内核的功用:进程管理、文件系统、网络功能、内存管理、驱动程序、安全功能 Process:运行中的程序的一个副本;存在生命周期 Linux内核存储进程信息的固定格式:task struct多个任务的task struct组成的链表:task list 进程创建:init进程由kernal创建父子关系进程:由其父进程创建fork(),clone() 进程优先级:0-139:1-99:实时优先级;(数字越大优先级越高)100-139:动态优先级;(数字越小,优先级越高) Nice值:-20-19分别对应于100-139的动态优先级 进程内存:Page Frame:页框,用存储页面数据存储Page MMU:Memory Management Unit 进程间通信:IPC:Inter Process Communication同一主机上:signalshm:shared memorysemerphor 不同主机上:rpc:remote procedure callsocket Linux内核:抢占式多任务 进程类型:守护进程:daemon,在系统引导过程中启动的进程,跟终端无关的进程;前台进程:跟终端相关,通过终端启动的进程;注意:也可把在前台启动的进程送往后台,以守护模式运行; 进程状态:运行态:running就绪态:ready睡眠态:可中断睡眠态:interruptable不可中断睡眠态:uninterruptable停止态:stopped;暂停于内存中,但不会被调度,除非手动启动之;僵死态:zombie 进程的分类:CPU bound IO bound Linux系统上的进程查看及管理工具 pstree,ps,pidof,pgrep,top,htop,glances,pmap,vmstat,dstat,kill,pkill,job,bg,fg,nohup,nice,renice,killall,... pstree命令 用于查看进程树进程数的根:CentOS6:initCentOS7:systemd ps命令 显示当前命令执行这一刻的所有进程状态/proc/:内核将它内部很多状态信息通过伪文件系统/proc/输出给用户的;内核参数:可设置其值从而调整内核运行特性的参数;/proc/sys/状态变量:其用于输出内核中统计信息或状态信息,仅用于查看; 参数:模拟成文件系统类型; 进程:/proc/#:这里的#PID,进程号;这个目录下有许多进程号文件夹,文件夹中保存了很多参数,这些参数代表着进程的状态; 启动进程的方式:系统启动过程中自动启动:与终端无关的进程;用户通过终端启动:与终端相关的进程; ps [options] 选项BSD分隔:无-a:所有与终端相关的进程;x:所有与终端无关的进程;u:以用户为中心组织进程状态信息显示; 常用组合之一: aux USER:启动该进程的用户;PID:进程号;%CPU:CPU占用百分比;%MEM:内存空间占用百分比;VSZ:虚拟内存集(Virtual Memory Size);其实就是占用的虚拟内存大小;RSS:常驻内存集(Resident Memory Size);不能放在交换内存(swap分区)中的数据称之为常驻内存集;TTY:终端;STAT:进程状态:　　　　R:running　　　　S:interruptable sleeping　　　　D:uninterruptable sleeping　　　　T:stopped　　　　Z:zomble　　　　+:前台进程　　　　l:多线程进程　　　　N:低优先级进程　　　　　　　　s:session leader;会话引领者;例如启动一个终端,终端上启一个bash,里面有个shell程序启动了好几级,　　　　这时这个bash就是会话领导者,我们把这个bash的会话kill了,那它的子子孙孙进程也都被kill了 START:进程启动时间 TIME:累计占用CPU的时间;COMMAND:由哪个命令启动的该进程;里面有很多带[]的表示内核线程; ps aux 选项为Unix风格有- -e:显示所有进程-f:显示完整格式的进程信息 常用组合二: -ef ps -ef -F:显示完整格式的进程信息(比-f更详细点) -H:以层级结构显示进程的相关信息; 常用组合之三: -eFH ps -eFH 常用组合之四: -eo,axo o field1,field2,...:自定义要显示的字段,以逗号分隔;常用的field:pid,ni,pri,psr,pcpu,stat,comm,tty,ppid,rtprloni:nice值;范围:-20-19priority:优先级;rtprlo:real time priority,实时优先级; BSD风格:-eoUnix风格:axo #BSD风格只显示pid和command ps axo pid,command #Unix风格只显示pid和command ps -eo pid,command pgrep、pkill命令: 根据进程名或其他属性来查询进程或向进程发送信号 pgrep [options] pattern-u uid:effective user,以哪个用户的身份运行;-U uid:read user,哪个用户启动的;-t TERMINAL:与指定的终端相关的进程;-l:显示进程名;-a:显示完整格式的进程名;-P pid:显示此进程的子进程; #列出启用postfix进程的用户和进程名 pgrep -U postfix -l ps aux | grep \"^postfix\" #列出启用postfix进程的用户和完整格式的进程名 pgrep -U postfix -a #显示指定进程号的子进程 pgrep -P 6870 #根据进程名查询出进程id pgrep ssh pgrep httpd pgrep nginx pkill命令以上选项全部使用,用于终止进程; pidof命令: 根据进程名,取其pid; pidof sshd top命令: 类似于windows中的任务管理器,以动态方式不断的刷新的来查看当前系统上所有进程状态信息;(默认占用CPU资源最多进程程序名排在最前面); top 首部信息:top - 17:08:57:系统当前时间;up 8 min:系统运行时长;2 users:登录到当前系统上的用户数;load average:平均负载;过去1分钟、5分钟和15分钟的平均负载;平均负载指的是:等待运行的进程队列长度;Tasks:225 total:一共运行有多少个进程;1 running:进程运行状态数;224 sleeping:进程睡眠状态数;0 stopped:进程停止状态数;0 zombie:进程僵死状态数; %Cpu(s):CPU占用百分比:0.1 us:用户空间(us:User space);用户空间进程所占用的cpu百分比;0.4 sy:内核空间(sy:System)内核所占用cpu的百分比;(高负载时,用户空间和内核空间比例在7:3左右);0.0 ni:Nice值调整以后额外占用CPU百分比(ni:Nice);99.4 id:空闲时间CPU百分比(id:idle);0.1 wa:等待io完成所消耗的百分比(wa:wait),如果这个百分比很高,io可能成为了系统的瓶颈;0.0 hi:处理硬件中断所消耗的CPU百分比(hi:hardware interrupt);0.0 si:处理软件中断所消耗的CPU百分比(si:software interrupt);0.0 st:被虚拟化程序(虚拟机)偷走的CPU百分比(st:stolen); KiB Mem:以kb来显示物理内存占用情况;1863248 total:一共有多少内存;245432 free:空闲内存;可使用的内存;786324 used:已使用内存;831492 buff/cache:用于缓冲和缓存的内存空间;它们可以被回收回来直接使用的; KiB Swap:以kb来显示交换分区内存占用情况;前三项和kib Mem一样;845512 avail Mem:可用内存空间; 进程列表中的表头:PID:进程编号;USER:用户;PR:优先级;NI:Nice值;VIRT:虚拟内存集;RES:常驻内存集;SHR:共享内存空间;S:当前状态;%CPU:占据CPU百分比;%MEM:占据内存百分比;TIME+:占用CPU的累计时间(占用时长);COMMAND:进程启动命令; top命令排序:输入:P,按CPU占用率排序;默认按照CPU占用率降序排序;输入:M,按内存占用率排序;输入:T,占用CPU的累计时间排序; 首部信息:uptime信息:输入l,可以显示和隐藏;tasks及cpu信息:输入t,可以显示和隐藏;内存信息:输入m,可以显示和隐藏;显示每个cpu信息:输入1,可以显示和隐藏 退出命令:q 修改刷新时间间隔:输入s,提示:Change delay from 3.0 to,这里就可以直接输入秒数回车即可(默认为3秒); 终止某进程:输入k,提示:PID to signal/kill,然后输入进程号回车,提示输入信号:Send pid 20816 signal [15/sigterm]这里回车使用15信号即可,就可以终止指定的进程了; 选项:-d #:指定刷新时间间隔,默认为3秒;-b:以批次方式显示,默认每3秒刷一屏显示;-n #:显示多少批次; uptime命令:显示系统时间、运行时长及平均负载; 过去1分钟、5分钟和15分钟的平均负载;平均负载指的是:等待运行的进程队列长度; #使用uptime可以显示top的第一行信息 uptime "},"pages/30.Linux进程及作业管理二.html":{"url":"pages/30.Linux进程及作业管理二.html","title":"30.Linux进程及作业管理二","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 kill killall命令 vmstat命令 pmap命令(了解): glances命令(了解): dstat命令(了解): Linux系统作业控制: 进程优先级调整 nice命令: renice命令 renice [-n] NICE PID... 未涉及到的命令:sar,tsar,lostat,lftop,nethog,... htop命令 top的升级版,可视化效果更好,且支持鼠标操作htop需要通过EPEL源安装 选项:-d #:指定延迟时间间隔;-u UserName:仅显示指定用户的进程;-s column:以指定字段进行排序; 子命令:l:显示选定的进程打开的文件列表;s:跟踪选定的进程的系统调用;t:以层级关系显示各进程状态;a:将选定的进程绑定至某指定的CPU核心; 使用htop需要安装: #将epel.repo安装仓库文件下载到/etc/yum.repos.d目录中 yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm #查看有哪些安装仓库文件 yum repolist #安装htop yum install htop -y #查看 htop kill 用于终止一个进程;向进程发送信号,以实现对进程的管理; 显示当前系统可用信号:kill -l [signal] #显示所有信号 kill -l #显示1号信号 kill -l 1 每个信号的标识方法有三种:1) 信号的数字标识;2) 信号的完整名称;3) 信号的简写名称; 向进程发信号:kill [-s signal|-signal] pid... 常用信号:1) SIGHUP:无需关闭进程而让其重读配置文件(不需要重启服务,重新加载配置);2) SIGINT:中断,相当于Ctrl+C;3) SIGQUIT:退出,相当于Ctrl+\\;9) SIGKILL:强制终止;(如果进程有内容没执行完毕,不等待,会被强行终止)15) SIGTERM:终止正在运行中进程;不指定默认信号为15;(如果进程有内容没执行完毕,会等待进程执行的内容操作完毕后,终止进程)18) SIGCONT:继续(与STOP相反,fg/bg命令)19) SIGSTOP:暂停(Ctrl+Z用于暂停,比如vim使用一半可以用Ctrl+Z暂停,fg命令可以继续之前的暂停,bg可以查看暂停的进程) #-s指定信号为15、进程号为7024 kill -s 15 7024 #以下操作完全相同,只是写法不同 #信号1的数字标识 kill -1 32649 #信号1的简写名称 kill -HUP 32649 #信号的完整名称 kill -SIGHUP 32649 #信号的完整名称二 kill -s SIGHUP 32649 killall命令 根据进程名来杀死进程;可以根据名称杀死该名称的所有进程; kill [-signal] program... killall nginx vmstat命令 报告虚拟内存(virtual memory)的统计信息 vmstat [options] [delay] [count] 选项:-s:显示内存统计数据; vmstat #每2秒刷新一次 vmstat 2 #每2秒刷新一次,只显示3次 vmstat 2 3 #显示内存统计数据 vmstat -s procs(process):r(running):等待运行的进程的个数;CPU中等待运行的任务队列长度;b(blocked):处于不可中断睡眠态的进程个数;被阻塞的任务队列的长度; memory:swpd:交换内存使用总量;free:空闲的物理内存总量;buffer:用于buffer的内存总量;cache:用于cache的内存总量; swap:si(swap in):数据进入swap中的数据速率(kb/s)so:(swap out):数据离开swap中的数据速率(kb/s) io:bi(block in):从块设备读入数据到系统的速率(kb/s)bo(block out):保存数据至块设备的速率(kb/s) system:in(interrupt):中断速率;cs(context switch):上下文切换的速率; cpuus:用户空间(us:User space);用户空间进程所占用的cpu百分比;sy:内核空间(sy:System)内核所占用cpu的百分比;(高负载时,用户空间和内核空间比例在7:3左右);id:空闲时间CPU百分比(id:idle);wa:等待io完成所消耗的百分比(wa:wait),如果这个百分比很高,io可能成为了系统的瓶颈;st:被虚拟化程序(虚拟机)偷走的CPU百分比(st:stolen); pmap命令(了解): 报告一个进程的内存映射表 pmap [options] pid [...]-x:显示详细格式的信息; 另一种查看方式:cat /proc/PID/maps #pmap查看pid为1的systemd进程 pmap 1 #另一种查看方式 cat /proc/1/maps #显示详细格式的信息 pmap -x 1 glances命令(了解): glances需要通过EPEL源安装跨平台的监控工具,监控cpu使用率、内存使用率等 常用选项:-b:以Byte为单位显示网卡数据速率;-d:关闭磁盘I/O模块;-n:关闭network模块;-t #:刷新时间间隔;-1:每个cup的相关数据单独显示; #安装glances yum install -y glances #类似htop的监控效果 glances dstat命令(了解): 非常精巧的生成系统资源使用统计数据的工具 dstat [-afv] [options..] [delay [count]] #属于base源 yum install -y dstat #查看 dstat #每2秒刷新一次,显示5批次 dstat 2 5 Linux系统作业控制: job:前台作业(foreground):通过终端启动,且启动后会一直占据终端;后台作业(background):可以通过终端启动,但启动后即转入后台运行(释放终端); 如何让作业运行于后台?(1) 运行中的作业Ctrl+z注意:送往后台后,作业会转为停止态; (2) 尚未启动的作业COMMAND &注意:此类作业虽然被送往后台,但其依然与终端相关;此时终端进程终止,与终端相关的进程也都会终止;如果希望把送往后台的作业剥离与终端的关系,可以使用:nohup COMMAND &该命令会立即转为与终端无关模式; 查看所有的作业:jobs上图中使用fg默认会调用带有+号的job,图中可以看出会调用htop这项,也可以使用fg 2来调用ping的这项job图中带-号的job代表的是+号job后的下一项 #默认会调用带有+号的job fg #以下2个命令效果一样,都是调用编号为2的job fg 2 fg %2 可实现作业控制的常用命令:fg [[%]][OB_NUM]:(foreground)把指定的作业调回前台;bg [[%]][OB_NUM]:(background)让送往后台的作业在后台继续运行;kill %OB_NUM:终止指定的作业;这个命令%不能省略,如果省略了%会被当做进程号处理,而不是作业号了; #根据作业号,终止指定的作业 kill %3 进程优先级调整 可通过nice值调整的优先级范围:100-139分别对应于:-20-19 进程启动时,其Nice值默认为0,其优先级是120; nice命令: 以指定的nice值启动并运行命令nice [OPTION] [COMMAND [ARGU]...]选项: -n #:指定nice值; ps axo pid,command,nice,priority | grep 'htop' #设置nice值为-5 nice -n -5 htop 注意:仅管理员可以调低nice值; renice命令 调整指定pid的nice值 renice [-n] NICE PID... renice -n -3 42892 查看Nice值和优先级: ps axo pid,comm,ni,priority | grep 'htop' 未涉及到的命令:sar,tsar,lostat,lftop,nethog,... "},"pages/31.网络客户端工具和while、untill循环.html":{"url":"pages/31.网络客户端工具和while、untill循环.html","title":"31.网络客户端工具和while、untill循环","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 ping hping命令(了解) traceroute命令(了解) ftp命令(用的不多,用lftp为主) lftp命令 lftpget命令 wget命令 rz,sz命令 curl命令 elinks 文本的浏览器 while循环: while循环的特殊用法(遍历文件的行): until循环 网络客户端工具 ping、lftp、ftp、lftpget、wget等; ping send ICMP ECHO_REQUEST to network hosts ICMP:internet Control Message Protocol 互联网消息控制协议;用于探测互联网上某一特定主机是否在线或某一网络是否在线;ECHO_REQUEST:回显请求;ECHO_REPLY:回显应答; ping [OPTION] destination-c #:发送的ping包个数;-w #:ping命令超时时长;-W #:一次ping操作中,等待对方响应的超时时长;-s #:指定ping包大小,默认64bytes; #ping三次终止 ping -c 3 www.baidu.com #5秒钟后停止ping操作 ping -w 5 www.baidu.com 指定ping包1024bytes ping -s 1024 www.baidu.com hping命令(了解) (package:hping3)send (almost) arbitrary TCP/IP packets to network hosts 选项:--fast:快速发ping包;Alias for -i u10000. Hping will send 10 packets for second;--flood:能发多快发多快,能发多少发多少; 安装: yum list all | grep 'hping' yum install -y hping3 #对方来讲显然是一种攻击行为,如果对baidu是hping不了的 hping --fast 127.0.0.1 traceroute命令(了解) 从一个主机到目标主机之间到底经过了哪些路由器;跟中从源主机到目标主机之间经过的网关有哪些; ftp命令(用的不多,用lftp为主) ftp:File Transfer Protocolftp服务命令行客户端工具 #安装ftp客户端 yum install ftp -y lftp命令 lftp用于取代ftp命令; lftp [-d] [-e cmd] [-p port] [-u user[,pass]] [site] 登录到ftp服务器后的子命令:get:单文件下载;mget:多文件下载;put:单文件上传;mput:多文件上传;rm,mrm,删除单文件和删除多文件; #安装lftp yum install -y lftp #-u指明用户名zhangsan来访问ftp服务器 lftp -u zhangsan 172.16.0.1 #-u 用户名,密码的方式来访问ftp服务器 lftp -u zhangsan,123456 172.16.0.1 lftpget命令 lftp专用的下载工具 lftpget [-c] [-d] [-v] URL [URL...] -c:断点续传,继续此前的下载; lftpget http://fastsoft.onlinedown.net/down/idm_ald.exe wget命令 非交互式的网络下载器 wget [option]... [URL]...-b:在后台执行下载操作;-q:静默模式,不显示下载进度;-O file:下载的文件的保存位置和文件名;-c:断点续传,继续此前的下载;--limit-rate=amount:以指定的速率传输文件; 注意:lftpget、wget命令只能下载文件,不能下载目录; #直接下载 wget http://fastsoft.onlinedown.net/down/idm_ald.exe #指定保存目录和文件名 wget http://fastsoft.onlinedown.net/down/idm_ald.exe -O /tmp/abc.exe rz,sz命令 rz:上传sz:下载 #查找软件包 yum list | grep rz yum search rz #安装 yum install -y lrzsz.x86_64 #选择文件上传 rz #下载指定目录的文件 sz ~/love.abc curl命令 curl是基于URL语法在命令行方式下工作的文件传输工具,它支持FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE及LDAP等协议.curl支持HTTPS认证,并且支持HTTP的POST、PUT等方法,FTP上传,kerberos认证,HTTP上传,代理服务器,cookies,用户名/密码认证,下载文件断电续传,上载文件断点续传,http代理服务器管道(proxy tunneling),甚至它还支持IPV6,socks5代理服务器,通过http代理服务器上传文件到FTP服务器等等,功能十分强大. curl [options...] url -A/--user-agent 设置用户代理发送给服务器--basic 使用HTTP基本认证--tcp-nodelay 使用TCP_NODELAY选项-e/--referer 来源网址--cacert CA证书(SSL)--compressed 要求返回是压缩的格式-H/--header 自定义首部信息传递给服务器-I/--head 只显示响应报文首部信息--limit-rate 设置传输速度-u/--user 设置服务器的用户和密码-0/--http1.0 使用HTTP 1.0 curl http://www.baidu.com #设置用户代理发送给服务器,在/var/log/httpd/access.log下查看该访问的用户代理 curl -A \"chrome10.11\" http://192.168.147.152 curl --user-agent \"chrome10.12\" http://192.168.147.152 #设置referer来源网址 curl --user-agent \"chrome10.12\" -e \"https://www.google.com/search?q=hello\" http://192.168.147.152 #只显示响应报文首部信息 curl -I http://192.168.147.152 elinks 文本的浏览器 elinks [option]... [url]...-dump:不进入交互式模式,而直接将URL的内容输出至标准输出; elinks http://www.baidu.com elinks -dump http://www.baidu.com while循环: while CONDITION;do　　循环体　　自增表达式done while循环计算1-100的示例: #!/bin/bash declare -i i=0 declare -i sum=0 while [ $i -le 100 ];do sum=$[$sum+$i] let i++ done echo $sum while循环的特殊用法(遍历文件的行): while read VARIABLE;do循环体;done 依次读取/PATH/FROM/SOMEFILE文件中的每一行,且将基赋值给VARIABLE变量; 示例:找出ID号为偶数的用户,显示其用户名、ID及默认shell; #!/bin/bash while read line;do userid=$(echo $line | cut -d: -f3) username=$(echo $line | cut -d: -f1) shell=$(echo $line | cut -d: -f7) if [ $[ $userid % 2 ] -eq 0 ];then echo \"$userid,$username,$shell\" fi done until循环 until CONDITION;do　　循环体　　自增表达式done CONDITION进入条件为假,和while的CONDITION相反; #!/bin/bash declare -i sum=0; declare -i i=0; until [ $i -gt 100 ];do let sum+=$i let i++ done echo $sum 练习:分别使用for,while,until实现1、分别求100以内所有偶数之和,100以内所有奇数之和; #!/bin/bash declare -i evenSum=0 declare -i i=0 [ $# -lt 1 ] && echo \"请输入计算偶数的上线的数值!\" && exit 1 while [ $i -le $1 ];do let i++ if [ $[ $i % 2 ] -eq 1 ];then continue fi let evenSum+=$i done echo \"evenSum:${evenSum}\" #!/bin/bash [ $# -lt 1 ] && echo \"请输入求奇数值上限值!\" && exit 1 declare -i i=0 declare -i oddSum=0 while true ;do let i++ if [ $i -eq $1 ];then break; fi if [ $[ $i % 2 ] -eq 0 ];then continue; fi let oddSum+=$i done echo \"oddSum:${oddSum}\" #!/bin/bash [ $# -lt 1 ] && echo \"请输入求奇数值上限值!\" && exit 1 declare -i i=1 declare -i oddSum=0 while true;do let oddSum+=$i let i+=2 if [ $i -gt $1 ];then break fi done echo \"oddSum:${oddSum}\" 2、创建10个用户,user101-user110;密码同用户名;3、打印九九乘法表; #!/bin/bash for i in {1..9};do for j in $(seq 1 $i);do echo -e -n \"${j}x${i}=$[${j}*${i}]\\t\" done echo done 4、打印逆序的九九乘法表; 5、练习:每隔3秒钟到系统上获取已经登录的用户信息;其中,如果logstash用户登录了系统,则记录于日志中,并退出; #!/bin/bash while true;do sleep 3 who | grep \"^logstash\\>\" &> /dev/null && echo \"$(date \"+%F %T\") logstash logged on\" >> ~/script/log && break done #!/bin/bash while true;do sleep 3 if who | grep \"^logstash\\>\" &> /dev/null;then break fi done echo \"$(date \"+%F %T\") logstash logged on\" >> ~/script/log #!/bin/bash until who | grep \"^logstash\\>\" &> /dev/null;do sleep 3 done echo \"$(date \"+%F %T\") logstash logged on\" >> ~/script/log "},"pages/32.CentOS系统启动流程.html":{"url":"pages/32.CentOS系统启动流程.html","title":"32.CentOS系统启动流程","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Linux系统组成部分: 进程间通信(IPC:Inter process Communication): 运行中的系统环境可分为两层:内核空间、用户空间 内核设计流派: Linux内核特点: Linux内核组成部分: CentOS 系统的启动流程: POST(Power On Self Test):加电自检; Boot Sequence: Kernel: init程序的类型: ramdisk: /sbin/init: CentOS 5: SysV init 配置文件:/etc/inittab chkconfig: 2345 50 60 prog=$(basename $0) CentOS 6: CentOS 7: CentOS系统启动流程 Linux系统组成部分: 内核+根文件系统内核:进程管理、内存管理、网络协议栈、文件系统、驱动程序、安全功能(加解密栈、SELinux) 进程间通信(IPC:Inter process Communication): 通主机上:消息队列、semerphor、shm不同主机上:socket、RPC 运行中的系统环境可分为两层:内核空间、用户空间 用户空间:应用程序(进程或线程)内核空间:内核代码(系统调用) 内核设计流派: 单内核设计:把所有功能集成于同一个程序;Linux微内核设计:每种功能使用一个单独的子系统实现;Windows,Solaris Linux内核特点: 支持模块化:.ko(kernel object);支持模块运行时动态装载或卸载; Linux内核组成部分: 核心文件:/boot/vmlinuz-VERSION-releaseramdisk:CentOS5:/boot/initrd-VERSION-release.imgCetnOS6,7:/boot/initramfs-VERSION-release.img 模块文件:/lib/modules/VERSION-release CentOS 系统的启动流程: POST(Power On Self Test):加电自检; ROM:CMOSBIOS:Basic Input and Output System Boot Sequence: 按次序查找各引导设备,第一个有引导程序的设备即为本次启动要用到的设备;bootloader:引导加载器:windows:ntloaderLinux:LILO(Linux loader)GRUB:Grand Uniform BootloaderGRUB 0.x:Grub LegacyGRUB 1.x:Grub2 功能:提供一个菜单,允许用户选择要启动的系统或不同的内核版本;把用户选定的内核装在到RAM(内存)中的特定空间中,解压、展开,而后把系统控制权移交给内核; MBR:Master Boot Record512bytes:446bytes:bootloader64bytes:fat(分区表)2bytes:55AA(如果是55AA表示MBR是有效的) GRUB:bootloader:1st stagePartition: filesystem driver,1.5 stagePartition:/boot/grub,2nd stage Kernel: 自身初始化:探测可识别到的所有硬件设备;加载硬件驱动程序;(有可能会借助于ramdisk加载驱动)以只读方式挂载根文件系统;运行用户空间的第一个应用程序:/sbin/init init程序的类型: CentOS5:SysV init配置文件:/etc/inittab CentOS6:Upstart配置文件:/etc/inittab/etc/init/*.conf CentOS7:Systemd配置文件:/usr/lib/systemd/system/,/etc/systemd/system/ ramdisk: Linux内核的特性之一:使用缓冲和缓存来加速对硬盘上文件访问;ramdisk --> ramfsCentOS5:initrd工具程序:mkinitrdCentOS6,7:initramfs工具程序:dracut、mkinitrd 系统初始化流程(内核级别):POST-->BootSequence(BIOS)-->BootLoader(MBR)-->Kernel(ramdisk)-->rootfs(read only)-->/sbin/init /sbin/init: CentOS 5: SysV init 运行级别:为了系统的运行或维护等目的而设定的机制;0-6:7个级别;0:关机,shutdown1:单用户模式(single user),root用户,无需认证(登录);维护模式(比如忘记root密码,进入该模式修改即可);2:多用户模式(multi user),回启动网络功能,但不会启动NFS;维护模式;3:多用户模式(multi user),完全功能模式;文本界面;4:预留级别:目前无特别使用目的,但习惯以同3级别功能使用;5:多用户模式(multi user),完全功能模式,图形界面;6:重启,reboot 默认级别:3、5 级别切换:init # init 3 级别查看: #查看当前的运行级别 who -r #查看上一次和这次的系统的运行级别 runlevel 配置文件:/etc/inittab 每行定义一种action以及与之对应的processid:runlevel:action:processid:一个任务的标识符;runlevels:在哪些级别启动此任务;#,###,也可以为空,表示所有级别;action:在什么条件下启动此任务;process:任务; action:　　　wait:等待切换至此任务所在的级别时执行一次;　　　respawn:一旦此任务终止时,就自动重新启动之;　　　initdefault:设定默认运行级别;此时,process省略;　　　sysinit:设定系统初始化方式,此处一般为指定/etc/rc.d/rc.sysinit脚本; 例如:id:3:initdefault::设定默认的运行级别为3;si::sysinit:/etc/rc.d/rc.sysinit:这里省略运行级别,代表所有运行级别都会运行所指定的脚本;l0:0:wait:/etc/rc.d/rc 0l1:1:wait:/etc/rc.d/rc 1...........l6:6:wait:/etc/rc.d/rc 6:切换至0运行级别会运行/etc/rc.d/rc文件,并传递参数0........... 切换至6运行级别会运行/etc/rc.d/rc文件,并传递参数6;意味着去启动或关闭/etc/rc.d/rc0.d目录下的服务脚本所控制的服务;K:要停止的服务;k##,优先级,数字越小,越是优先关闭;依赖的服务先关闭,而后关闭被依赖的服务;S:要启动的服务;S##,优先级,数字越小,越是优先启动;被依赖的服务先启动,而后启动依赖的服务;rc脚本:接受一个运行级别数字为参数; 脚本框架:for srv in /etc/rc.d/rc#.d/K*;do　　＄srv stopdone for srv in /etc/rc.d/rc#.d/S*;do　　＄srv startdone /etc/init.d/(/etc/rc.d/init.d/)脚本执行方式:/etc/init.d/SRV_SCRIPT {start|stop|restart|status} 注:以下命令在CentOS5,6上执行: /etc/init.d/crond stop /etc/init.d/crond start /etc/init.d/crond restart /etc/init.d/crond status service SRV_SCRIPT {start|stop|restart|status} #实际上这里执行的就是/etc/rc.d目录下的crond服务脚本 service restart crond chkconfig命令:管控/etc/init.d/每个服务脚本在各级别下启动或关闭状态 vim /etc/init.d/testsrv.sh: #!/bin/bash # testsrv.sh 是一个服务测试脚本 # # chkconfig: 2345 50 60 # description:服务测试脚本 # prog=$(basename $0) if [ $# -lt 1 ];then echo \"使用:$prog (start|stop|status|restart)\" exit 1 fi if [ \"$1\" == \"start\" ];then echo \"start $prog finished.\" elif [ \"$1\" == \"stop\" ];then echo \"stop $prog finished.\" elif [ \"$1\" == \"restart\" ];then echo \"restart $prog finished.\" elif [ \"$1\" == \"status\" ];then if pidof $prog &> /dev/null;then echo \"$prog is running.\" else echo \"$prog is stopped.\" fi else echo \"使用:$prog (start|stop|status|restart)\" exit 2 fi # chkconfig: 2345 50 60:这里的2345代表运行级别,50代表要启动的服务的优先级,60代表要停止的服务优先级; #检查是否有语法错误 bash -n testsrv #设置该文件有执行权限 chmod +x testsrv #表示testsrv服务受checkconfig管理 chkconfig --add testsrv #这样所有级别都受到checkconfig管理了 ls /etc/rc.d/rc0.d/ | grep \"testsrv\" ls /etc/rc.d/rc2.d/ | grep \"testsrv\" # chkconfig: 2345 50 60这里运行级别写成2345的意思是,当我们chkconfig --add testsrv.sh的时候,运行级别2,3,4,5都设置为要启动的服务、其他运行级别为要停止的服务;请看下图:注:如果希望所有运行级别服务都是停止的,可以设置为-,如:# chkconfig: - 50 60 #这时就可以对其做服务操作了 service testsrv start service testsrv status #直接指定路径操作 /etc/init.d/testsrv restart 如果服务想脱离chkconfig管理,可以使用以下命令: #testsrv服务脱离chkconfig管理 chkconfig --del testsrv 查看服务状态列表:chkconfig --list [name] chkconfig --list chkconfig --list testsrv 修改指定级别状态:chkconfig [--level LEVELS] serviceName --level LEVELS:指定要控制的级别;默认为2345;注意:这只是影响下一次开机的效果,当前是启动还是关闭的没有任何影响; #指定运行级别2345关闭 chkconfig --level 2345 testsrv off chkconfig --list testsrv #指定运行级别35开启 chkconfig --level 35 testsrv on chkconfig --list testsrv #如果不指定级别,则默认开启2345,如下: chkconfig testsrc on chkconfig --list testsrv 注意:正常级别下(运行级别3、5),最后启动的一个服务S99local链接至/etc/init.d下的某脚本,而是链接至了/etc/rc.d/rc.local (/etc/rc.local)脚本;因此,不便或不需写为服务脚本的程序期望能开机自动运行时,直接放置于此脚本文件中即可. tty1:2345:respawn:/usr/sbin/mingetty tty1......tty6:2345:respawn:/usr/sbin/mingetty tty6当运行级别是2,3,4,5时,自动运行/usr/sbin/mingetty程序,mingetty命令用来启动虚拟终端,tty1是参数(1) mingetty会调用login程序;(2) 打开虚拟终端程序除了mingetty之外,还有诸如getty等; 系统初始化脚本:/etc/rc.d/rc.sysinit(1) 设置主机名; HOSTNAME=$(/bin/hostname) set -m if [ -f /etc/sysconfig/network ]; then . /etc/sysconfig/network fi if [ -z \"$HOSTNAME\" -o \"$HOSTNAME\" = \"(none)\" ]; then HOSTNAME=localhost fi (2) 设置欢迎信息;(3) 激活udev(设备)和selinux;(4) 挂载/etc/fstab文件中定义的所有文件系统;(5) 检测根文件系统,并以读写方式重新挂载根文件系统;(6) 设置系统时钟;(7) 根据/etc/sysctl.conf文件来设置内核参数;(8) 激活lvm及软raid设备;(9) 激活各swap设备;(10)加载额外设备的驱动程序;(11)清理操作; 总结 (用户空间的启动流程): /sbin/init (/etc/inittab)设置默认运行级别-->运行系统初始化脚本,完成系统初始化-->关闭对应级别下需要停止的服务,启动对应级别下需要开启的服务-->设置登录终端[-->启动图形终端] CentOS 6: init程序:upstart,但依然为/sbin/init,其配置文件:/etc/init/.conf/etc/inittab (仅用于定义默认级别)注意:.conf为upstart风格的配置文件; CentOS 7: init程序:systemd,配置文件:/usr/lib/systemd/system/,/etc/systemd/system/ 完全兼容SysV脚本机制;因此,service命令依然可用;不过,建议使用systemctl命令来控制服务; systemctl {start|stop|restart|status} name[.service] "},"pages/33.grub系统配置与使用.html":{"url":"pages/33.grub系统配置与使用.html","title":"33.grub系统配置与使用","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 GRUB(Boot Loader): grub legacy: grub如何识别设备: grub的命令行接口 手动在grub命令行接口启动系统: 配置文件: /boot/grub/grub.conf 示例:grub.conf中添加菜单编辑认证和选定的内核或操作系统时进行认证 进入单用户模式: 安装grub: 回顾: CentOS 6启动流程:POST --> Boot Sequence(BIOS) --> Boot Loader (MBR) --> Kernel(ramdisk) --> rootfs --> switchroot --> /sbin/init --> (/etc/inittab,/etc/init/*.conf) --> 设置默认运行级别 --> 系统初始化脚本 --> 关闭或启动对应级别下的服务 --> 启动终端 GRUB(Boot Loader): grub 0.x:grub legacygrub 1.x:grub2 grub legacy: stage1:mbrstage1_5:mbr之后的扇区,让stage1中的bootloader能识别stage2所在的分区上的文件系统;stage2:磁盘分区(/boot/grub) 配置文件:/boot/grub/grub.conf stage2及内核等通常放置于一个基本磁盘分区:功用:(1) 提供菜单、并提供交互式接口e:编辑模式,用于编辑菜单;c:命令模式,交互式接口;(2) 加载用户选择的内核或操作系统允许传递参数给内核可隐藏此菜单(3) 为菜单提供了保护机制为编辑菜单进行认证为启用内核或操作系统进行认证 grub如何识别设备: (hd#,#):hd#:磁盘编号,用数字表示,从0开始编号;#:分区编号,用数字表示,从0开始编号;(hd0,0):第一块硬盘的,第一个分区; grub的命令行接口 启动CentOS时,有5秒等待,按任意键可以进入grab选项界面,按C键可以进入grab命令行按e键: help:获取帮助列表;help KEYWORD:详细帮助信息;find (hd#,#)/PATH/TO/SOMEFILE:查找定位某文件是否存在;root (hd#,#):把哪一个磁盘分区设定为根设备;kernel /PATH/TO/KERNEL_FILE:设定本次启动时用到的内核文件;额外还可以添加许多内核支持使用的commandline参数;例如:init=/path/to/init,selinux=0initrd /PATH/TO/INITRAMFS_FILE:设定为选定的内核提供额外文件的ramdisk;boot:引导启动选定的内核; #查看grub的命令帮助 help #查看具体命令find帮助 help find #vmlinuz内核为内核压缩文件名开头,两次tab,可以查找是否有内核的压缩文件:vmlinuz-version-el#.arch find (hd0,0)/vmlinuz #设置第一块磁盘的第一个分区为根设备 root (hd0,0) #设置完根设备后就可以使用/来访问了,两次tab,可以查找是否有内核的压缩文件:vmlinuz-version-el#.arch find /vmlinuz 手动在grub命令行接口启动系统: #设定根磁盘和分区 root (hd0,0) #设置内核文件,指定根文件系统的设备(磁盘),quiet代表静默模式,不显示设置信息 kernel /vmlinuz-2.6.32-754.12.1.el6.x86_64 ro root=/dev/sda3 quiet #指定内核补充性的ramdisk文件 initrd /initramfs-2.6.32-754.12.1.el6.x86_64.img #启动 boot 如下图: 配置文件: /boot/grub/grub.conf 配置项:default=#:设定默认启动的菜单项;菜单项(title)编号从0开始;timeout=#:指定菜单项等待选项选择时长;splashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE:指明菜单背景图片的文件路径;hiddenmenu:隐藏菜单(有这个配置项后,默认系统启动时时没有菜单项选择的);password [--md5] STRING:菜单编辑认证(进入启动菜单时需要键入密码,才能编辑菜单);title TITLE:定义菜单项\"标题\"　　　root (hd#,#):grub查找stage2及kernel文件所在的设备分区;为grub的\"根\";　　　kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]:启动的内核;　　　initrd /PATH/TO/INITRAMFS_FILE:内核匹配的ramfs文件;　　　password [--md5] STRING:启动选定的内核或操作系统时进行认证; 示例:grub.conf中添加菜单编辑认证和选定的内核或操作系统时进行认证 grub-md5-crypt命令: vim /etc/grub.conf: reboot重启后:如果选择第二个选项:,会提示输入密码后才能登录系统; 进入单用户模式: (1) 编辑grub菜单(选定要编辑的title,而后使用e命令);(2) 在选定的kernel后按e键: 进入命令行,输入空格+1,s,S或single都可以;(3) 在kernel所在行,键入\"b\"命令; 安装grub: (1) grub-installgrub-install --root-directory=ROOT /dev/DISK (2) grubroot (hd#,#)setup (hd#) 实验1:新加硬盘,提供直接单独运行bash系统; 实验2:破坏本机grub stage1,而后在救援模式下修复之; "},"pages/34.Linux内核功能及模块应用.html":{"url":"pages/34.Linux内核功能及模块应用.html","title":"34.Linux内核功能及模块应用","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 ldd命令: 内核设计体系:单内核、微内核 内核信息获取: uname命令: 模块信息获取和管理: lsmod命令: modinfo命令: modprobe命令: depmod命令(了解): 模块的装载和卸载的另一组命令: insmod命令:插入模块 rmmod命令:删除模块 ramdisk文件的管理: mkinitrd命令 dracut命令 内核信息输出的伪文件系统 (1) sysctl命令 (2) 文件系统命令 (cat,echo) (3) 配置文件:/etc/sysctl.conf,/etc/sysctl.d/*.conf Linux Kernel CentOS启动流程:POST-->Bootloader(BIOS,MBR)-->Kernel(initrd)-->rootfs-->switch_root-->/sbin/initroot (hd0,0)kernelinitrd ldd命令: 打印应用程序所依赖到的库文件(二进制程序文件所依赖到的库); ldd [OPTION]... FILE... #打印ls的所依赖到的库 ldd /bin/ls #仅获取各库文件的路径,-o:代表只匹配正则匹配到的文本,而非整行 ldd /bin/ls | grep -o \"/lib[^[:space:]]*\" 内核设计体系:单内核、微内核 Linux:单内核设计,但充分借鉴了微内核体系的设计的优点;为内核引入了模块化机制;内核的组成部分:kernel:内核核心,一般为bzimage,通常位于/boot目录,名称为vmlinuz-VERSION-release;kernel object:内核对象,即内核模块,一般放置于/lib/modules/VERSION-release/内核模块与内核核心版本一定要严格匹配; 内核:动态装载和卸载; ramdisk:辅助性文件,并非必须,这取决于内核是否能直接驱动rootfs所在的设备;目标设备驱动,例如:SCSI设备的驱动;逻辑设备驱动,例如LVM设备的驱动;文件系统,例如xfs文件系统; ramdisk:是一个简装版的根文件系统; 内核信息获取: uname命令: print system information 内核对应文件:/boot/vmlinuz-VERSION-release uname [OPTION]...-r:内核的release号-n:主机名-v:操作系统编译版本号(和程序版本号是两回事)-a:显示所有信息 #内核的release号 uname -r #主机名 uname -n #操作系统编译版本号 uname -v 模块信息获取和管理: lsmod命令: Show the status of modules in the Linux Kernel 显示的内容来自于/proc/modules三个字段:Module:模块名称Size:模块大小Used by:被引用次数以及被什么模块所引用 lsmod modinfo命令: 用于显示指定Linux模块的详细信息 #显示ext4模块的详细信息 modinfo ext4 #未被加载的btrfs模块也能使用modinfo查看详细信息 lsmod | grep btrfs modinfo btrfs modprobe命令: 内核中模块的动态装卸载 modprobe [-r] module_name不带-r表示装载模块,带-r表示卸载模块 #装载btrfs模块 modprobe btrfs #查找btrfs是否装载 lsmod | grep btrfs #卸载btrfs模块,注:对正在使用的内核模块,不要轻易去卸载它 modprobe -r btrfs depmod命令(了解): 内核模块依赖关系文件及系统信息映射文件的生成工具; 模块的装载和卸载的另一组命令: insmod命令:插入模块 insmod [filename] [module options...]filename:模块文件的路径; #查看btrfs文件路径 modinfo -n btrfs #查看依赖关系 modinfo -F depends btrfs #insmod无法解决依赖关系，所以需要先插入依赖模块;`modinfo -n raid6_pq`:引用命令结果的方式 insmod `modinfo -n raid6_pq` insmod `modinfo -n xor` insmod `modinfo -n btrfs` #查看 lsmod | grep btrfs rmmod命令:删除模块 rmmod btrfs ramdisk文件的管理: mkinitrd命令 为当前使用中的内核重新制作ramdisk文件:mkinitrd [OPTION...] [] --with=:除了默认的模块之外需要装载至至initramfs中的模块;--preload=:initramfs所提供的模块需要预先装载的模块; #移动或删除之后,下次重启系统之后发现系统启动不了了,这里面拥有装载根文件系统所在设备的驱动和文件系统 mv /boot/initramfs-3.10.0-957.12.1.el7.x86_64.img /tmp #为了避免下次重启系统启动不了,我们可以重新创建它,指定创建文件名和内核版本;过程需要消耗一点时间 mkinitrd /boot/initramfs-$(uname -r).img $(uname -r) #查看 ls /boot/ dracut命令 较为底层的用于生成ramdisk文件的命令dracut [OPTION...] [ []] #删除ramdisk文件 rm /boot/initramfs-3.10.0-957.12.1.el7.x86_64.img #重新创建 dracut /boot/initramfs-$(uname -r).img $(uname -r) #查看 ls /boot/ 内核信息输出的伪文件系统 /proc目录:内核状态和统计信息的输出接口;同时,还提供一个配置接口,/proc/sys;参数:只读:信息输出;例如/proc/#/* (只是用来输出进程的相关信息)可写:可接受用户指定一个\"新值\"来实现对内核某功能或特性的配置; /proc/sys/ /proc/sys:net/ipv4/ip_forward 相当于 net.ipv4.ip_forward (1) sysctl命令 专用于查看或设定/proc/sys目录下参数的值;sysctl [options] [variable[=value]] [...]查看:sysctl -asysctl variablecat /proc/sys/PATH/TO/SOME_KERNEL_FILE #显示所有的可配置的内核参数 sysctl -a #查看某个内核参数的值 sysctl net.ipv4.ip_forward #修改某个内核参数的值;-w选项就是write sysctl -w net.ipv4.ip_forward=1 #查看对应的伪文件系统的文件 cat /proc/sys/net/ipv4/ip_forward #修改主机名 sysctl -w kernel.hostname=www.abc.com #查看的三种方式 cat /proc/sys/kernel/hostname uname -n hostname (2) 文件系统命令 (cat,echo) 查看:cat /proc/sys/PATH/TO/SOME_KERNEL_FILE设定:echo \"VALUE\" > /proc/sys/PATH/TO/SOME_KERNEL_FILE #设置内核参数主机名为node1 echo \"node1\" > /proc/sys/kernel/hostname #查看 uname -n cat /proc/sys/kernel/hostname 注意:上述两种方式的设定仅当前运行内核有效; (3) 配置文件:/etc/sysctl.conf,/etc/sysctl.d/*.conf 使用配置文件永久有效使配置文件立即生效:sysctl -p [/PATH/TO/CONFIG_FILE] vim /etc/sysctl.conf 加入以下内核参数: net.ipv4.ip_forward=1 #重新加载sysctl.conf文件,-p不指定任何配置文件默认重启加载sysctl.conf文件 sysctl -p #查看 cat /proc/sys/net/ipv4/ip_forward 内核参数:kernel.hostname:主机名;net.ipv4.ip_forward:核心转发;vm.drop_cache:手动清除缓存,回收内存;net.ipv4.icmp_echo_ignore_all:忽略所有发往本主机的ping操作; #关闭ping功能 echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all cat /proc/sys/net/ipv4/icmp_echo_ignore_all /sys目录:sysfs:输出内核识别出的个硬件设备的相关属性信息,也有内核对硬件特性的可设置参数;对此些参数的修改,即可定制硬件设备工作特性; udev:通过读取/sys目录下的硬件设备信息按需为各硬件设备创建设备文件;udev是用户空间程序;专用工具:devadmin,hotplug; udev为设备创建设备文件时,会读取其事先定义好的规则文件,一般在/etc/udev/rules.d/目录下,以及/usr/lib/udev/rule.d目录下; "},"pages/35.Linux内核模块功能定制.html":{"url":"pages/35.Linux内核模块功能定制.html","title":"35.Linux内核模块功能定制","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 编译内核 内核编译过程: 过程详细说明 程序包编译安装: ./configure,make,make install 前提:开发环境(开发工具,开发库),头文件:/usr/include 开源:源代码-->可执行格式发行版:以\"通用\"的目标 编译内核 前提:(1) 准备好开发环境;(2) 获取目标主机上硬件设备的相关信息;(3) 获取到目标主机系统功能的相关信息,例如要启用的文件系统;(4) 获取内核源代码包:www.kernel.org; 准备开发环境:CentOS 6,7:包组:Development ToolsServer Platform Development #查看包组 yum group list #安装开发工具包组 yum groupinstall \"开发工具\" -y #确保ncurses.x86_64包已安装 yum list all *ncurses 获取目标主机上硬件设备相关信息: CPU: #查看cpu信息 cat /proc/cpuinfo lscpu #安装x86info yum -y install x86info #查看所有cpu相关的详细信息 x86info -a PCI设备: #查看PCI设备信息 lspci #查看每个PCI设备的详细信息 lspci -v #查看每个PCI设备的更详细信息 lspci -vv #查看usb设备信息 lsusb #查看usb设备详细信息 lsusb -v #查看硬盘信息 lsblk 内核编译过程: 步骤:tar -xf linux-3.16.71.tar.xz -C /usr/srccd /usr/srcln -sv linux-3.16.71 linuxcd linux make menuconfig 配置内核选项make [-j #] 编译内核,可使用-j指定编译线程数量make modules_install 安装内核模块make install 安装内核 重启系统,选择使用新内核; screen命令:在终端模拟器上打开屏幕(在screen中执行的所有操作,不会因为你的ssh连接断开而终止)打开screen:screen拆除screen:Ctrl+a松开键盘,直接按d列出screen:screen -ls连接screen:screen -r SCREEN_ID关闭screen:在screen内部输入exit #安装 yum install -y screen #打开screen,Ctrl+a松开键盘,直接按d,拆除 screen #列出screen screen -ls #连接id为82650的screen screen -r 82650 #rz上传linux-3.16.71.tar.xz内核包 tar -xf linux-3.16.71.tar.xz -C /usr/src #切换目录 cd /usr/src #创建符号链接 ln -sv linux-3.16.71 linux #进入解压目录 cd linux #安装ncurses-devel yum install -y ncurses-devel #参照当前系统内核的模块配置 cp /boot/config-3.10.0-957.12.1.el7.x86_64 .config #会打开一个文本菜单界面,可以选择哪些模块编译进内核等操作 make menuconfig #打开screen screen #指定4个线程,启动编译 make -j 4 #安装内核模块 make modules_install #安装内核 make install #重启系统,选择使用新内核; 过程详细说明 (1) 配置内核选项支持\"更新\"模式进行配置:在已有的.config文件的基础之上进行\"修改\"配置;(a) make config:基于命令行以遍历的方式去配置内核中可配置的每个选项;(b) make menuconfig:基于cureses的文本配置窗口;(c) make gconfig:基于GTK开发环境的窗口界面;包组:\"桌面平台开发\"(d) make xonfig:基于QT开发环境的窗口界面;支持\"全新配置\"模式进行配置:(a) make defconfig:基于内核为目标平台提供的\"默认\"配置为模板进行配置;(b) make allnoconfig:所有选项均为\"no\"; (2) 编译(a) 多线程编译:make [-j #](b) 编译内核中的一部分代码:　　(i) 只编译某子目录中的相关代码:　　cd /usr/src/linux　　make path/to/dir/ 　　(ii) 只编译一个特定的模块　　cd /usr/src/linux　　make path/to/dir/file.ko (c) 如何交叉编译:目标平台与当前编译操作所在的平台不同; make ARCH=arch_name 要获取特定目标平台的使用帮助:make ARCH=arch_name help (3) 如何在执行过编译操作的内核源码树上做重新编译:事先清理操作:make clean:清理编译生成的绝对多数文件,但会保留config,及编译外部模块所需要的文件;make mrproper:清理编译生成的所有文件,包括配置生成的config文件及某些备份文件;make distclean:相当于mrproper,额外清理各种patches以及编辑器备份文件; 　　 "},"pages/36.Linux自动化安装anaconda配置定制.html":{"url":"pages/36.Linux自动化安装anaconda配置定制.html","title":"36.Linux自动化安装anaconda配置定制","keywords":"","body":"CentOS系统安装: 安装程序:anaconda bootloader --> kernel(initrd(rootfs)) --> anaconda anaconda:tui:基于cureses的文本配置窗口gui:图形界面 CentOS的安装过程启动流程:MBR:boot.catStage2:isolinux/isolinux.cfg配置文件:isolinux/isolinux.cfg 每个对应的菜单选项:加载内核:isolinux/vmlinuz向内核传递参数:append initrd=initrd.img 装载根文件系统,并启动anaconda默认界面是图形界面:512MB+内存空间;若需要显示指定启动TUI接口:向启动内核传递一个参数\"text\"即可; ESCboot:linux text 注意:上述内容一般位于引导设备,例如可通过光盘、U盘或网络等;后续的anacona及其安装用到的程序包等可以来自于程序包仓库,此仓库的位置可以为:本地光盘本地硬盘ftp serverhttp servernfs server 如果想手动指定安装仓库:ESCboot:linux method anaconda的工作过程:安装前配置阶段:安装过程使用的语言键盘类型安装目标存储设备:Basic Storage:本地磁盘、Special Storage:ISCSI设定主机名配置网络接口时区管理员密码设定分区方式及MBR的安装位置创建一个普通用户选定要安装的程序包 安装阶段:在目标磁盘创建分区并执行格式化;将选定的程序包安装至目标位置;安装bootloader; 首次启动:iptablesselinuxcore dump(核心转储) anaconda的配置方式:(1) 交互式配置方式;(2) 支持通过读取配置文件中事先定义好的配置项自动完成配置;遵循特定的语法格式,此文件即为kickstart文件; 安装引导选项:boot:　　text:文本安装方式　　method:手动指定使用的安装方法　　与网络相关的引导选项:　　　　ip=IPADDRESS　　　　netmask=MASK　　　　gateway=GW　　　　dns=DNS_SERVER_IP　　远程访问功能相关的引导选项:　　　　vnc　　　　vncpassword='PASSWORD'　　启动紧急救援模式:　　　　rescue　　装载额外驱动　　　　dd(driver disk) "},"pages/37.Linux系统自动化安装无人值守环境配置部署.html":{"url":"pages/37.Linux系统自动化安装无人值守环境配置部署.html","title":"37.Linux系统自动化安装无人值守环境配置部署","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 安装引导选项: kickstart文件的格式 命令段中的必备命令 补充:分区相关的其它指令 可选命令: 系统安装完成之后禁用防火墙: 系统安装完成后禁用SELinux 定制kickstart文件: 根据kickstart文件安装系统 CentOS系统安装: CentOS 6.8 x86_64:minimal install 安装时按ESC键,设置网络引导选项: 分区: 安装引导选项: ks:指明kickstart文件的位置;ks=DVD drive:ks=cdrom:/PATH/TO/KICKSTART_FILEHard drive:ks=hd:/DEVICE/PATH/TO/KICKSTART_FILEHTTP Server:ks=http://HOST[:PORT]/PATH/TO/KICKSTART_FILEFTP Server:ks=ftp://HOST[:PORT]/PATH/TO/KICKSTART_FILEHTTPS Server:ks=https://HOST[:PORT]/PATH/TO/KICKSTART_FILE kickstart文件的格式 命令段:指定各种安装前配置选项,如键盘类型等;必备命令可选命令 程序包段:指明要安装程序包,以及包组,也包括不安装的程序包;%packages 程序包开始@group_name 要安装的程序包组package 要安装的程序包-package 不安装的程序包%end 程序包结束脚本段%pre:安装前脚本(安装前的命令非常有限,因为是运行在内存中的小系统提供的)运行环境:运行安装介质上的微型Linux系统环境; %post:安装后脚本运行环境:安装完成的系统; 命令段中的必备命令 authconfig:认证方式配置authconfig --enableshadow --passalgo=sha512 bootloader:定义bootloader的安装位置及相关配置bootloader --location=mbr --driveorder=sda --append=\"crashkernel=auto rhgb quiet\" keyboard:设置键盘类型keyboard us lang:语言类型lang zh_CN.UTF-8 part:分区布局part /boot --fstype=ext4 --size=500part pv.008002 --size=50000 pv代表物理卷,008002代表卷号 rootpw:管理员密码rootpw --iscrypted $6$1jPjchbF9ylkguG4$oCsx23WRO916/WoZCGgAmkHGzRrOdvq441CR1KSgqNVqZhU9gAaTOhmSw5IZ4W.M6HynqLXhtp.O3oV6QI2xn. 生成加密密码的方式: #-1:代表使用md5加密,指定盐为随机4个字节16进制,也就是8位盐 openssl passwd -1 -salt `openssl rand -hex 4` timezone:指定时区timezone --utc Asia/Shanghai 补充:分区相关的其它指令 clearpart --none --drives=sda 清空指定磁盘上的所有分区volgroup lv_vg --pesize=4096 pv.008002 创建卷组,卷组名:lv_vg,--pesize=4096:pe大小4096,pv.008002:物理卷号logvol /home --fstype=ext4 --name=lv_home --vgname=lv_vg --size=9996 创建逻辑卷 可选命令: install:安装install OR upgrade:安装或升级 text:安装界面类型,text为tui,默认为GUI network:配置网络接口network --onboot yes --device eth0 --bootproto dhcp --noipv6--onboot no:操作系统开机时是否自动启动网络接口,[yes|no] firewall:防火墙firewall --service=ssh--service=ssh:代表防火墙启用了,但这个防火墙放行了对本机ssh的访问如果要禁用防火墙,可以这样配置:firewall --disabled selinux:SELinux,安全加强的linux,基于内核的安全访问加固策略库selinux --enforcing禁用可以这样配置:selinux --disabled halt、poweroff或reboot:安装完成之后的行为(关机或重启); repo:指明安装时使用的repository:repo --name=\"CentOS\" --baseurl=cdrom:sr0 --cost=100 这里指定为光盘,cost开销默认为1000,这里指定100表示优先使用; url:指明安装时使用的repository,但为url格式;(配置该项网卡要在启动的时候配置好)url --url=http://172.16.0.1/cobbler/ks_mirror/CentOS-6.7-x86_64/ 系统安装完成之后禁用防火墙: CentOS 6: #禁用防火墙 service iptables stop #以后不再自启动防火墙 chkconfig iptables off CentOS 7: #禁用防火墙 systemctl stop firewalld.service ##以后不再自启动防火墙 systemctl disable firewalld.service 系统安装完成后禁用SELinux 编辑配置文件:/etc/selinux/config或链接文件/etc/sysconfig/selinux只需编辑:vim /etc/sysconfig/selinux,修改SELINUX=disabled: # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=disabled # SELINUXTYPE= can take one of three two values: # targeted - Targeted processes are protected, # minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection. SELINUXTYPE=targeted 注:以上修改需要重启才有效,需要永久有效,需要setenforce 0,使修改立即生效: #SELinux修改立即生效 setenforce 0 #查看SELinux状态,只要结果是Permissive就可以,重启以后会改为Disabled getenforce 定制kickstart文件: windows上需要先安装xmanager,然后xshell设置如下: #安装 yum install system-config-kickstart #让它在后台运行图形化配置界面 system-config-kickstart & 打开图形化界面后,文件-->打开文件,打开root目录下的,anaconda-ks.cfg文件,基于该文件的配置修改: 最后保存文件名为ks.cfg到/root目录下: #检查kickstart文件语法错误 ksvalidator ks.cfg 根据kickstart文件安装系统 配置好虚拟机后,按ESC中输入如下内容安装: 注:这里在192.168.147.157虚拟机上安装httpd服务,在其/var/www/html目录下放置了配置好的ks.cfg文件 "},"pages/38.函数编程和case语句.html":{"url":"pages/38.函数编程和case语句.html","title":"38.函数编程和case语句","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 chkconfig: - 50 50 prog=$(basename $0) 函数:function 函数返回值: 函数可以接收参数: return 5 : User exists 变量作用域: 函数递归 case语句的语法格式: case $VARIABLE inPAT1)　　分支1　　;;PAT2)　　分支2　　;;... *)　　分支n　　;;esac case支持glob风格的通配符:*:任意长度的任意字符;?:任意单个字符;[]:范围内任意单个字符;a|b:a或b; 回顾下if..elif多分支写法: #!/bin/bash cat case写法: #!/bin/bash cat 示例:写一个服务框架脚本:$lockfile,值/var/lock/subsys/SCRIPT_NAME (1) 此脚本可接受start,stop,restart,status四个参数之一;(2) 如果参数非此四者,则提示使用帮助后退出;(3) start,则创建lockfile,并显示启动;stop,则删除lockfile,并显示停止;restart,则先删除此文件再创建此文件,而后显示重启完成;status,如果lockfile存在,则显示running,否则,则显示stopped. #!/bin/bash # # chkconfig: - 50 50 # description: test service script # prog=$(basename $0) lockfile=/var/lock/subsys/$prog case $1 in start) if [ -f $lockfile ];then echo \"$prog is running yet.\" else touch $lockfile [ $? -eq 0 ] && echo \"start $prog finish.\" fi ;; stop) if [ -f $lockfile ];then rm -f $lockfile [ $? -eq 0 ] && echo \"stop $prog finished.\" else echo \"$prog is not running.\" fi ;; restart) if [ -f $lockfile ];then rm -f $lockfile touch $lockfile echo \"restart $prog finished.\" else touch $lockfile echo \"start $prog finished.\" fi ;; status) if [ -f $lockfile ];then echo \"$prog is running.\" else echo \"$prog is finished.\" fi ;; *) echo \"Usage:$prog {start|stop|restart|status}\" exit 1 ;; esac 使用如下: cp testservice /etc/init.d/ chmod +x testservice chkconfig --add testservice chkconfig --list testservice service testservice start 函数:function 过程式编程:代码重用模块化编程结构化编程 把一段独立功能的代码当做一个整体,并为之取一个名字;命名的代码段;此即为函数;注意:定义函数的代码段不会自动执行,在调用时执行;所谓调用函数,在代码中给定函数名即可;函数名出现的任何位置,在代码执行时,都会被自动替换为函数代码; 语法一:function f_name{　　　...函数体...} 语法二:f_name(){　　　...函数体...} 函数的生命周期:每次被调用时创建,返回时终止;其状态返回结果为函数体中运行的最后一条命令的状态结果;自定义状态返回值,需要使用:returnreturn [0-255]0:成功1-255:失败 示例:给定一个用户名,取得用户的id号和默认shell #!/bin/bash userinfo(){ if id $username &> /dev/null;then grep \"^$username\\>\" /etc/passwd | cut -d: -f3,7 else echo \"No such user.\" fi } username=$1 userinfo username=$2 userinfo 调用: bash -x f1.sh root bk 函数返回值: 函数的执行结果返回值:(1) 使用echo或printf命令进行输出;(2) 函数体中调用的命令的执行结果;函数的退出状态码:(1) 默认取决于函数体中执行的最后一条命令的退出状态码;(2) 自定义:return 函数可以接收参数: 传递参数给函数:在函数体中,可以使用$1,$2,...引用传递给函数的参数;还可以函数中使用$*或$@引用所有参数,$#引用传递的参数的个数;在调用函数时,在函数名后面以空白符分隔给定参数列表即可,例如:testfunc arg1 arg2 arg3... 示例:添加10个用户添加用户的功能使用函数实现,用户名作为参数传递给函数; #!/bin/bash # # return 5 : User exists adduser(){ if id $1 &> /dev/null;then return 5 else useradd $1 retval=$? return $? fi } for i in {1..10};do adduser ${1}${i} retval=$? if [ $retval -eq 0 ];then echo \"Add User ${1}${i} finished.\" elif [ $retval -eq 5 ];then echo \"User ${1}${i} exists.\" else echo \"Unkown Error.\" fi done 练习1.写一个脚本,使用函数实现ping一个主机来测试主机的在线状态;主机地址通过参数传递给函数;主程序:测试172.16.1.1-172.16.67.1范围内各主机的在线状态 2.写一个脚本,打印NN乘法表; 变量作用域: 局部变量:作用域是函数的生命周期;在函数结束时被自动销毁;定于局部变量的方法:local VARIABLE=VALUE 本地变量:作用域是运行脚本的shell进程的生命周期;因此，其作用范围为当前shell脚本程序文件; #!/bin/bash name=tom setname(){ #默认会对本地变量name赋值 name=jerry echo \"Function:$name\" } setname echo \"Shell:$name\" 运行结果都为jerry,调用了setname函数后,函数内将本地变量name,重新赋值,所以无论Function还是Shell都输出jerry如果需要明确setname函数里的name是局部变量,需要为变量加上关键字local #!/bin/bash name=tom setname(){ #local关键字,指定该name为局部变量 local name=jerry echo \"Function:$name\" } setname echo \"Shell:$name\" 函数递归 函数直接或间接调用自身; 10!=109!=1098!=10987!=... #!/bin/bash val=3 factorial(){ if [ $1 -eq 0 -o $1 -eq 1 ];then echo 1 else echo $[ $1*$(factorial $[$1-1]) ] fi } factorial $val 斐波那契额数列: #!/bin/bash fab(){ if [ $1 -eq 1 ];then echo 1 elif [ $1 -eq 2 ];then echo 1 else echo $[$(fab $[$1-1])+$(fab $[$1-2])] fi } for i in $(seq 1 $1);do fab $i done "},"pages/39.systemd及systemctl实战.html":{"url":"pages/39.systemd及systemctl实战.html","title":"39.systemd及systemctl实战","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Systemd的新特性: 核心概念:unit unit的常见类型: 关键特性: 不兼容: 管理系统服务: systemctl命令: service unit file: 管理target units: 其他常用命令: systemd: POST --> Boot Sequence --> Bootloader(MBR) --> Kernel(ramdisk) --> rootfs --> /sbin/initInit:CentOS 5:SysV initCentOS 6:UpstartCentOS 7:Systemd Systemd的新特性: 系统引导时实现服务并行启动;按需激活进程;系统状态快照;基于依赖关系定义服务控制逻辑; 核心概念:unit unit由其相关配置文件进行标识、识别和配置;文件中主要包含了系统服务、监听的socket、保存的快照以及其它与init相关的信息;这些配置文件主要保存在:/usr/lib/systemd/system/run/systemd/system/etc/systemd/system unit的常见类型: Service unit:文件扩展名为.service,用于定义系统服务;Target unit:文件扩展名为.target,用于模拟实现\"运行级别\";Device unit:文件扩展名为.device,用于定义内核识别的设备;Mount unit:文件扩展名为.mount,定义文件系统挂载点;Socket unit:文件扩展名为.socket,用于标识进程间通信用到的socket文件;Snapshot unit:文件扩展名为.snapshot,管理系统快照;Swap unit:文件扩展名为.swap,用于标识swap设备;Automount unit:文件扩展名为.automount,文件系统自动挂载点设置;Path unit:文件扩展名为.path,用于定义文件系统中的一个文件或目录; 关键特性: 基于socket的激活机制:socket与程序分离;基于bus(总线)的激活机制;基于device的激活机制;基于Path的激活机制;系统快照:保存各unit的当前状态信息于持久存储设备中;向后兼容sysv init脚本;/etc/init.d 不兼容: systemctl的命令是固定不变的;非由systemd启动的服务,systemctl无法与之通信; 管理系统服务: CentOS 7:service类型的unit文件; systemctl命令: Control the systemd system and service manager systemctl [OPTIONS...] COMMAND [NAME...] 启动:service NAME start ==> systemctl start NAME.service停止:service NAME stop ==> systemctl stop NAME.service重启:service NAME restart ==> systemctl restart NAME.service状态:service NAME status ==> systemctl status NAME.service条件式重启:service NAME condrestart ==> systemctl try-restart NAME.service重载或重启服务:systemctl reload-or-restart NAME.service注:重载代表重新读取配置文件而不用重启服务;重载或重启服务代表如果支持重载就重载,不支持就重启重载或条件式重启服务:systemctl reload-or-try-restart NAME.service 查看某服务当前激活与否的状态:systemctl is-active NAME.service查看所有已激活的服务:systemctl list-units -t service查看所有服务(已激活及未激活):chkconfig --list ==> systemctl list-units --all --t service 设置服务开机自启:chkconfig NAME on ==> systemctl enable NAME.service禁止服务开机自启:chkconfig NAME off ==> systemctl disable NAME.service查看某服务是否能开机自启:chkconfig --list NAME ==> systemctl is-enabled NAME.service 禁止某服务设定为开启自启:systemctl mask NAME.service取消此禁止:systemctl unmask NAME.service 查看服务的依赖关系:systemctl list-dependencies NAME.service #查看所有已激活的服务 systemctl list-units --t service #查看所有服务(已激活及未激活) systemctl list-units --all --t service #查看某服务是否能开机自启 systemctl is-enabled nginx #查看服务的依赖关系 systemctl list-dependencies nginx service unit file: service unit文件/usr/lib/systemd/system/nginx.service如下: [Unit] Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/ After=network-online.target remote-fs.target nss-lookup.target Wants=network-online.target [Service] Type=forking PIDFile=/var/run/nginx.pid ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s TERM $MAINPID [Install] WantedBy=multi-user.target 文件通常由三部分组成: [Install]:定义由\"systemctl enable\"以及\"systemctl disable\"命令在实现服务启用或禁用时用到的一些选项; Unit段的常用选项:Description:描述信息;意义性描述;After:定义unit的启动次序;表示当前unit应该晚于哪些unit启动;其功能与Before相反;Requies:依赖到的其它units;(强依赖.被依赖的units无法激活时,当前units即无法激活);Wants:依赖到的其它units;(弱依赖);Conflicts:定义units间的冲突关系; Service段的常用选项:Type(了解即可):用于定义影响ExecStart及相关参数的功能的unit进程启动类型;类型:simple:代表ExecStart指定的程序为该服务的主进程forking:代表ExecStart指定的程序所启动的进程,生成的一个子进程为该服务的主进程oneshot:指启动一次,在启动后续的unit之前,主进程将会退出dbus:后续的units仅在主进程得到dbus名称之后,才能启动notify:类似于simple,后续的units仅在通过sdnotify函数发送通知以后,才能启动idle:类似于simple,..... EnvironmentFile:环境配置文件;ExecStart:指明启动unit要运行命令或脚本;ExecStartPre,ExecStartPostExecStop:指明停止unit要运行的命令或脚本;Restart:如果进程意外终止了,它会自动重启; Install段的常用选项:Alias:当前unit的别名;RequiredBy:被哪些units所依赖(强依赖);WantedBy:被哪些units所依赖(弱依赖); 注意:对于新创建的unit文件或修改了的unit文件,要通知systemd重载此配置文件;systemctl daemon-reload 管理target units: 运行级别:0 ==> runlevel0.target,poweroff.target1 ==> runlevel1.target,rescue.target2 ==> runlevel2.target,multi-user.target3 ==> runlevel3.target,multi-user.target4 ==> runlevel4.target,multi-user.target5 ==> runlevel5.target,graphical.target6 ==> runlevel6.target,reboot.target 级别切换:init N ==> systemctl isolate NAME.target 查看级别:runlevel ==> systemctl list-units -t target查看所有级别:systemctl list-units -t target -a 获取默认运行级别:systemctl get-default修改默认运行级别:systemctl set-default NAME.target #查看激活的target unit systemctl list-units -t target #查看所有的target unit systemctl list-units -t target --all #设置默认运行级别 systemctl set-default runlevel3 #级别切换 systemctl isolate runlevel3.target 切换至紧急救援模式(运行级别1):systemctl rescue切换至emergency模式:systemctl emergency 其他常用命令: 关机:systemctl halt,systemctl poweroff重启:systemctl reboot挂起:systemctl suspend快照:systemctl hibernate快照并挂起:systemctl hybrid-sleep "},"pages/40.SELinux简介.html":{"url":"pages/40.SELinux简介.html","title":"40.SELinux简介","keywords":"","body":"SELinux SELinux:Secure Enhanced Linux,工作于Linux内核中 DAC:discretionary access control,自主访问控制MAC:Mandatory access control,强制访问控制 SELinux有两种工作级别:strict:每个进程都受到selinux的控制;targeted:仅有限个进程受到selinux的控制;(只监控容易被入侵的进程) sandbox:沙盒 subject operation object subject:进程object:进程,文件文件:open,read,write,close,chown,chmod subject:domainobject:type 编辑配置文件,修改SELINUX=enforcing,然后重启init 6或rebootvim /etc/sysconfig/selinux: # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=enforcing # SELINUXTYPE= can take one of three two values: # targeted - Targeted processes are protected, # minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection. SELINUXTYPE=targeted SELinux的状态:enforcing:强制,每个受限的进程都必然受限;permissive:启用,每个受限的进程违规操作不会被禁止,但会被记录于审计日志;disabled:关闭; 相关命令:getenforce:获取selinux当前状态;setenforce 0|10:设置为permissive1:设置为enforcing 此设定:重启系统后无效; 配置文件(永久生效): /etc/sysconfig/selinux, /etc/selinux/configSELINUX={disabled|enforcing|permissive} #查看SELinux处于的状态 getenforce #关闭SELinux setenforce 0 #再次查看状态为Permissive getenforce SELinux为每个文件提供了安全标签,也为进程提供了安全标签:user:role:typeuser:SELinux的user;(与linux系统的user无关)role:角色;type:类型; #显示SELinux安全上下文标签 ls -Z /etc #进程中多了LABEL字段为SELinux安全上下文标签 ps auxZ SELinux规则库:规则:哪种域能访问哪种或哪些种类型内的文件; 配置SELinux:SELinux是否启用;给文件重新打SELinux安全上下文标签;设定某些布尔型特性(bool型开关); #显示当前系统很多应用程序的bool型开关 getsebool -a 给文件重新打标:chcon - change file SELinux security context chcon [OPTION]... CONTEXT FILE...chcon [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...chcon [OPTION]... --reference=RFILE FILE... -R:递归打SELinux安全上下文标签; 还原文件的默认标签:restorecon [-R] /path/to/somewhere cd /tmp ll -Z #安装httpd yum install -y httpd #启动httpd服务 systemctl start httpd.service #查看httpd,80端口是否侦听 ss -tnl #切换到默认存放html的目录 cd /var/www/html/ #编辑一个html页面 vim index.html #查看SELinux安全上下文标签type是httpd_sys_content_t ll -Z index.html #查看httpd进程的SELinux安全上下文标签type是httpd_t,httpd_sys_content_t是httpd_t的子类型,所以可以访问 #访问虚拟机地址:http://192.168.18.146/index.html能够正常访问 ps auxZ | grep \"httpd\" #复制一份 cp index.html test.html #我们把SELlinux的type改成admin_home_t chcon -t admin_home_t test.html #查看修改后的SELinux安全上下文标签 l -Z test.html #访问虚拟机地址:http://192.168.18.146/test.html提示没有权限,因为admin_home_t并不允许被httpd_t域所访问 #还原文件的默认标签 restorecon test.html #查看已经还原到原来的标签了 ll -Z test.html 布尔型规则:getseboolsetsebool getsebool命令:getsebool [-a] [boolean] setsebool命令:setsebool [-P] boolean value | bool1=val1 bool2=val2 ... #查看所有 getsebool -a #查看某一个bool规则 getsebool abrt_anon_write #设置开启,{on|off|1|0},on和1代表开启,off和0代表关闭 setsebool abrt_anon_write 1 #查看 getsebool abrt_anon_write #以上修改不会永久有效,要想永久有效需要加上-P选项,表示保存在策略库当中 setsebool -P abrt_anon_write on "},"pages/41.shell数组和字符串处理工具.html":{"url":"pages/41.shell数组和字符串处理工具.html","title":"41.shell数组和字符串处理工具","keywords":"","body":"数组 存储多个元素的连续的内存空间;数组名:整个数组只有一个名字;数组索引:编号从0开始;数组名[索引]${ARRAY_NAME[INDEX]} 注意:bash-4及之后的版本,支持自定义索引格式,而不仅仅是0,1,2,...数字格式;此类数组称之为\"关联数组\" #查看bash的版本 rpm -q bash 声明数组:declare -a NAME:声明索引属组;declare -A NAME:声明关联属组; 数组中元素的赋值方式:(1) 一次只赋值一个元素;ARRAY_NAME[index]=value(2) 一次赋值全部元素;ARRAY_NAME=(\"VAL1\" \"VAL2\" \"VAL3\" ...)(3) 只赋值特定元素(稀疏格式的属组);ARRAY_NAME=([0]=\"VAL1\" [3]=\"VAL4\" ...)注意:bash支持稀疏格式的数组;(4) read -a ARRAY_NAME-a:后跟一个变量,该变量会被认为是个数组,然后给其赋值,默认是以空格为分割符 引用数组中的元素:${ARRAY_NAME[INDEX]}注意:引用时,只给数组名,表示引用下标为0的元素; 数组的长度(数组中元素的个数):${#ARRAY_NAME[*]} echo ${#jianghu[*]} echo ${#jianghu[@]} 示例:生成10个随机数,并找出其中的最大值和最小值; declare -a rand max=0 for i in $(seq 1 10);do rand[$i]=$RANDOM [ ${rand[$i]} -gt $max ] && max=${rand[$i]} echo ${rand[$i]} done echo \"Max:$max\" 练习:1.生成10个随机数,而后由小到大进行排序; 2.写一个脚本定义一个数组,数组中的元素是/var/log目录下所有以.log结尾的文件;统计其下标为偶数的文件中的行数之和;files=(/var/log/*.log)会解析为数组,每个文件以空格分隔; #!/bin/bash declare -a files files=(/var/log/*.log) lines=0 for i in $(seq 0 $[${#files[*]}-1]);do if [ $[$i % 2] -eq 0 ];then let lines+=$(wc -l ${files[$i]} | cut -d' ' -f1) fi done echo \"lines:${lines}\" 引用数组中的所有元素:${ARRAY_NAME[*]}${ARRAY_NAME[@]} echo ${jianghu[*]} echo ${jianghu[@]} 数组元素切片:${ARRAY_NAME[*]:offset:number}offset:偏移量(指定数组下标);number:要取出的元素个数;省略number时,表示取偏移量之后的所有元素; files=(/etc/[Pp]*) #从数组下标2开始取3个元素 echo ${files[*]:2:3} #从数组下标5开始取之后所有元素 echo ${files[*]:5} 向非稀疏格式数组中追加元素:ARRAY_NAME[${#ARRAY_NAME[*]}]=VALUE 删除数组中的某元素:unset ARRAY[INDEX]注意:撤销元素不是引用属组中的值,所以这里不需要加${} 关联数组:必须先声明数组:declare -A ARRAY_NAMEARRAY_NAME=([index_name1]=\"value1\" [index_name2]=\"value2\") bash的内置字符串处理工具 字符串切片:${var:offset:number}取字符串的子串;取字符串最右侧的几个字符:${var: -length};注意:冒号后必须有一个空白字符; name=Jerry #截取索引从2开始后所有字符 echo ${name:2} #截取索引从2开始后2位的字符 echo ${name:2:2} #从右侧向前取4个字符,正向截取从索引0开始,反向从索引-1开始,最后一个字符为-1 echo ${name: -4} 基于模式取子串:${var#*word}:其中word是指定的分隔符;功能:自左而右,查找var变量所存储的字符串中,第一次出现的word分隔符,删除字符串开头至此分隔符之间的所有字符;${var##*word}:其中word是指定的分隔符;功能:自左而右,查找var变量所存储的字符串中,最后一次出现的word分隔符,删除字符串开头至此分隔符之间的所有字符; mypath=\"/etc/init.d/functions\" echo ${mypath#*/} echo ${mypath##*/} ${var%word*}:其中word是指定的分隔符;功能:自右而左,查找var变量所存储的字符串中,第一次出现的word分隔符,删除此分隔符至字符串尾部之间的所有字符;${var%%word*}:其中word是指定的分隔符;功能:自右而左,查找var变量所存储的字符串中,最后一次出现的word分隔符,删除此分隔符至字符串尾部之间的所有字符; mypath=\"/etc/init.d/functions\" echo ${mypath%/*} mypath=\"etc/init.d/functions\" echo ${mypath%%/*} url=http://www.baidu.co,:80 #取端口号 echo ${url##*:} #取协议 echo ${url%%:*} 查找替换:${var/PATTERN/SUBSTI}:查找var所表示的字符串中,第一次被PATTERN所匹配到的字符串,将其替换为SUBSTI所表示的字符串;${var//PATTERN/SUBSTI}:查找var所表示的字符串中,所有被PATTERN所匹配到的字符串,并将其全部替换为SUBSTI所表示的字符串; ${var/#PATTERN/SUBSTI}:查找var所表示的字符串中,行首被PATTERN所匹配到的字符串,将其替换为SUBSTI所表示的字符串;${var/%PATTERN/SUBSTI}:查找var所表示的字符串中,行尾被PATTERN所匹配到的字符串,将其替换为SUBSTI所表示的字符串; 注意:这里的PATTERN只能使用GLOB风格的通配符 userinfo=\"root:x:0:0:root admin:/root:/bin/chroot\" echo ${userinfo/r??t/ROOT} echo ${userinfo//r??t/ROOT} echo ${userinfo/#r??t/ROOT} echo ${userinfo/%r??t/ROOT} 查找删除:${var/PATTERN}:以PATTERN为模式查找var字符串中第一次的匹配,并删除之;${var//PATTERN}:以PATTERN为模式查找var字符串中,所有被PATTERN所匹配的字符串,并删除之;${var/#PATTERN}:以PATTERN为模式查找var字符串中,行首被PATTERN所匹配到的字符串,并删除之;${var/%PATTERN}:以PATTERN为模式查找var字符串中,行尾被PATTERN所匹配到的字符串,并删除之; 字符串大小写转换:${var^^}:把var中的所有小写字符转换为大写;${var,,}:把var中的所有大写字符转换为小写; url=http://www.baidu.com:80 echo ${url^^} myurl=${url^^} echo ${url,,} 变量赋值:${var:-VALUE}:如果var变量为空,或未设置,那么返回VALUE;否则,则返回var变量的值;${var:=VALUE}:如果var变量为空,或未设置,那么返回VALUE,并将VALUE赋值给var变量;否则,则返回var变量的值;${var:+VALUE}:如果var变量不空,则返回VALUE;${var:?ERROR_INFO}:如果var为空,或未设置,那么返回ERROR_INFO为错误提示;否则,返回var值; 练习:写一个脚本,完成如下功能(1) 提示用户输入一个可执行命令的名称;(2) 获取此命令所依赖到的所有库文件列表;(3) 复制命令至某目标目录(例如/mnt/sysroot,即把此目录当作根)下的对应的路径中bash,/bin/bash ==> /mnt/sysroot/bin/bashuseradd,/usr/sbin/useradd ==> /mnt/sysroot/usr/sbin/useradd #查找可执行命令所在的目录 whereis ls whereis useradd #显示依赖库文件的目录 ldd /bin/ls ldd /usr/sbin/useradd (4) 复制此命令依赖到的所有库文件至目标目录下的对应路径下:/lib64/ld-linux-x8664.so.2 ==> /mnt/sysroot/lib64/ld-linux-x8664.so.2 进一步:每次复制完成一个命令后,不要退出,而是提示用户继续输入要复制的其它命令,并重复完成如上所描述的功能;直到用户输入\"quit\"退出脚本; "},"pages/42.shell信号捕捉实战.html":{"url":"pages/42.shell信号捕捉实战.html","title":"42.shell信号捕捉实战","keywords":"","body":"写一个脚本:ping命令去查看172.16.1.1-172.16.67.1范围内的所有主机是否在线;在线的显示为up,不在线的显示为down,分别统计在线主机,及不在线主机; #!/bin/bash declare -i uphosts=0 declare -i downhosts=0 for i in $(seq 140 160);do if ping -W 1 -c 1 192.168.147.$i &> /dev/null;then echo \"192.168.147.$i is up\" let uphosts+=1 else echo \"192.168.147.$i is down\" let downhosts+=1 fi done echo \"uphosts:${uphosts},downhosts:${downhosts}\" 用函数实现: #!/bin/bash declare -i uphosts=0 declare -i downhosts=0 declare -i i=140 hostping(){ if ping -W 1 -c 1 $1 &> /dev/null;then echo \"$1 is up\" let uphosts+=1 else echo \"$1 is down\" let downhosts+=1 fi } while [ $i -le 160 ];do hostping 192.168.147.$i let i++ done echo \"uphosts:${uphosts},downhosts:${downhosts}\" 把统计在线和不在线的功能交给函数外来实现: #!/bin/bash declare -i uphosts=0 declare -i downhosts=0 declare -i i=140 hostping(){ if ping -W 1 -c 1 $1 &> /dev/null;then echo \"$1 is up\" return 0 else echo \"$1 is down\" return 1 fi } while [ $i -le 160 ];do hostping 192.168.147.$i [ $? -eq 0 ] && let uphosts++ || let downhosts++ let i++ done echo \"uphosts:${uphosts},downhosts:${downhosts}\" 写一个脚本,实现:能探测C类、B类或A类网络中的所有主机是否在线; #!/bin/bash cping(){ local i=1 while [ $i -le 5 ];do if ping -W 1 -c 1 $1.$i &> /dev/null;then echo \"$1.$i is up\" else echo \"$1.$i is down\" fi let i++ done; } bping(){ local j=0 while [ $j -le 5 ];do cping $1.$j let j++ done; } aping(){ local x=0 while [ $x -le 5 ];do bping $1.$x let x++ done; } aping 10 信号捕捉 列出信号:trap -lkill -l每个信号作用的帮助:man 7 signal trap 'COMMAND' SIGNALS 常可以进行捕捉的信号:HUP,INT #!/bin/bash trap 'echo \"Quit\"; exit 1' INT for i in {1..254};do ping -W 1 -c 1 172.16.$i.1 done trap中使用函数: #!/bin/bash declare -a hosttempfiles trap 'mytrap' INT mytrap(){ echo \"Quit\" rm -f ${hosttempfiles[*]} exit 1 } for i in {1..5};do tmpfile=$(mktemp /tmp/ping.XXXXX) if ping -W 1 -c 1 172.16.$i.1 &> /dev/null;then echo \"172.16.$i.1 up\" | tee $tmpfile else echo \"172.16.$i.1 down\" | tee $tmpfile fi hosttempfiles[${#hosttempfiles[*]}]=$tmpfile done rm -f ${hosttempfiles[*]} "},"pages/43.awk使用与实践.html":{"url":"pages/43.awk使用与实践.html","title":"43.awk使用与实践","keywords":"","body":"GNU awk: 报告生成器,格式化文本输出;遍历文件中符合条件的每一行;并且逐行进行处理或者显示; GNU awk,gawkgawk - pattern scanning and processing language基本用法:gawk [options] 'program' FILE ...program:PATTERN{ACTION STATMENTS}语句之间用分隔分隔print,printf 选项:-F:指明输入时用到的字段分隔符;-v var=value:自定义变量; 1、printprint item1,item2, ... 要点:(1) 逗号分隔符;(2) 输出的各item可以是字符串,数值;当前记录的字段、变量或awk的表达式;(3) 如省略item,相当于print $0; #使用awk显示fstab配置的第二个字段和第四个字段的结果,awk不指明分隔符默认以空格为分隔符; tail -3 /etc/fstab | awk '{print $2,$4}' #在两个item,$2,$4之前加上hello tail -3 /etc/fstab | awk '{print \"hello\",$2,$4}' #在两个item,$2,$4之前加上hello,之后加上数字6 tail -3 /etc/fstab | awk '{print \"hello\",$2,$4,6}' #print之后没有item,代表打印$0,整行内容 tail -3 /etc/fstab | awk '{print}' #指明输入时用到的字段分隔符:号 awk -F: '{print $1}' /etc/passwd 2、变量2.1 内建变量FS:input field seperator,默认为空白字符;OFS:output field seperator,默认为空白字符;RS:input record seperator,输入时的换行符;ORS:output record sperator,输出时的换行符; NF:number of field,字段数量;{print NF},{print $NF}NR:number of record:行数;FNR:个文件分别计数;行数; FILENAME:当前文件名; ARGC:命令行参数的个数;ARGV:数组,保存的是命令行所给定的各参数; #指明输入时所用的分隔符为:号,然后取第一个字段 awk -v FS=':' '{print $1}' /etc/passwd #指明输入输出时所用的分隔符为:号,这样字段输出的结果就不会以默认空格分隔了 awk -v FS=':' -v OFS=':' '{print $1,$3,$7}' /etc/passwd #将输入时的换行符改为空格,有空格的地方都会换行 awk -v RS=' ' '{print}' /etc/passwd #统计出每行有多少个字段,这里没指定分隔符,所以默认分隔符为空格;在awk中应用变量是不需要要$符的 awk '{print NF}' /etc/fstab #以下$NF并不是显示每行有多少字段,由于它是一个数值,所以用于显示字段;$NF代表引用了最后一个字段 awk '{print $NF}' /etc/fstab #对行进行计数(会显示每一行的行号) awk '{print NR}' /etc/fstab #对两个文件的行进行计数 awk '{print NR}' /etc/fstab /etc/issue #对每个文件的行单独进行计数 awk '{print FNR}' /etc/fstab /etc/issue #每行都会显示文件名;这正好符合awk遍历文件中符合条件的每一行;并且逐行进行处理或者显示;后面会讲怎么只显示一个文件名 awk '{print FILENAME}' /etc/fstab #命令行参数的个数,这里是3个 awk '{print ARGC}' /etc/fstab /etc/issue #文件有多少行会打印多少行的命令行个数,如果想只显示1个,我们可以加上模式BEGIN awk 'BEGIN{print ARGC}' /etc/fstab /etc/issue #命令行所给定的各参数 awk 'BEGIN{print ARGV[0]}' /etc/fstab /etc/issue awk 'BEGIN{print ARGV[1]}' /etc/fstab /etc/issue awk 'BEGIN{print ARGV[2]}' /etc/fstab /etc/issue 2.2 自定义变量变量名区分字符大小写; (1) -v var=value(2) 在program中直接定义变量 #此处/etc/fstab唯一作用就是行数 awk -v test='hello gawk' '{print test}' /etc/fstab #如果只是输出变量信息,可以使用BEGIN模式,然后不加指定文件 awk -v test='hello gawk' BEGIN'{print test}' #在program内部定义变量 awk 'BEGIN{test=\"hello gawk\";print test}' 3、printf命令格式化输出:printf FORMAT,item1,item2, ...(1) FORMAT必须给出;(2) 不会自动换行,需要显示给出换行控制符,\\n;(3) FORMAT中需要分别为后面的每个item指定一个格式化符号; 格式符:%c:显示字符的ASCII码;%d,%i:显示十进制整数;%e,%E:科学计数法数值显示;%f:显示为浮点数;%g,%G:以科学计数法或浮点形式显示数值;%s:显示字符串;%u:无符号整数;%%:显示%自身; 修饰符:#[.#]:第一个#控制显示的宽度;第二个#表示小数点后的精度;例如:%3.1f;-:左对齐;+:表示数值的符号(数值有正、负); #这里$1以字符串格式输出,printf不会自动换行,所以都输出成一坨了 awk -F: '{printf \"%s\",$1}' /etc/passwd #加入换行符 awk -F: '{printf \"%s\\n\",$1}' /etc/passwd #为每行加上UserName: awk -F: '{printf \"UserName: %s\\n\",$1}' /etc/passwd #显示用户名和UID,UID以十进制整数格式显示 awk -F: '{printf \"UserName:%s,UID:%d\\n\",$1,$3}' /etc/passwd #用户名固定为15个字符,默认右对齐 awk -F: '{printf \"UserName:%15s,UID:%d\\n\",$1,$3}' /etc/passwd #%-15s,加上-号就为左对齐了 awk -F: '{printf \"UserName:%-15s,UID:%d\\n\",$1,$3}' /etc/passwd #%+d,会显示数值类型的正、负号 awk -F: '{printf \"UserName:%15s,UID:%+d\\n\",$1,$3}' /etc/passwd 4、操作符算数操作符:x+y,x-y,x*y,x/y,x^y,x%y-x:把正数转成负数+x:把字符串转换为数值 字符串操作符:没有符号的操作符,代表字符串连接 赋值操作符:=,+=,-=,*=,/=,%=,^=++,-- 比较操作符:>,>=, 模式匹配符:(左侧的字符串是否能被右侧所匹配)~:是否匹配!~:是否不匹配 逻辑操作符:&&、||、! 函数调用:function_name(arg1,arg2,...) 条件表达式:confition?expression1:expression2 awk -F: '{$3>1000?usertype=\"Common User\":usertype=\"System Admin or System User\";printf \"%15s,%-s\\n\",$1,usertype}' /etc/passwd 5、PATTERN(1) empty:空模式,匹配每一行;(2) /regular expression/:仅处理能够被此处的模式匹配到的行;(3) relational expression:关系表达式;结果有\"真\"有\"假\";结果为\"真\"才会被处理;真:结果为非0值,非空字符串;(4) line ranges:行范围,/pat1/,/pat2/注意:不支持直接给出数字的格式(5) BEGIN/END模式BEGIN{}:仅在开始处理文件中的文本之前执行一次;END{}:仅在文本处理完成之后执行一次; #仅处理UUID开头的行 awk '/^UUID/{print $1}' /etc/fstab #仅处理UUID开头以外的行 awk '!/^UUID/{print $1}' /etc/fstab #处理用户id大于1000的 awk -F: '$3>1000{print $1,$3}' /etc/passwd #处理bin/bash的用户 awk -F: '$NF==\"/bin/bash\"{print $1,$NF}' /etc/passwd #正则匹配bash的用户 awk -F: '/bash$/{print $1,$NF}' /etc/passwd #加上模式匹配符~,左边的字符串是否能被右边的字符串匹配.结果和以上两项一致 awk -F: '$NF~/bash$/{print $1,$NF}' /etc/passwd #从第一个root开头,到第一个games结尾的所有用户名 awk -F: '/^root/,/^games/{print $1}' /etc/passwd #处理指定2-10行的用户名 awk -F: 'NR>=2 && NR 6、常用的action(1) Expressions:算数表达式、赋值表达式、比较表达式等;(2) Control statements:if,while等;(3) Compound statements:组合语句;(4) Input statements(5) Output statements 7、控制语句if(condition) {statements}if(condition) {statements} else {statements}while(condition) {statements}do {statements} while(condition)for(expr1;expr2;expr3) {statements}breakcontinuedelete array[index]delete arrayexit{ statements } 7.1 if-else语法:if(confition) statement [else statement]使用场景:对awk取得的整行或某个字段做条件判断; #如果用户id大于1000,则显示用户名和用户编号 awk -F: '{if($3>1000)print $1,$3}' /etc/passwd #if..else结构 awk -F: '{if($3>=1000) { printf \"Common User:%s\\n\",$1 } else { printf \"root or sysuser:%s\\n\",$1 }}' /etc/passwd #处理bash的用户 awk -F: '{if($NF==\"/bin/bash\") {printf \"%s %s\\n\",$1,$NF}}' /etc/passwd #处理大于5的行数 awk '{if(NF>5){print $0}}' /etc/fstab #处理使用空间大于20%的;[%]:里面可以多个分隔符,这里只放了单个 df -h | awk -F[%] '/^\\/dev/{print $1}' | awk '{if($NF>20) print $1}' 7.2 while循环语法:while(confition) statement条件\"真\",进入循环;条件\"假\",退出循环; 使用场景:对一行内的多个字段逐一类似处理时使用;对数组中的各元素逐一处理时使用;length():获取字符个数 #取包含或不包含linux16开头的行,循环每行每个字段,获取每个字段的字符个数 awk '/^[[:space:]]*linux16/{i=1;while(i=7){print $i,length($i)};i++;}}' /etc/grub2.cfg 7.3 do...while循环语法:do statement while(condition)意义:至少执行一次循环体 7.4 for循环语法:for(exp1;exp2;exp3) statementfor(variable assignment,condition;iteration process){for-body} 特殊用法:能够遍历数组中的元素:语法:for(var in array) { for-body } awk '/^[[:space:]]*linux16/{for(i=1;i 7.5 switch语句语法:switch(expression){ case VALUE1 or /REGEXP/: statement; case VALUE2 or /REGEXP2/: statement; ...; default: statement }7.6 break和continuebreak [n]continue 7.7 next 提前结束对本行的处理而直接进入下一行; #处理用户id为偶数的行 awk -F: '{if($3%2!=0)next;print $1,$3}' /etc/passwd 8、array关联数组:array[index-expression]index-expression:(1) 可使用任意字符串;字符串要使用双引号;(2) 如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值初始化为\"空串\";如果我们把它当数值使用(运算),空串会被当成0; 若要判断数组中是否存在某元素,要使用\"index in array\"(数组是否存在索引)格式进行; weekdays[\"mon\"]=\"Monday\"注意:awk中字符串都使用双引号,只有program使用单引号'{}' #定义数组 awk 'BEGIN{weekdays[\"mon\"]=\"monday\";weekdays[\"tue\"]=\"tuesday\";print weekdays[\"mon\"],weekdays[\"tue\"]}' #遍历数组,不会按赋值顺序遍历 awk 'BEGIN{weekdays[\"mon\"]=\"Monday\";weekdays[\"tue\"]=\"Tuesday\";for(i in weekdays){print weekdays[i]} }' #awk统计ipv4的所有行,LISTEN和ESTABLISHED状态的个数 netstat -tan | awk '/^tcp\\>/{state[$NF]++;}END{for(i in state){print i,state[i]}}' rpm -q httpd systemctl status httpd systemctl start httpd #统计各访问ip的次数 awk '{ip[$1]++;}END{for(i in ip){ print i,ip[i] }}' /var/log/httpd/access_log 练习:1、统计/etc/fstab文件中每个文件系统类型出现的次数; awk '/^(\\/dev|UUID)/{filetype[$3]++;}END{for(i in filetype) { print i,filetype[i] }}' /etc/fstab 2、统计指定文件中每个单词出现的次数; awk '{for(i=0;i 9、函数9.1 内置函数数值处理:rand():返回0和1之间一个随机数;字符串处理:length([s]):返回指定字符串的长度;sub(r,s,[t]):以r表示的模式来查找t所表示的字符中的匹配的内容,并将其第一次出现替换为s所表示的内容;gsub(r,s,[t]):以r表示的模式来查找t所表示的字符中的匹配的内容,并将其所有出现均替换为s所表示的内容; split(s,a[,r]):以r为分隔符切割字符s,并将切割后的结果保存至a所表示的数组中; #返回0和1之间一个随机数;awk中只有第一次取是随机的,随后都是同一个数值 awk 'BEGIN{print rand()}' #split函数的使用 netstat -tan | awk '/^tcp\\>/{split($5,ip,\":\");count[ip[1]]++}END{for(i in count){ print i,count[i] }}' 9.2 自定义函数(不常用了解即可) "},"pages/44.通信加密和解密、公钥、私钥、CA.html":{"url":"pages/44.通信加密和解密、公钥、私钥、CA.html","title":"44.通信加密和解密、公钥、私钥、CA","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 密钥算法和协议 对称加密:加密和解密使用同一个密钥; 公钥加密 单向加密 密钥交换:IKE(Internet Key Exchange) OpenSSL 传输层协议:TCP、UDP、SCTPport:进程地址,进程向内核注册使用某端口(独占) 同一主机上的进程间通信:IPC,message queue,shm,semerphor不同主机上进程间通信:socketClientIp:port ServerIp:portcip:55673 sip:80 监听模式:LISTEN (Ip:port) SSL:Secure Sockets Layerhttp --> ssl --> https 安全的目标:保密性:confidentiallty完整性:integrity可用性:availability 攻击类型:威胁保密性攻击:窃听、通信量分析;威胁完整性的攻击:更改、伪装、重放、否认威胁可用性的攻击:拒绝服务(DOS) 解决方案:技术(加密和解密)、服务(用于抵御攻击的服务,也即是为了上述安全目标而特地设计的安全服务) 加密和解密:传统加密方法:替代加密方法、置换加密方法现代加密方法:现代加密方法、 服务:认证机制访问控制机制 Linux系统:OpenSSL(ssl)、GPG(pgp) OpenSSL由三部分组成:libencrypto库libssl库openssl多用途命令行工具 密钥算法和协议 对称加密:加密和解密使用同一个密钥; 对称机密算法:DES:Data Encryption Standard;3DES:Triple DES;AES:Advanced Encryption Standard;(128bits,192bits,256bits,384bits)BlowfishTwofishIDEARC6CAST5 特性:1、加密、解密使用同一密钥;2、将原始数据分割成为固定大小的块,逐个进行加密; 缺陷:1、密钥太多;2、密钥分发困难; 公钥加密 密钥分为公钥和私钥公钥:从私钥中提取产生;可公开给所有人;pubkey;私钥:通过工具创建,使用者自己留存,必须保证其私密性;secret key;特点:用公钥加密的数据,只能使用与之配对儿的私钥解密;反之亦然; 用途:数字签名:主要在于让接收方确认发送方的身份;用于完成身份认证;实现方式:发送方用自己的私钥去加密数据特征码,接收方用对方的公钥去解密,如果能解开,从而就让接收方确认了发送方的身份发送方用自己的私钥去加密数据特征码的这个结果就叫做数字签名 密钥交换:发送方用对方公钥加密一个对称密钥,并发送给对方;数据加密 公钥加密算法:RSA、DSA、ELGamalDSA和RSA不同的地方在于,DSA仅能实现签名,而不能用于加解密.RSA即能签名,又能加解密.DSA:Digital Signature Algorithm也叫作DSS:Digital Signature Standard. 假设:Alice和Bob进行通信加密过程:加密过程:1、Alice为了保证数据安全无误保密的送达给Bob.Alice先用单向加密算法,计算出这段数据的特征码.2、而后用自己的私钥加密这段特征码,将特征码附加在这段数据的后面,生成数字签名.3、Alice生成一个临时的对称密钥,并使用对称密钥加密整段数据(也就是之前的数据和特征码),生成一个对称加密后的密码.4、Alice会获取到Bob的公钥,并用公钥加密上一步生成的密码,并附加在整段数据之后.发送给Bob.解密过程:5、Bob先用自己与公钥配对的私钥解密.这个过程就叫做密钥交换.6、对称加密的密钥解密数据.7、用Alice的公钥去解密特征码.能解密则代表Alice的身份得到了验证.8、Bob再用同样的单向加密算法去计算数据的特征码,并与解密出来的特征码相比较,如果一样说明数据的完整性得到了验证.以上步骤保证了保密性和完整性同时完成了身份验证; 单向加密 即提取数据指纹;只能加密,不能解密;特性:定长输出、雪崩效应;功能:完整性验证; 单向加密算法:md5:Message Digest 5,128bitssha1:Secure Hash Algorithm 1,160bitssha224,sha256,sha384,sha512 密钥交换:IKE(Internet Key Exchange) 公钥加密DH(Deffie-Hellman) PKI:公钥基础设施 Public Key Infrastructure签证机构:CA注册机构:RA证书吊销列表:CRL 证书存取库:CB X.509v3:定义了证书的结构以及认证协议标准版本号序列号签名算法ID发行者名称有效期限主体名称主体公钥发行者的唯一标识主体的唯一标识扩展信息发行者签名 SSL:Secure Sockets LayerNetscape:1994V1.0,V2.0,V3.0有安全性问题已经废弃 TLS:Transport Layer SecurityIETF:1999 V1.0,V1.1,V1.2,V1.3 分层设计:1、最底层:基础算法原语的实现,aes,ras,md5;2、向上一层:各种算法的实现;3、再向上一层:组合算法实现的半成品;4、用各种组件拼装而成的各种成品密码学协议软件; 协议开源实现:OpenSSL "},"pages/45.OpenSSL.html":{"url":"pages/45.OpenSSL.html","title":"45.OpenSSL","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 SSL会话主要三步 SSL Handshake Protocol: OpenSSL Linux系统下的随机数生成器 CA 配置文件：/etc/pki/tls/openssl.cnf 构建私有CA: 要用到证书进行安全通信的服务器,需要向CA请求签署证书: 吊销证书(了解): SSL/TLS SSL:安全套接字层 (ssl 1.0,ssl 2.0,ssl 3.0)TLS:传输层安全(tls 1.0,tls 1.1,tls 1.2,tls 1.3) SSL会话主要三步 客户端向服务器端索要并验证证书;双方协商生成\"会话密钥\";双方采用\"会话密钥\"进行加密通信; SSL Handshake Protocol: 第一阶段:ClientHello:支持的协议版本,比如tls 1.2;客户端生成一个随机数,稍后用户生成\"会话密钥\";支持的加密算法,比如AES、RSA;支持的压缩算法; 第二阶段:ServerHello:确认使用的加密通信版本,比如tls 1.2;服务器端生成一个随机数,稍后用于生成\"会话密钥\";确认使用的加密方法;服务器证书; 第三阶段:验证服务器证书,在确认无误后取出其公钥;(发证机构、证书完整性、证书持有者、证书有效期、吊销列表)发送以下信息给服务器端:一个随机数;编码变更通知(表示随后的信息都将用双方商定的加密方法和密钥发送);客户端握手结束通知; 第四阶段:收到客户端发来的第三个随机数pre-master-key后,计算生成本次会话所用到的\"会话密钥\";向客户端发送如下信息:编码变更通知(表示随后的信息都将用双方商定的加密方法和密钥发送);服务器端握手结束通知; PKI:公钥基础设施签证机构:CA注册机构:RA证书吊销列表:CRL证书存取库:CB OpenSSL libcrypto,libssl主要由开发者使用;openssl:多用途命令行工具; openssl众多子命令分为三类:标准命令消息摘要命令(dgst子命令)加密命令(enc子命令) #显示openssl的版本 openssl version 标准命令:enc,ca,req,genrsa,... 对称加密:工具:openssl enc,gpg支持的算法:3des,aes,blowfish,towfish enc命令: cp /etc/fstab ~/ #-e:代表加密,-des3代表使用des3加密算法,-a代表使用base64编码,-sale代表加盐,-in代表要加密的文件,-out代表加密后的文件,会提示输入两次确认密码 openssl enc -e -des3 -a -salt -in fstab -out fstab.ciphertext #查看加密的内容 cat fstab.ciphertext #解密刚才加密的文件,会提示输入密码 openssl enc -d -des3 -a -salt -in fstab.ciphertext -out fstab.plaintext #查看解密后的文件 cat fstab.plaintext 单向加密:工具:openssl dgst,md5sum,sha1sum,sha224sum,... dgst命令: #md5加密 openssl dgst -md5 fstab.plaintext md5sum fstab.plaintext 生成用户密码:工具:passwd,openssl passwd #查看openssl passwd的帮助文档 whatis passwd man sslpasswd #-1代表md5算法加密,-salt:指定加盐的值 openssl passwd -1 -salt 12345678 生成随机数:工具:openssl rand #查看openssl rand帮助 whatis rand man sslrand #使用base64编码生成随机数,这里的10代表10个字节 openssl rand -base64 10 #使用16进制编码生成随机数,这里的10代表10个字节 openssl rand -hex 10 #两种引用方式来生成随机盐创建密码 openssl passwd -1 -salt `openssl rand -hex 4` openssl passwd -1 -salt $(openssl rand -hex 4) 公钥加密:加密解密:算法:RSA,ELGamal工具:openssl rsautl,gpg 数字签名:算法:RSA,DSA,ELGamal 密钥交换:算法:DH 生成密钥:生成私钥: #生成1024位rsa私钥 openssl genrsa 1024 #使用输出重定向,将私钥保存在一个文件中 openssl genrsa 1024 > /tmp/mykey.private cat /tmp/mykey.private #使用-out选项保存到指定文件 openssl genrsa -out /tmp/mykey2.private 1024 cat /tmp/mykey2.private #umask 077;077代表生成的文件要使用666权限减去077结果为600的权限,这样保证只有自己能打开该加密文件,保证安全性 #使用\"()\"代表会使用一个子shell子进程去运行括号里的命令,括号里的umask 077;设置了子shell的umask值为077,括号内命令执行完毕后会销毁子shell进程 (umask 077;openssl genrsa -out /tmp/mykey3.private 2048) #执行完以上命令,我们可以查看父shell进程中umask还是默认值0022,所以创建文件默认为644(666-022),创建目录默认为755(777-022);第一位0是特殊权限 umask #查看权限 ll /tmp/mykey3.private 提出公钥 #-in代表从哪个私钥文件提取公钥,-pubout,输出公钥 openssl rsa -in /tmp/mykey3.private -pubout Linux系统下的随机数生成器 /dev/random:仅从熵池中返回随机数,熵池中的随机数用尽,则阻塞后来的进程,等待更多的随机数产生;/dev/urandom:从熵池中返回随机数,熵池中的随机数用尽,会利用软件生成伪随机数,非阻塞;伪随机数不安全;熵池:运行中的内核维护的一段内存空间,这段空间当中存储了大量的随机数;熵池中随机数来源:硬盘IO中断时间间隔;键盘IO中断时间间隔; CA 公共信任的CA,私有CA; 建立私有CA:opensslOpenCA 配置文件：/etc/pki/tls/openssl.cnf less /etc/pki/tls/openssl.cnf dir:CA的工作目录certs:存放签发过的证书目录crl_dir:存放吊销的证书目录database:存放各个已经办法过的证书的索引等信息的数据库文件serial:存放系列号的文件,文件中用于指明当前序列号certificate:指定CA的自签证书目录和文件名private_key:指定CA自己的私钥的目录和文件名default_days:证书的默认有效期default_crl_days:默认吊销日期,吊销声明多少天 构建私有CA: 在确定配置为CA的服务上生成一个自签证书,并为CA提供所需要的目录及文件即可; 步骤:(1) 生成私钥; #生成私钥 (umask 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096) #查看文件和权限 ls /etc/pki/CA/private/ -l #查看私钥 cat /etc/pki/CA/private/cakey.pem (2) 生成自签证书;openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3655-new:生成新证书签署请求;-x509:生成自签格式证书,专用于创建私有CA时;-key:生成请求时用到的私钥文件路径;-out:生成的请求文件路径;如果自签操作将直接生成签署过的证书;-days:证书的有效时长,单位是day; #-new表示生成一个新请求,-key表示指明你的私钥的路径,它会从该私钥提取出公钥,放在请求当中,-out表示保存在什么地方 #-days指明证书有效期限(单位:天),默认365天,-x509表示这是个自签证书,如果不是自签证书不要加-x509选项 #执行后会提示回答很多信息,看下图 openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3655 #查看生成的证书 ls /etc/pki/CA (3) 为CA提供所需的目录及文件; #创建所需的目录 mkdir -pv /etc/pki/CA/{certs,crl,newcerts} #创建所需的文件 touch /etc/pki/CA/{serial,index.txt} #serial这个文件要给明第一个证书的序列号 echo 01 > /etc/pki/CA/serial 要用到证书进行安全通信的服务器,需要向CA请求签署证书: 步骤:(以httpd为例)(1) 用到证书的主机生成私钥;(2) 生成证书签署请求;(3) 将请求通过可靠方式发送给CA主机;(4) 在CA主机上签署证书(5) 查看证书中的信息 #查看是否安装了httpd rpm -q httpd #安装httpd yum -y install httpd #启动 systemctl start httpd #查看httpd是否占用80端口 netstat -tnlp #进入httpd配置目录 cd /etc/httpd/ #创建ssl目录,在这个目录下生成一个证书签署请求,请求发给谁,让谁给签就可以了 mkdir ssl #进入ssl目录 cd ssl #生成私钥 (umask 077;openssl genrsa -out httpd.key 2048) #请求,需要填写信息,里面的内容要和之前证书颁发者写的内容一致 openssl req -new -key httpd.key -out httpd.csr -days 365 #信息填写看下图: 现在我们就生成了一个证书签署请求,叫httpd.csr.把这个请求扔给之前的那台CA的主机,由它签署一下即可 #ssh协议的远程安全复制命令 #将httpd.csr文件复制到192.168.147.153这台CA主机上,并放在tmp目录 scp httpd.csr root@192.168.147.153:/tmp/ #终端切换到153的CA主机上做签证,签完的证书放在/etc/pki/CA/certs/目录下,且签完的文件后缀名为.crt openssl ca -in /tmp/httpd.csr -out /etc/pki/CA/certs/httpd.crt -days 365 #查看证书签署的信息 cat /etc/pki/CA/index.txt #将证书发给web服务器 scp /etc/pki/CA/certs/httpd.crt root@192.168.147.152:/etc/httpd/ssl/ #在152主机上查看证书文件,只看serial和subject openssl x509 -in /etc/httpd/ssl/httpd.crt -noout -serial -subject 吊销证书(了解): 步骤:(1) 客户端获取要吊销的证书的serial(在使用证书的主机上执行) openssl x509 -in /etc/httpd/ssl/httpd.crt -noout -serial -subject (2) CA主机吊销证书先根据客户提交的serial和subject信息,对比其本机数据库index.txt中存储的是否一致;吊销:openssl ca -revoke /etc/pki/CA/newcerts/serial.pem其中的serial要换成证书真正的序列号; ls /etc/pki/CA/newcerts/ openssl ca -revoke /etc/pki/CA/newcerts/01.pem (3) 生成吊销证书的吊销编号(第一次吊销证书时执行)echo 01 > /etc/pki/CA/crlnumber (4) 更新证书吊销列表openssl ca -gencrl -out thisca.crl 查看crl文件:openssl crl -in /PATH/FROM/CRL_FILE.crl -noout -text "},"pages/46.DNS.html":{"url":"pages/46.DNS.html","title":"46.DNS","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 DNS:Domain Name Service,应用层协议 一次完整的查询请求经过的流程: 主-辅DNS服务器 DNS and Bind Sockets:C/S:Client:发起应用请求的程序；Server:响应请求(提供服务)程序;LISTEN:Socket 传输层协议:TCP,UDP,SCTPTCP:Transmission Control Protocol面向连接的协议:双方通信之前需要事先建立虚连接;UDP:User Datagram Protocol无连接的协议:双方无需通信之前需要事先建立虚连接; DNS:Domain Name Service,应用层协议 C/Stcp、udp协议的53号端口 www.baidu.com:FQDN(Full Qualified Domain Name) tld:Top Level Domain组织域:.com,.net,.orgh,.gov.edu,.mil,...国家域:.iq,.tw,.hk,.jp,.cn,... DNS查询类型:递归查询迭代查询 DNS名称解析方式名称 --> IP:正向解析IP --> 名称:反向解析 注意:二者的名称空间,非为同一个空间,即非为同一颗树;因此,也不是同一个解析库; 域:baidu.com.www.baidu.com. 1.1.1.1ftp.baidu.com. 2.2.2.2bbs.baidu.com. 3.3.3.3cloud.baidu.com. 4.4.4.4 DNS服务器类型:负责解析至少一个域:　　主名称服务器　　辅助名称服务器不负责域解析:　　缓存名称服务器 一次完整的查询请求经过的流程: Client --> hosts文件 --> DNS Local Cache --> DNS Server(recursion) -->自己负责解析的域:直接查询数据库并返回答案;不是自己负责解析域:Server Cache --> Iteration(迭代) 解析答案:肯定答案;否定答案:不存在查询的键,因此,不存在与其查询键对应的值; 权威答案:由直接负责的DNS服务器返回的答案;非权威答案:其他的都是非权威答案; 主-辅DNS服务器 主DNS服务器:维护所负责解析的域数据库的那台服务器;读写操作均可进行;从DNS服务器:从主DNS服务器那里或其它的从DNS服务器那里\"复制\"一份解析库;但只能进行读操作;\"复制\"操作的实施方式:序列号:serial,也即时数据库的版本号;主服务器数据库内容发生变化时,其版本号递增;刷新时间间隔:refresh,从服务器每多久到主服务器检查序列号更新状况;重试时间间隔:retry,从服务器从主服务器请求同步解析库失败时,再次发起尝试请求的时间间隔;过期时常:expire,从服务器始终联系不到主服务器时,多久之后放弃从主服务器同步数据;停止提供服务;否定答案的缓存时长:negative answer ttl; 主服务器\"通知\"从服务器随时更新数据; 区域传送:全量传送:axfr,传送整个数据库;增量传送:lxfr,仅传送增量的数据; 区域(zone)和域(domain):baidu.com域:FQDN --> IP正向解析库;区域 IP --> FQDN反向解析库;区域 区域数据库文件:资源记录:Resource Record,简称rr;记录有类型:A,AAAA,PTR,SOA,NS,CNAME,MX SOA:Start Of Authority,起始授权记录;一个区域解析库有且只能有一个SOA记录,而且必须放在第一条;NS:Name Service,域名服务记录;一个区域解析库可以有多个NS记录;其中一个为主;A:Address,地址记录,FQDN --> IPV4;AAAA:地址记录,FQDN --> IPV6;CNAME:Canonical Name,别名记录;PTR:Pointer,IP --> FQDNMX:Mail Exchanger,邮件交换器优先级:0-99,数字越小优先级越高; 资源记录的定义格式:语法: name [TTL] IN RR_TYPE value SOA:name:当前区域的名字;例如\"baidu.com.\",或者\"2.3.4.in-addr.arpa.\"value:有多部分组成(1) 当前区域的区域名称(也可以使用主DNS服务器名称);(2) 当前区域管理员的邮箱地址;但地址中不能使用@符号,一般使用点号来替代;(3) (主从服务协调属性的定义以及否定答案的TTL) 例如: baidu.com. 86400 IN SOA baidu.com. admin.baidu.com. ( 　　　　　　　　　　　　2017010801 ;serial 　　　　　　　　　　　　2H ;refresh 　　　　　　　　　　　　10M ;retry 　　　　　　　　　　　　1W ;expire 　　　　　　　　　　　　1D ;negative answer ttl ) NS:name:当前区域的区域名称value:当前区域的某DNS服务器的名字,例如ns.baidu.com.;注意:一个区域可以有多个ns记录; 例如: baidu.com. 86400 IN NS ns1.baidu.com. baidu.com. 86400 IN NS ns2.baidu.com. MX:name:当前区域的区域名称value:当前区域某邮件交换器的主机名注意:MX记录可以有多个;但每个记录的value之前应该有一个数字表示其优先级; 例如: baidu.com. IN MX 10 mx1.baidu.com. baidu.com. IN MX 20 mx1.baidu.com. A:name:某FQDN,例如www.baidu.com.value:某IPV4地址; 例如: www.baidu.com. IN A 1.1.1.1 www.baidu.com. IN A 1.1.1.2 bbs.baidu.com. IN A 1.1.1.1 AAAA:name:FQDNvalue:IPV6 PTR:name:IP地址,有特定格式,IP反过来写,而且加特定后缀;例如1.2.3.4的记录应该写为4.3.2.1.in-addr.arpa.;value:FQDN 例如: 4.3.2.1.in-addr.arpa IN PTR www.baidu.com. CNAME:name:FQDN格式的别名value:FQDN格式的正式名字 例如: web.baidu.com. IN CNAME www.baidu.com. 注意:(1) TTL可以从全局继承;(2) @表示当前区域的名称;(3) 相邻的两条记录其name相同时,后面的可省略;(4) 对于正向区域来说,各MX,NS等类型的记录的value为FQDN,此FQDN应该有一个A记录； "},"pages/47.DNS and Bind.html":{"url":"pages/47.DNS and Bind.html","title":"47.DNS and Bind","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 BIND的安装配置 程序包: bind: 主配置文件:/etc/named.conf 解析库文件: rndc:remote name domain controller bind程序安装完成之后,默认即可做缓存名称服务器使用;如果没有专门负责解析的区域,直接即可启动服务; 主配置文件格式(/etc/named.conf): 缓存名称服务器的配置: 配置解析一个正向区域: 配置解析一个反向区域 主从服务器: 子域授权: bind中的安全相关的配置: DNS and BIND BIND的安装配置 BIND:Berkeley Internet Name Domain,ISC.orgdns:协议bind:dns协议的一种实现named:bind程序运行的进程名 程序包: bind-libs:被bind和bind-utils包中的程序共同用到的库文件;bind-utils:bind客户端程序集,例如dig,host,nslookup等;bind:提供的dns server程序、以及几个常用的测试程序;bind-chroot:选装,让named运行于jail模式下; #查看bind的简要信息 yum info bind #查看bind相关的包 yum list all bind* #查看bind-libs所安装的库文件 rpm -ql bind-libs #查看bind-utils所安装的程序 rpm -ql bind-utils #查看bind-utils的简要信息 yum info bind-utils #查看bind的简要信息 yum info bind bind: 主配置文件:/etc/named.conf 或包含进来其它文件:/etc/named.iscdlv.key/etc/named.rfc1912.zones/etc/named.root.key #安装bind yum install -y bind #查看bind的安装文件 rpm -ql bind 解析库文件: /var/named/目录下;一般名字为:ZONE_NAME.zone 注意:(1) 一台DNS服务器可同时为多个区域提供解析;(2) 必须要有根区域解析库文件:named.ca;(3) 还应该有两个区域解析库文件:localhost和127.0.0.1的正反向解析库;正向解析库named.localhost cat /var/named/named.localhost 反向解析库：named.loopback cat /var/named/named.loopback rndc:remote name domain controller rndc工作在tcp的53端口,默认监听于127.0.0.1地址,因此仅允许本地使用; bind程序安装完成之后,默认即可做缓存名称服务器使用;如果没有专门负责解析的区域,直接即可启动服务; CentOS 6:service named startCentOS 7:systemctl start named.service 主配置文件格式(/etc/named.conf): 全局配置段:options{...}日志配置段:logging{...}区域配置段:zone{...}那些由本机负责解析的区域,或转发的区域; 注意:每个配置语句必须以分号结尾; 缓存名称服务器的配置: vim /etc/named.conf 监听能与外部主机通信的地址;监听特定地址:listen-on port 53{ 192.168.147.152; };(注意{}内的文本前后必须要有空格) 学习时,建议关闭dnssec dnssec-enable no; dnssec-validation no; dnssec-lookaside no; 把关闭仅允许本地查询,注释掉;(这样就允许所有DNS到本机查询,这是默认选项) //allow-query { localhost } 检查配置文件语法错误: #不指定配置文件默认为检查/etc/named.conf named-checkconf #指定检查的配置文件 named-checkconf /etc/named.conf 启动服务 #启动服务 systemctl start named.service #查看状态 systemctl status named.service #查看tcp和udp的53号端口侦听是否是named ss -tunlp 修改dns配置文件vim /etc/resolv.conf #修改dns地址为192.168.147.152 nameserver 192.168.147.152 确保防火墙是关闭的: #查看防火墙规则 iptables -L -n #清空防火墙规则 iptables -F #停止防火墙 systemctl stop firewalld #禁止防火墙开机自启动 systemctl disable firewalld 测试工具:dig,host,nslookup等 dig命令:dig [-t RR_TYPE] name [@SERVER] [query options]用于测试dns系统,因此其不会查询hosts文件;查询选项:+[no]trace:跟踪解析过程;+[no]recurse:进行递归解析; 反向解析测试dig -x ip 模拟完全区域传送:dig -t axfr DOMAIN [@server] #没有写@server表示通过本机作为DNS服务器测试 dig -t A www.baidu.com dig -t A www.sina.com #+trace跟踪正向解析过程 dig +trace -t A www.baidu.com #反向解析测试 dig -x 180.76.76.95 host命令:host [-t RR_TYPE] name SERVER_IPSERVER_IP:代表指定DNS服务器IP测试,不指定表示通过本机作为DNS服务器测试 #查询A记录对应的ip host -t A www.baidu.com #查询百度这个域的域名服务器 host -t NS baidu.com #查询百度这个域的邮件服务器 host -t MX baidu.com nslookup命令:nslookup [-options] 交互式模式:nslookup>server IP:以指定的IP为DNS服务器进行查询;set q=RR_TYPE:要查询的资源记录类型;name:要查询的名称; #进入交互模式 nslookup #指定IP对应的DNS服务器来查询 server 192.168.147.2 #设置查询A记录类型 set q=A #查询sohu的A记录 www.sohu.com #退出 exit rndc命令:named服务控制命令 #查看服务器状态 rndc status #清空缓存 rndc flush 配置解析一个正向区域: 以baidu.com域为例: (1) 定义区域在主配置文件中或主配置文件辅助配置文件中实现;格式如下: zone \"ZONE_NAME\" IN { type {master|slave|hint|forward}; file \"ZONE_NAME.zone\"; } 注意:区域名字(ZONE_NAME)即为域名; (2) 建立区域数据文件(主要记录为A或AAAA记录)在/var/named目录下建立区域数据文件;以下示例建立了:/var/named/baidu.com.zone区域数据文件 权限及属组修改: cd /var/named/ chgrp named baidu.com.zone chmod o= baidu.com.zone 检查语法错误:named-checkconfnamed-checkzone ZONE_NAME ZONE_FILE (3) 让服务器重载配置文件和区域数据文件rndc reload或者systemctl reload named.service 编辑配置文件vim /etc/named.rfc1912.zones在末尾加入如下: zone \"baidu.com\" IN { type master; file \"baidu.com.zone\"; }; 创建对应的区域数据库文件,默认路径在/var/named下: cd /var/named 编辑文件如下:vim baidu.com.zone: $TTL 3600 $ORIGIN baidu.com. @ IN SOA ns1.baidu.com. dnsadmin.baidu.com. ( 2019082701 1H 10M 3D 1D ) IN NS ns1 IN MX 10 mx1 IN MX 20 mx2 ns1 IN A 192.168.147.152 mx1 IN A 192.168.147.153 mx2 IN A 192.168.147.154 www IN A 192.168.147.152 web IN CNAME www bbs IN A 192.168.147.155 bbs IN A 192.168.147.156 $TTL 3600:(Time To Live)单位是秒;$ORIGIN baidu.com.:域,比如以下ns1、mx1、mx2后面没写会自动补全这个ORIGIN的这个域; 检查主配置文件是否有语法错误: #修改权限,将属组改成named chown :named /var/named/baidu.com.zone #修改其他用户没有任何权限 chmod o= /var/named/baidu.com.zone #检查主配置文件 named-checkconf #检查区域数据库文件 named-checkzone baidu.com /var/named/baidu.com.zone #完成整个区域内容重载 rndc reload #通过指定本机作为DNS服务器来解析A记录 dig -t A www.baidu.com @192.168.18.146 #通过指定本机作为DNS服务器来解析A记录,使用主机名web.baidu.com dig -t A web.baidu.com @192.168.18.146 #通过指定本机作DNS服务器来解析A记录,使用主机名bbs.baidu.com dig -t -A bbs.baidu.com @192.168.18.146 #host来解析,并指定146作为DNS服务器 host -t A bbs.baidu.com 192.168.18.146 #解析ns记录 dig -t NS baidu.com #解析mx记录 dig -t MX baidu.com #host来解析mx记录 ost -t MX baidu.com 配置解析一个反向区域 (1) 定义区域在主配置文件中或主配置文件辅助配置文件中实现;格式如下: zone \"ZONE_NAME\" IN { type {master|slave|hint|forward}; file \"ZONE_NAME.zone\"; } 注意:反向区域的名字是反写的网段地址.in-addr.arpa18.168.192.in-addr.arpa (2) 定义区域解析库文件(主要记录为PTR) (3) 让服务器重载配置文件和区域数据文件 示例:区域区域名称为:18.168.192.in-addr.arpa:编辑:vim /etc/named.rfc1912.zones文件,在末尾新增如下: zone \"18.168.192.in-addr.arpa\" IN { type master; file \"192.168.18.zone\"; }; cd /var/named/ 编辑区域解析库文件vim 192.168.18.zone文件: $TTL 3600 $ORIGIN 18.168.192.in-addr.arpa. @ IN SOA ns1.kecloud.com. nsadmin.kecloud.com.( 2019082701 1H 10M 3D 12H ) IN NS ns.kecloud.com. 67 IN PTR ns.kecloud.com. 68 IN PTR mx1.kecloud.com. 69 IN PTR mx2.kecloud.com. 70 IN PTR bbs.kecloud.com. 71 IN PTR bbs.kecloud.com. 67 IN PTR www.kecloud.com. #修改属组 chgrp named /var/named/192.168.18.zone #修改权限 chmod o= /var/named/192.168.18.zone #检查主配置文件 named-checkconf #检查区域数据库文件 named-checkzone 18.168.192.in-addr.arpa /var/named/192.168.18.zone #完成整个区域内容重载 rndc reload #查看dns服务器状态,number of zones选项值加了1 rndc status #反向解析IP dig -x 192.168.18.67 主从服务器: 注意:从服务器时区域级别的概念; 配置一个从区域:On Slave(1) 定义区域定义一个从区域,格式如下:; zone \"ZONE_NAME\" IN { type slave; file \"slaves/ZONE_NAME.zone\"; masters { MASTER_IP; }; }; 配置文件语法检查:named-checkconf (2) 重载配置 rndc reload systemctl reload named.service On Master(1) 确保区域数据文件中为每个从服务配置NS记录,并且在正向区域文件中,为每个从服务器的NS记录的主机名配置一个A记录,且此A后面的地址为真正的从服务器的IP地址; 注意:主从DNS服务器时间要同步;(多台服务器基于某种特定的应用同时协调的进程和服务都应该做时间同步)ntpdate命令; #新开一台IP为192.168.147.212作为DNS从服务器,并安装bind yum install -y bind #编辑DNS服务器的主配置文件,让其能监听到外部IP地址上 vim /etc/named.conf 在配置文件中新增一个地址192.168.147.212,并关闭dnssec功能: listen-on port 53 { 127.0.0.1; 192.168.147.212; }; dnssec-enable no; dnssec-validation no; dnssec-lookaside no; 把关闭仅允许本地查询,注释掉;(这样就允许所有DNS到本机查询,这是默认选项) //allow-query { localhost } 检查配置文件语法错误并启动named服务: #检查主配置文件是否有语法错误 named-checkconf #启动dns服务 systemctl start named.service #查看dns服务状态 systemctl status named.service 编辑配置文件,将其配置为正向区域的从服务器,vim /etc/named.rfc1912.zones,在末尾加入如下配置: zone \"baidu.com\" IN { type slave; file \"slaves/baidu.com.zone\"; masters { 192.168.147.152; }; }; 检查配置文件语法错误:named-checkconf 到主DNS服务器IP为192.168.147.152加一条ns记录vim /var/named/baidu.com.zone: 检查主服务器区域配置文件是否存在错误,并让服务器重载配置文件和区域数据文件: #检查主服务器区域配置文件是否存在错误 named-checkzone baidu.com /var/named/baidu.com.zone #让服务器重载配置文件和区域数据文件 rndc reload #查看状态,有选项为server is up and running表示启动正常 rndc status 回到从服务器212 #让服务器重载配置文件和区域数据文件 rndc reload #查看dns服务器状态,可以看到日志中有如下字样,表示传输完成 #transfer of 'baidu.com/IN' from 192.168.147.152#53: Transfer completed: ..... systemctl status named.service #查看主DNS服务器传过来的区域数据库文件 ll /var/named/slaves/ #查看传输过来的文件是二进制格式 cat /var/named/slaves/baidu.com.zone #使用从服务器做解析测试 dig -t A www.baidu.com @192.168.147.212 切换到主服务器152编辑vim /var/named/baidu.com.zone文件,加入A记录pop3,并修改版本号: #让服务器重载配置文件和区域数据文件 rndc reload #查看状态 systemctl status named.service 切换到从服务器212,查看dns服务状态: #对新增的pop3做解析测试 dig -t -A pop3.baidu.com @192.168.147.212 手动测试区域传送: #测试从主DNS服务器152，向子DNS服务器212上做区域传送 dig -t axfr baidu.com @192.168.147.152 子域授权: 正向解析的区域授权子域的方法: ops.baidu.com. IN NS ns1.ops.baidu.com. ops.baidu.com. IN NS ns1.ops.baidu.com. ns1.ops.magedu.com. IN A IP.AD.DR.ESS(主子域名称服务器的IP地址) ns2.ops.magedu.com. IN NS IP.AD.DR.ESS(次子域名称服务器的IP地址) 修改主DNS服务器192.168.147.152区域数据库文件:vim /var/named/baidu.com.zone: #让服务器重载配置文件和区域数据文件 rndc reload 切换到192.168.147.139服务器作子域DNS服务器 #安装bind程序 yum install bind -y #编辑DNS服务器的主配置文件,让其能监听到外部IP地址上 vim /etc/named.conf 在配置文件中新增一个地址192.168.147.139,并关闭dnssec功能: listen-on port 53 { 127.0.0.1; 192.168.147.139; }; dnssec-enable no; dnssec-validation no; dnssec-lookaside no; 把关闭仅允许本地查询,注释掉;(这样就允许所有DNS到本机查询,这是默认选项) //allow-query { localhost } 启动服务和查看状态: systemctl start named.service systemctl status named.service #查看53号端口ip是否是192.168.147.139 ss -tnlp 编辑配置文件,添加子域,vim /etc/named.rfc1912.zones,末尾添加如下: zone \"ops.baidu.com\" IN { type master; file \"ops.baidu.com.zone\"; }; 创建区域解析库vim /var/named/ops.baidu.com.zone: $TTL 3600 $ORIGIN ops.baidu.com. @ IN SOA ns1.ops.baidu.com. nsadmin.ops.baidu.com. ( 2019082801 1H 10M 1D 2H ) IN NS ns1 ns1 IN A 192.168.147.139 www IN A 192.168.147.139 #修改权限 chmod o= /var/named/ops.baidu.com.zone chgrp named /var/named/ops.baidu.com.zone #让服务器重载配置文件和区域数据文件 rndc reload #解析测试 dig -t A www.ops.baidu.com @192.168.147.139 定义转发:注意:被转发的服务器必须允许为当前服务器做递归;(1) 区域转发:仅转发对某特定区域的解析请求;格式: zone \"ZONE_NAME\" IN { type forward; forward {first|only}; forwarders { SERVER_IP; } }; first:首先转发;转发器不响应时,自行去迭代查询;only:只转发; 对于子域而言,由于它不知道父域在什么地方,我们可以定义区域转发,这样就不用专门去找根DNS服务器去查询编辑:vim /etc/named.rfc1912.zones,在末尾加入: zone \"baidu.com\" IN { type forward; forward only; forwarders { 192.168.147.152; 192.168.147.212; }; }; #检查主配置文件语法错误 named-checkconf #完成整个区域内容重载 rndc reload 切换到主DNS的服务器152父域解析子域测试: dig -t A www.ops.baidu.com @192.168.147.152 切换到子域服务器139子域解析父域测试 dig -t A www.baidu.com @192.168.147.139 (2) 全局转发:针对凡本地没有通过zone定义的区域查询请求,通通转发给某转发器;格式: options{ ... ... forward {only|first}; forwarders { SERVER_IP; }; }; 编辑配置文件:vim /etc/named.conf,在options选项中加入: forward only; forwarders { 192.168.147.152; }; rndc reload #这样子域服务器不是自己解析的内容转发给152解析 dig -t A www.sina.com.cn @192.168.147.139 bind中的安全相关的配置: acl:访问控制列表;把一个或多个地址归并一个命名的集合,随后通过此名称即可对此集合内的所有主机实现统一调用;格式: acl acl_name{ ip; net/prelen; }; 示例: acl mynet{ 192.168.147.0/24; 127.0.0.0/8; }; bind有四个内置的aclnone:没有一个主机;any:任意主机;local:本机;localnet:本机所在的IP所属的网络; 访问控制指令:allow-query {};允许查询的主机;白名单;allow-transfer{};允许向哪些主机做区域传送;默认为向所有主机;应该配置仅允许从服务器;allow-recursion{};允许哪些主机向当前DNS服务器发起递归查询请求;allow-update{};DDNS,允许动态更新区域数据库文件中内容; "},"pages/48.http协议及Web服务.html":{"url":"pages/48.http协议及Web服务.html","title":"48.http协议及Web服务","keywords":"","body":"Web服务 应用层:http,https实现某类具体应用: 传输层协议:TCP,UDP,SCTP IANA:0-1023:众所周知,永久地分配给固定的应用使用,特权端口;1024-41951:亦为注册端口,但要求不是特别严格,分配给程序注册为某应用使用;3306/tcp,11211/tcp;41952+:客户端程序随机使用的端口,动态端口,或私有端口;其范围定义在/proc/sys/net/ipv4/op_local_port_range内核参数中; BSD Socket:IPC的一种实现,允许位于不同主机(也可以是同一主机)上的进程之间进行通信;Socket API(封装了内核中的socket通信相关的系统调用)SOCK_STREAM:TCP套接字SOCK_DGRAM:UDP套接字SOCK_RAW:raw套接字(裸套接字) 根据套接字所使用的地址格式,Socket Domain:AF_INET:Address Family,IPv4AF_INET6:IPv6AF_UNIX:同一主机上的不同进程间基于socket套接字通信使用的一种地址;Unix_SOCK TCP FSM(Finite State Mache):CLOSED ->LISTEN ->SYN_SENT ->SYN_RECV ->ESTABLISHED ->FIN_WAIT1 ->CLOSE_WAIT ->FIN_WAIT2 ->LAST_ACK ->TIMEWAIT ->CLOSED TCP协议的特性:建立连接:三次握手;将数据打包成段:校验和(CRC32);确认、重传及超时;排序:逻辑序号;流量控制:滑动窗口算法;拥塞控制:慢启动和拥塞避免算法; http:hyper text transfer protocol,应用层协议,80/tcp 协议版本:http/0.9:原型版本,功能简陋http/1.0:cache,MIME,methodMIME:Multipurpose Internet Mall Extesionmethod:GET,POST,HEAD,PUT,DELETE,TRACE,OPTIONShttp/1.1:增强了缓存功能;spdyhttp/2.0: rfc文档 工作模式:http请求报文:http requesthttp响应报文:http response一次http事务:请求响应 资源的标识机制:URLUniform Resource Locator:用于描述服务器某特定资源的位置;例如:http://www.sina.com.cn/index.htmlScheme://Server[:Port][/PATH/TO/SOME_RESOURCE] 一次完整的http请求处理过程:(1) 建立或处理连接:接收请求或拒绝请求;(2) 接收请求:接收来自于网络上的主机请求报文中对某特定资源的一次请求的过程;(3) 处理请求:对请求报文进行解析,获取客户端请求的资源及请求方法等相关信息;(4) 访问资源:获取请求报文中请求的资源;(5) 构建响应报文;(6) 发送响应报文;(7) 记录日志; 接收请求的模型:并发访问响应模型:单进程I/O模型:启动一个进程处理用户请求;这意味着,一次只能处理一个请求,多个请求被串行响应;多进程I/O结构:由父进程并行启动多个子进程,每个子进程响应一个请求;复用的I/O结构:一个进程响应n个请求:多线程模式:一个进程生成n个线程,一个线程处理一个请求;事件驱动(event-driven):一个进程直接处理n个请求;复用的多进程I/O结构:启动多个(m)个进程,每个进程生成(n)个线程;响应的请求的数量:m*n 处理请求:分析请求报文的http请求报文首部http协议:http请求报文首部http响应报文首部 请求:request响应:response 报文语法格式:request报文 response报文 method:请求方法,标明客户端希望服务器对资源执行的动作:GET、HEAD、POST、PUT(DAV)、DELETE、TRACE、OPTIONS version:HTTP/. status:三位数字,如200,301,302,404,502;标记请求处理过程中发生的情况; reason-phrase:状态码所标记的状态的简要描述; headers:每个请求或响应报文可包含任意个首部;每个首部都有首部名称,后面跟着一个冒号,而后跟上一个可选空格,接着是一个值; entity-body:请求时附加的数据或响应时附加的数据; method(方法):GET:从服务器获取一个资源;HEAD:只从服务器获取文档的响应首部;POST:向服务器发送要处理的数据;PUT:将请求的主体部分存储在服务器上;DELETE:请求删除服务器上指定的文档;TRACE:追踪请求到达服务器中间经过的代理服务器;OPTIONS:请求服务器返回对指定资源支持使用的请求方法; 协议查看或分析工具tcpdump,tshark,wireshark status(状态码):1xx:100-101,信息提示;2xx:200-206,成功;3xx:300-305,重定向;4xx:400-415,错误类信息,客户端错误;5xx:500-505,错误类信息,服务器端错误; 常用的状态码:200:成功,请求的所有数据通过响应报文的entity-body部分发送;OK301:请求的URL指向的资源已经被删除;但在响应报文中通过首部Location指明了资源现在所处的新位置;Moved Permanently302:与301相似,但在响应报文中通过Location指明资源现在所处临时新位置;Found304:客户端发出了条件式请求,但服务器上的资源未曾发生改变,则通过响应此响应状态码通知客户端;Not Modified401:需要输入账号和密码认证方能访问资源;Unauthorized403:请求被禁止;Forbidden404:服务器无法找到客户端请求的资源;Not Found500:服务器内部错误;Internal Server Error502:代理服务器从后端服务器收到了一条伪响应;Bad Gateway headers:格式:Name:Value Request Header: GET / HTTP/1.1 Host: www.baidu.com Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cookie: BAIDUID=EE51586CC6003E5D187357BD2ED27FC9:FG=1; BIDUPSID=EE51586CC6003E5D187357BD2ED27FC9; PSTM=1564037873; BD_UPN=12314753; MCITY=-333%3A; BDUSS=TVTcUhvdWoyWGU5UXJoUGhSQzVuN0pzQjF1fkxPTjhGM3FFTUlFcTBUeWNZM3RkSVFBQUFBJCQAAAAAAAAAAAEAAACkgCUwb2piazEyMzQzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJzWU12c1lNdd; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; H_PS_PSSID=1437_21118_29522_29521_29721_29568_29220_29458; H_PS_645EC=9cb3cYXI9%2BhXNdRtt8jdVZWChyReiLvDJf%2FJ%2BY3TbzeFo80lXJNQhiihtGoi8l%2F%2FOTun; delPer=0; BD_CK_SAM=1; PSINO=5; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; BDSVRTM=0 Response Header: HTTP/1.1 200 OK Bdpagetype: 2 Bdqid: 0x8fd8d2420013e5b3 Cache-Control: private Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html;charset=utf-8 Date: Wed, 04 Sep 2019 05:49:46 GMT Expires: Wed, 04 Sep 2019 05:49:46 GMT Server: BWS/1.1 Set-Cookie: BDSVRTM=220; path=/ Set-Cookie: BD_HOME=1; path=/ Set-Cookie: H_PS_PSSID=1437_21118_29522_29521_29721_29568_29220_29458; path=/; domain=.baidu.com Strict-Transport-Security: max-age=172800 X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked 首部分类:通用首部请求首部响应首部实体首部扩展首部 通用首部:Date:报文的创建时间Connection:连接状态,如keep-alive,closeVia:显示报文经过的中间节点Cache-Control:控制缓存 请求首部:Accept:可接受的媒体类型(MIME,text/html,application/javascript,images/jpeg);Accept-Charset:可接受字符编码格式;Accept-Encoding:可接受的编码格式,一般指压缩机制,如gzip,deflate,scdh;Accept-Language:接受的语言;zh-CN,zh;q=0.8 Client-IP:Host:请求的服务器名称和端口号;Referer:包含当前正在请求的资源的上一级资源;User-Agent:客户端代理; 条件式请求首部:If-Modified-Since:自从指定的时间之后,请求的资源是否发生过修改;If-None-Match:本地缓存中存储的文档的Etag标签是否与服务器文档的Etag不匹配; 安全请求首部:Authorization:向服务器发送认证信息,如账号和密码;Cookie:客户端向服务器发送cookie 代理请求首部:Proxy-Authorization:向代理服务器认证 响应首部:信息性:Age:响应持续时长Server:服务器程序软件名称和版本 协商首部:某资源有多重表示方法时使用Accept-Ranges:服务器可接受的请求范围类型Vary:服务器查看的其它首部列表; 安全响应首部:Set-Cookie:向客户端设置cookie;WWW-Authenticate:来自服务器的对客户端的质询认证表单 实体首部:Allow:列出对此实体可使用的请求方法Location:告诉客户端真正的实体位于何处 Content-Encoding:响应编码方式;gzip, deflate, brContent-Language:语言;zh-CN,zh;q=0.9Content-Length:主体的长度Content-Location:实体真正所处位置Content-Type:主体的对象类型 缓存相关:ETag:实体的扩展标签;Expires:实体的过期时间;Last-Modified:最后一次修改的时间; 访问资源:获取请求报文中请求的资源web服务器,即存放了web资源的主机,负责向请求者提供对方请求的静态资源,或动态资源运行生成的结果;这些资源通常应该放置于本地文件系统某路径下;此路径称为DocRoot; /var/www/html/:images/log.jpg http://www.baidu.com/images/log.jpg web服务器的资源路径映射方式:(a) docroot(b) alias(c) 虚拟主机的docroot(d) 用户家目录的docroot http请求处理中的连接模式:保持连接(长连接):keep-alive时间;数量;非保持连接(短连接); "},"pages/49.Apache.html":{"url":"pages/49.Apache.html","title":"49.Apache","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 httpd的特性 MPM:Multipath Processing Modules(多路处理模块): prefork:多进程模型,每个进程响应一个请求; worker:多进程多线程模型,每线程处理一个用户请求; event:事件驱动模型,多进程模型,每个进程响应多个请求; httpd的功能特性: CentOS7: httpd-2.4 httpd-2.4的常用配置 创建keepalive.conf文件vim ../conf.d/keepalive.conf加入如下: httpd ASF:apache software foundationhttpd:apachea patchy server=apache httpd的特性 高度模块化:core+modulesDSO:dynamic shared object MPM:Multipath Processing Modules(多路处理模块): prefork:多进程模型,每个进程响应一个请求; 一个主进程:负责生成子进程及回收子进程;负责创建套接字;负责接收请求,并将其派发给某子进程进程处理;n个子进程:每个子进程处理一个请求;工作模型:会预先生成几个空闲进程,随时等待用于响应用户请求;最大空闲和最小空闲; worker:多进程多线程模型,每线程处理一个用户请求; 一个主进程:负责生成子进程及回收子进程;负责创建套接字;负责接收请求,并将其派发给某子进程进程处理;多个子进程:每个子进程负责生成多个线程;每个线程:负责响应用户请求;并发响应数量:m*nm:子进程数量n:每个子进程所能创建的最大线程数量; event:事件驱动模型,多进程模型,每个进程响应多个请求; 一个主进程:负责生成子进程及回收子进程;负责创建套接字;负责接收请求,并将其派发给某子进程进程处理;子进程:基于事件驱动机制直接响应多个请求;httpd-2.2:仍为测试使用模型;httpd-2.4:event可生产环境中使用; #查看httpd信息 yum info httpd #查看httpd相关的包 yum list all http* #安装httpd yum install -y httpd #查看httpd主包和工具包的文件 rpm -ql httpd rpm -ql httpd-tools #启动httpd systemctl start httpd.service #查看是否是httpd占用80端口 ss -tnlp httpd的功能特性: CGI:Common Gateway Interface虚拟主机:IP,PORT,FQDN反向代理负载均衡路径别名丰富的用户认证机制:basicdigest支持第三方模块......... CentOS7: httpd-2.4 程序环境:配置文件:/etc/httpd/conf/httpd.conf/etc/httpd/conf.d/.conf模块相关的配置文件:/etc/httpd/conf.modules.d/.confsystemd unit file:/usr/lib/systemd/system/httpd.service主程序文件:/usr/sbin/httpdhttpd-2.4支持MPM的动态切换;日志文件:/var/log/httpd:access_log:访问日志error_log:错误日志站点文档:/var/www/html模块文件路径:/usr/lib64/httpd/modules 服务控制:systemctl enable|disable httpd.servicesystemctl {start|stop|restart|status} httpd.service httpd-2.4的常用配置 主配置文件:/etc/httpd/conf/httpd.confSection 1:Global Environment 全局环境配置,对所有的虚拟主机都通用的设定Section 2:'Main' server configuration 主服务器配置Section 3:Virtual Hosts 虚拟主机配置 配置格式:directive valuedirective:不区分字符大小写;value:为路径时,是否区分字符大小写,取决于文件系统; 常用配置:1、修改监听的IP和PORTListen [IP-address:]protnumber [protocol](1) 省略IP表示为0.0.0.0(2) Listen指令可重复出现多次;Listen 80Listen 8080(3) 修改监听socket,重启服务进程方可生效;(4) 限制其必须通过ssl通信时,protocol需要定义为https; #安装telnet yum install -y telnet #telnet测试 telnet 192.168.147.152 80 2、持久连接(保持连接,长连接)Persisten Connection:tcp连续建立后,每个资源获取完成后不全断开连接,而是继续等待其它资源请求的进行;如何断开?数量限制时间限制 副作用:对并发访问量较大的服务器,长连接机制会使得后续某些请求无法得到正常响应;折衷:使用较短的持久连接时长,以及较少的请求数量; KeepAlive On|OffKeepAliveTimeout 15MaxKeepAliveRequests 100 注意:httpd-2.4的KeepAliveTimeout可以是毫秒级的;例如:KeepAliveTimeout 300ms;单位默认为秒,加ms为毫秒; #备份配置文件 cd /etc/httpd/conf cp httpd.conf{,.bak} 创建keepalive.conf文件vim ../conf.d/keepalive.conf加入如下: KeepAlive off #检查配置文件语法错误 httpd -t #重启服务 systemctl restart httpd.service 使用telnet测试: 编辑vim ../conf.d/keepalive.conf修改如下: KeepAlive On KeepAliveTimeout 30 MaxKeepAliveRequests 100 #检查配置文件语法错误 httpd -t #重启服务 systemctl restart httpd.service 使用telnet测试:注意:做telnet测试要找一个客户端主机,这里使用139这个CentOS作为客户端,如果在152上使用需要telnet localhost 80; 3、MPMhttpd-2.2不支持同时编译多个MPM模块,所以只能编译选定要使用的那个;CentOS 6的rpm包围此专门提供了三个应用程序文件,httpd(prefork),httpd.worker,httpd.event,分别用于实现对不同的MPM机制的支持;确认现在使用的是哪个MPM机制的方法: ps aux | grep httpd 默认使用的为/usr/sbin/httpd,其为prefork的MPM模块; 查看httpd程序的模块列表:查看静态编译的模块:httpd -l查看静态编译及动态编译的模块:httpd -M 更换使用httpd程序,以支持其它MPM机制;/etc/sysconfig/httpdHTTPD=/usr/sbin/httpd.{worker,event} 注意:需要重启服务进程方可生效 httpd2.2(CentOS 6): #可以看到httpd2.2提供的MPM机制文件有3个/usr/sbin/httpd、/usr/sbin/httpd.event、/usr/sbin/httpd.worker #由于httpd2.2不支持动态装载,所以把三个都提供给我们了 rpm -ql httpd | grep /usr/sbin/httpd #可以看到默认是httpd,也就是MPM为prefork ps aux | grep httpd 如果在CentOS 6上想换别的MPM机制,编辑文件vim /etc/sysconfig/httpd加入如下,将MPM机制改为event: HTTPD=/usr/sbin/httpd.event 重启服务进程: service httpd restart #可以看到进程的执行程序变成了:/usr/sbin/httpd.event ps aux | grep httpd MPM配置/etc/httpd/conf/httpd.conf:prefork的配置: StartServers 8 #httpd进程启动以后不管有没有人访问,我们所要创建的几个空闲的子进程 MinSpareServers 5 #最小空闲子进程 MaxSpareServers 20 #最大空闲子进程 ServerLimit 256 #最大允许处于活跃状态的服务器子进程数量,一般设置为与MaxClients的值相同 MaxClients 256 #最大允许启动的服务器子进程的数量 MaxRequestsPerChild 4000 #一个子进程最多可以处理多少个请求,这里设置4000，意味着达到4000会被kill掉 worker的配置: StartServers 4 #httpd进程启动以后不管有没有人访问,我们所要创建的几个空闲的子进程 MaxClients 300 #最大允许创建的线程数 MinSpareThreads 25 #最少空闲线程数 MaxSpareThreads 75 #最大空闲线程数 ThreadsPerChild 25 #每个子进程启动时生成的线程数 MaxRequestsPerChild 0 #一个子进程最多可以处理多少个请求,线程模型所以不限制了,这里的0标识无限制 httpd2.4修改MPM机制,vim /etc/httpd/conf.modules.d/00-mpm.conf,使用哪种MPM机制就打开哪种机制的注释,并重启httpd服务即可: LoadModule mpm_prefork_module modules/mod_mpm_prefork.so #LoadModule mpm_worker_module modules/mod_mpm_worker.so #LoadModule mpm_event_module modules/mod_mpm_event.so 修改后使用:httpd -M | grep mpm来查看当前的MPM机制 PV,UV,IPPV:Page ViewUV:User ViewIP:访问IP量 4、DSO配置指定实现模块加载LoadModule 所有使用httpd -M显示为shared的模块,都是可以使用LoadModule来装载的 模块文件路径可使用相对路径:相对于ServerRoot(默认/etc/httpd) 5、定义'Main' server的文档页面路径ServerName 用来标识当前主机用于服务于谁的DocumentRoot \"\" 文档路径映射:DocumentRoot指向的路径为URL路径的起始位置其相当于站点URL的根路径; URL PATH与FileSystem PATH不是等同的,而是存在一种映射关系;URL / --> FileSystem /var/www/html//images/logo.jpg --> /var/www/html/images/logo.jpg 6、站点访问控制常见机制可基于两种机制指明对哪些资源进行何种访问控制文件系统路径:格式: ... ... ... URL路径: ... ... 中\"基于源地址\"实现访问控制:Options:定于特定目录下的资源如何被访问后跟1个或多个以空白字符分隔的\"选项\"列表;Indexes:指明的URL路径下不存在与定义的主页面资源相符的资源文件时,返回索引列表给用户;FollowSymLinks:允许跟踪符号链接文件所指向的源文件(网站源代码或资源文件如果是链接自其它非网站指定目录的文件,是否允许被访问,指定该选项则代表允许);None:什么选项都不用,最安全的做法;All:启用除了MultiViews的所有选项; mkdir /data/web/www/images #-iname选项表示不区分大小写 find /usr/share -iname \"*.jpg\" #将查找到的文件复制到/data/web/www/images目录下 find /usr/share -iname \"*.jpg\" -exec cp {} /data/web/www/images/ \\; ls /data/web/www/images/ 然后客户端访问http://192.168.147.152/images由于配置文件中打开了Indexes选项,所有会显示整个目录,如果去除这个配置,则会显示403,但不影响访问它下面的图片文件,只是访问这个目录不被允许; httpd-2.2的配置:order和allow、denyorder:定义生效次序;写在后面的表示默认法则; Allow from,Deny from来源地址:IPNetAddr:172.16172.16.0.0172.16.0.0/16172.16.0.0/255.255.0.0 Order allow,deny #这个次序代表不被允许的都拒绝访问 Deny from 192.168.147.139 #拒绝这个ip访问 Allow from 192.168 #允许这个网段访问 httpd-2.4:基于IP控制:Require ip IP地址或网络地址Require not ip IP地址或网络地址基于主机名控制:Require host 主机名或域名Require not host 主机名或域名 Options Indexes FollowSymLinks AllowOverride None Require not ip 192.168.147.130 #拒绝该ip访问 Require ip 192.168 #允许该网段访问 httpd-2.4Require 示例:配置DocumentRoot路径和访问权限: #创建目录,在目录下创建index.html文件 mkdir -pv /data/web/www 修改vim /etc/httpd/conf/httpd.conf配置文件的DocumentRoot为: DocumentRoot \"/data/web/www\" 重启服务: systemctl restart httpd.service 访问http://192.168.147.152/index.html页面之后提示:You don't have permission to access /index.html on this server.需要在/etc/httpd/conf/httpd.conf文件中配置访问控制: Options Indexes FollowSymLinks AllowOverride None Require all granted #代表允许所有人访问 重启服务: systemctl restart httpd.service 再次访问http://192.168.147.152/index.html 就可以了;注意:如果还是没有权限请检查防火墙和SELinux是否关闭; 控制页面资源允许所有来源的主机可访问:httpd-2.2 ... Order allow,deny Allow from all httpd-2.4 ... Require all granted 控制页面资源拒绝所有来源的主机可访问:httpd-2.2 ... Order allow,deny Deny from all httpd-2.4 ... Require all denied 7、定义站点主页面:DirectoryIndex index.htm index.html.var 8、定义路径别名格式:Alias /URL/ \"/PATH/TO/SOMEDIR/\" Alias /images/ \"/usr/share/pixmaps/faces/\" #定义别名 AllowOverride None Options Indexes FollowSymLinks Require all granted 9、设置默认字符集AddDefaultCharset UTF-8中文字符集:GBK、GB2312、GB18030 10、日志设定日志类型:访问日志和错误日志 错误日志:ErrorLog logs/error_logLogLevel warnPossible values Include:debug,info,notice,warn,error,crit,alert,emerg. 访问日志:LogFormat \"%h %l %u %t \\\"%r\\\" %>s %b \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"\" combinedCustomLog logs/access_log combined%h:客户端IP地址;%l:Remote User,通常为一个减号(\"-\");%u:Remote user(from auth;may be bogus if return status (%s) is 401);非为登录访问时,其为一个减号;%t:服务器收到请求时的时间;%r:First line of request,即表示请求报文的首行;记录了此次请求的\"方法\",\"URL\"以及协议版本;%>s:响应状态码;%b:响应报文的大小,单位是字节;不包括响应报文的http首部;%{Referer}i:请求报文中首部\"referer\"的值;即从哪个页面中的超链接跳转至当前页面的;%{User-Agent}i:请求报文中首部\"User-Agent\"的值;即发出请求的应用程序; 11、基于用户的访问控制 认证质询:WWW-Authenticate:响应码为401,拒绝客户端请求,并说明要求客户端提供账号和密码; 认证:Authorization:客户端用户填入账号和密码后再次发送请求报文;认证通过时,则服务器发送响应的资源; 认证方式有两种:basic:明文digest:消息摘要认证 安全域:需要用户认证后方能访问的路径;应该通过名称对其进行标识,以便于告知用户认证的原因; 用户的账号和密码存放于何处?虚拟账号:仅用于访问某服务时用到的认证标识 存储:文本文件;SQL数据库;ldap目录存储; basic认证配置示例:(1) 定义安全域 Options None AllowOverride None AuthType Basic AuthName \"String\" AuthUserFile \"/PATH/To/HTTPD_USER_PASSWD_FILE\" Require user username1 username2 ... 允许账号文件中的所有用户登录访问: Require valid-user (2) 提供账号和密码存储(文本文件)使用专用命令完成此类文件的创建及用户管理htpasswd [options] /PATH/TO/HTTPD_PASSWD_FILE username-c:自动创建此处指定的文件,因此,仅应该在此文件不存在时使用;-m:md5格式加密-s:sha格式加密-D:删除指定用户-b:批模式添加用户htpasswd -b /PATH/TO/HTTPD_PASSWD_FILE username password 示例:httpd自带命令htpasswd命令用于提供账户密码存储的文件 #使用htpasswd生成用户名密码到指定文件 htpasswd -c /tmp/test.users tom #查看 cat /tmp/test.users #再创建一个用户,就不能使用-c这个选创建一个新文件,如果存在则覆盖 htpasswd /tmp/test.users jerry #查看 cat /tmp/test.users #-b代表可以在用户名后面直接指定密码,-m代表使用md5加密,此为默认选项,不指定加密方式也用md5 htpasswd -b -m /tmp/test.users obama 123456 #查看 cat /tmp/test.users #复制到httpd的conf.d目录下 mv /tmp/test.users /etc/httpd/conf.d/.htpasswd #创建需要做权限控制的目录 mkdir /data/web/www/admin #在目录内创建文件,并在index.html页面里写上admin area vim /data/web/www/admin/index.html 创建配置文件vim /etc/httpd/conf.d/admin.conf: Options None AllowOverride None AuthType basic #basci认证方式 AuthName \"Admin Area,please enter username and password.\" #认证提示信息 AuthUserFile \"/etc/httpd/conf.d/.htpasswd\" #认证的用户信息配置文件 Require user jerry obama #允许访问的用户 #检查语法错误和重启服务 httpd -t systemctl restart httpd.service 另外:基于组账号进行认证;(1) 定义安全域 Options None AllowOverride None AuthType Basic AuthName \"String\" AuthUserFile \"/PATH/To/HTTPD_USER_PASSWD_FILE\" AuthGroupFile \"/PATH/TO/HTTPD_GROUP_FILE\" Require group grpname1 grpname2 ... (2) 创建用户账号和组账号文件;组文件:每一行定义一个组GRP_NAME:username1 username2 ... 创建组配置文件:vim /etc/httpd/con.d/.htgroup: animals: tom jerry #创建一个animals组,下面有tom何jerry 修改之前的配置文件: Options None AllowOverride None AuthType basic AuthName \"Admin Area,please enter username and password.\" AuthUserFile \"/etc/httpd/conf.d/.htpasswd\" AuthGroupFile \"/etc/httpd/conf.d/.htgroup\" Require group animals #检查语法错误和重启服务 httpd -t systemctl restart httpd 12、虚拟主机站点标识:socketIP相同,但端口不同;IP不同,但端口均为默认端口;FQDN不同;请求报文中首部Host:www.baidu.com 有三种实现方案:基于ip:为每个虚拟主机准备至少一个ip地址;基于port:为每个虚拟主机使用至少一个独立的port;基于FQDN:为每个虚拟主机使用至少一个FQDN; 注意(专用于httpd-2.2):一般虚拟主机不要与中心主机混用;因此,要使用虚拟主机,得先禁用'main'主机:禁用方法:注释中心主机的DocumentRoot指令即可; 虚拟主机的配置方法: ServerName FQDN DocumentRoot \"\" 其他可用指令:ServerAlias:虚拟主机的别名;可多次使用;ErrorLog:CustomLog: ... Alias... 示例: #创建虚拟主机目录,并在两个目录中分别创建index.html文件 mkdir /data/web/{ilinux,iunix} #查看ip ip addr list #为该网卡添加新的ip ip addr add 192.168.147.153/24 dev ens33 #用ip addr list简写查看 ip a l 编写第一个虚拟主机的配置文件vim /etc/httpd/conf.d/ilinux.conf: ServerName www.ilinux.io DocumentRoot \"/data/web/ilinux\" Options None AllowOverride None Require all granted CustomLog \"logs/ilinux_access_log\" combined 编写第二个虚拟主机的配置文件vim /etc/httpd/conf.d/iunix.conf: ServerName www.iunix.io DocumentRoot \"/data/web/iunix\" Options None AllowOverride None Require all granted CustomLog \"logs/iunix_access_log\" combined #检查语法 httpd -t #重启服务 systemctl restart httpd 之后就可以分别访问http://192.168.147.152,http://192.168.147.153查看不同效果了.如果希望按照端口不同的配置方式: #先删除153这个ip ip addr delete 192.168.147.153/24 dev ens33 #查看 ip a l 修改配置文件vim /etc/httpd/conf.d/iunix.conf: Listen 81 #记得侦听81端口 ServerName www.iunix.io DocumentRoot \"/data/web/iunix\" Options None AllowOverride None Require all granted CustomLog \"logs/iunix_access_log\" combined #检查语法 httpd -t #重启服务 systemctl restart httpd-d 之后就可以分别访问http://192.168.147.152,http://192.168.147.152:81查看不同效果了.如果希望基于不同主机名访问的分别修改两个配置方式: ServerName www.ilinux.io DocumentRoot \"/data/web/ilinux\" Options None AllowOverride None Require all granted CustomLog \"logs/ilinux_access_log\" combined #*:80 代表这台服务器上的所有ip ServerName www.iunix.io DocumentRoot \"/data/web/iunix\" Options None AllowOverride None Require all granted CustomLog \"logs/iunix_access_log\" combined #检查语法 httpd -t #重启服务 systemctl restart httpd-d #查看之前的定义日志在此目录中 ls /var/log/httpd/ 然后修改客户端hosts文件,就可以通过www.ilinux.io,www.iunix.io来访问了特别注意:关闭防火墙和selinux #查看防火墙规则 iptables -L -n #清空防火墙规则,这种清理值对当前有效 iptables -F #CentOS7停止防火墙,这种清理值对当前有效 systemctl stop firewalld.service #禁用防火墙,开机不自启动 systemctl disable firewalld.service setenforce 0或vim /etc/selinux/config文件将SELINUX=disabled,曾今在这个selinux上卡了很久,检查防火墙都ok的,文件一直403没权限访问. 注意:如果是httpd-2.2,则使用基于FQDN的虚拟主机时,需要实现使用如下指令:NameVirtualHost IP:PORT也就是说在这个ip和端口开放基于FQDN访问虚拟主机.httpd-2.4不用; 13.status页面(内建的状态页面)LoadModule status_module modules/mod_status.so httpd-2.2: SetHandler server-status Order allow,deny Allow from 192.168 httpd-2.4: SetHandler server-status Require ip 192.168 #查看模块是否被装载 httpd -M | grep status #编辑配置文件 vim /etc/httpd/conf.d/iunix.conf 配置文件如下 ServerName www.iunix.io DocumentRoot \"/data/web/iunix\" Options None AllowOverride None Require all granted CustomLog \"logs/iunix_access_log\" combined #指定服务器状态页面 SetHandler server-status Require ip 192.168 #允许访问的网段 14.user/group指定以哪个用户的身份运行httpd服务器进程;在配置文件中/etc/httpd/conf/httpd.conf查看: User apache Group apache 15.使用deflate_module模块压缩页面优化传输速度适用场景:(1) 节约带宽,额外消耗CPU;同时,可能有些较老浏览器不支持;(2) 压缩适于压缩的资源,例如文本文件; 创建压缩配置文件vim /etc/httpd/conf.d/compression.conf: #设置过滤器名为DEFLATE,过滤器名可以随意定义 SetOutputFilter DEFLATE #根据文件的MIME类型做过滤 AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE application/xhtml+xml AddOutputFilterByType DEFLATE text/xml AddOutputFilterByType DEFLATE application/xml AddOutputFilterByType DEFLATE application/x-javascript AddOutputFilterByType DEFLATE text/javascript AddOutputFilterByType DEFLATE text/css #指明压缩比(Highest9 - Lowest1) DeflateCompressionLevel 9 #判断user-agent来做相应的压缩机制 BrowserMatch ^Mozilla/4 gzip-only-text/html BrowserMatch ^Mozilla/4\\.0[678] no-gzip BrowserMatch \\bMSI[E] !no-gzip !gzip-only-text/html 16.https,http over ssl #查看mod_ssl信息 yum info mod_ssl #查看是否安装 httpd -M | grep ssl #安装 yum install -y mod_ssl #查看生成的文件 rpm -ql mod_ssl 139作为CA服务器 #创建私钥 cd /etc/pki/CA (umask 077;openssl genrsa -out private/cakey.pem 2048) #生成自签证书 openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 365 152作为SSL主机服务器 cd /etc/httpd mkdir ssl cd ssl #创建私钥 (umask 077;openssl genrsa -out httpd_key.pem 1024) #生成证书用于CA机构签发 openssl req -new -key httpd_key.pem -out httpd_csr.pem #将自己生成的证书文件复制到CA服务器的/tmp目录下 scp httpd_csr.pem root@192.168.147.139:/tmp 回到139,CA服务器 cd /etc/pki/CA touch index.txt serial echo 01 > serial #签发证书 openssl ca -in /tmp/httpd_csr.pem -out certs/httpd_crt.pem #将签发好的证书复制到SSL主机服务器 scp certs/httpd_crt.pem root@192.168.147.152:/etc/httpd/ssl 回到152,配置ssl证书 #查看虚拟主机设定 httpd -t -D DUMP_VHOSTS 编辑ssl配置文件,vim /etc/httpd/conf.d/ssl.conf: #这台服务器只有152这一个ip,所以不做修改 #设置主机名和访问根目录 DocumentRoot \"/data/web/ilinux\" ServerName www.ilinux.io:443 #设置ssl证书 SSLCertificateFile /etc/httpd/ssl/httpd_crt.pem #设置加密文件 SSLCertificateKeyFile /etc/httpd/ssl/httpd_key.pem 在虚拟机139这台CA服务器上打开火狐,首选项-->高级-->证书-->查看证书-->证书机构-->导入-->选择/etc/pki/CA/cakey.pem后就可以正常访问了同样在139上也可以使用以下命令测试(由于之前火狐浏览器在这台机器上添加了证书为受信任的机构):测试: openssl s_client -connect www.ilinux.io:443 -CAfile /etc/pki/CA/cacert.pem 17.httpd自带的工具程序htpasswd:basic认证基于文件实现时,用到的账号密码文件生成工具;apachectl:httpd自带的服务控制脚本,支持start和stop;apxs:由httpd-devel包提供,扩展httpd使用第三方模块的工具;rotatelogs:日志滚动工具;suexec:访问某些有特殊权限配置的资源时,临时切换至指定用户身份运行;ab:apache bench; 18.httpd的压力测试工具ab,webbench,http_load,seige jmeter,loadrunner "},"pages/50.LAMP.html":{"url":"pages/50.LAMP.html","title":"50.LAMP","keywords":"","body":"LAMP 安装lamp:CentOS 6:httpd,php,mysql-server,php-mysql service httpd start service mysqld start CentOS 7: Modules:程序包,httpd,php,php-mysql,mariadb-server systemctl start mariadb systemctl start httpd FastCGI:程序包,httpd,php-fpm,php-mysql,mariadb-server systemctl start mariadb systemctl start php-fpm systemctl start httpd #安装 yum -y install php php-mysql mariadb-server #查看php生成相关文件,可以看到httpd新加了配置文件/etc/httpd/conf.d/php.conf rpm -ql php #所以检查下语法 httpd -t #重启服务器 systemctl restart httpd #进入虚拟主机主目录 cd /data/web/ilinux/ 创建一个php文件在里面写phpinfo()函数vim phpinfo.php: 浏览器访问这个文件测试 #启动mariadb systemctl start mariadb #输入mysql命令就进入mariadb了 mysql 测试php连接mariadbvim php-mysql.php文件: 浏览器访问这个文件测试 示例:部署wordpress #先上传wordpress-4.7.4-zh_CN.tar.gz这个包 rz #解压 tar xf wordpress-4.7.4-zh_CN.tar.gz #复制解压文件到虚拟主机目录 cp -a wordpress /data/web/ilinux/blog #进入mysql mysql #授权wordpress这个数据库的所有表给wpuser这个用户,%代表任何ip的主机都可以连接,IDENTIFIED BY用于指定密码 GRANT ALL ON wordpress.* TO 'wpuser'@'%' IDENTIFIED BY '123456'; #退出 exit; #测试连接提示:ERROR 1045 (28000): Access denied for user 'wpuser'@'www.ilinux.io' (using password: YES) #这是因为mysql默认会把我们指定的ip解析为主机名的问题 mysql -uwpuser -h192.168.147.152 -p 编辑vim /etc/my.cnf加入skip-name-resolve=ON重启服务systemctl restart mariadb,然后再次连接问题解决. mysql -uwpuser -h192.168.147.152 -p #进入mysql,创建数据库 create database wordpress; #进入目录 cd /data/web/ilinux/blog #复制配置文件 cp wp-config-sample.php wp-config.php 编辑配置文件:vim wp-config.php: // ** MySQL 设置 - 具体信息来自您正在使用的主机 ** // /** WordPress数据库的名称 */ define('DB_NAME', 'wordpress'); /** MySQL数据库用户名 */ define('DB_USER', 'wpuser'); /** MySQL数据库密码 */ define('DB_PASSWORD', '123456'); /** MySQL主机 */ define('DB_HOST', '192.168.147.152'); /** 创建数据表时默认的文字编码 */ define('DB_CHARSET', 'utf8'); /** 数据库整理类型。如不确定请勿更改 */ define('DB_COLLATE', ''); 访问www.ilinux.io/blog安装即可 在mysql中修改密码: use mysql; select user,host,password from user; --修改user列为root,host列为127.0.0.1的密码 set password for 'root'@'127.0.0.1'=PASSWORD('123456'); --注:修改完后Mysql不会立即生效,想立即生效,使用以下指令 FLUSH PRIVILEGES; MYSQL MYSQL:单进程,多线程插件式存储引擎:存储引擎也称为表类型,如InnoDB、MyISAM;用户连接:通过线程来实现;线程池; Mysql的衍生版:MariaDBAliSQL CentOS 6:yum安装的版本是5.1,使用的存储引擎:MyISAMCentOS 7:yum安装的版本是5.5,使用的存储引擎:InnoDB #查看当前存储引擎 show engines; 索引:将表中的某一个或某些字段抽取出来,单独将其组织一个独特的数据结构中;常用的索引类型:B+Tree:Balance Tree;hash:只有它支持hash索引,MEMORY存储引擎(基于内存的存储引擎,重启数据就没了)支持; 注意:有助于读请求,但不利于写请求; "},"pages/51.MariaDB.html":{"url":"pages/51.MariaDB.html","title":"51.MariaDB","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 命令行交互式客户端程序:mysql 用户账号及权限管理 MariaDB(mysql): 可用版本:MySQL:MariaDBPercona-ServerAliSQLTIDB Mysql URL:www.mysql.comCommunityEnterprise Mariadb URL:mariadb.org MariaDB的特性:插件式存储引擎:存储管理器有多种实现版本,彼此间的功能和特性可能略有区别;用户根据需要灵活选择; 存储引擎也称为\"表类型\"; (1) 更多的存储引擎;MyISAM:不支持事务,表级锁,崩溃后不保证安全恢复;MyISAM --> AriaInnoDB --> XtraDB:支持事务,行级锁,外键,热备;(2) 诸多扩展和新特性;(3) 提供了较多的测试组件;(4) truly open source; 安装和使用MariaDB:安装方式:(1) rpm包;(a) 由OS的发行商提供;(b) 程序官方提供;(2) 源码包;(3) 通用二进制格式程序包; MariaDB程序的组成:C/SC:Client --> mysql protocol --> Servermysql:CLI交互式客户端程序;mysqldump:备份工具;mysqladmin:管理工具;mysqlbinlog:二进制日志;... S:Servermysqldmysqld_safe:建议运行服务器端程序;mysqld_multi:多实例; 三类套接字地址:IPv4 3306/tcpIPv6 3306/tcpUnix Sock(本机进程,本机套接字通信):/var/lib/mysql/mysql.sock,/tmp/mysql.sock:C S:localhost,127.0.0.1 ll /var/lib/mysql/mysql.sock 配置文件:ini风格,用一个文件为多个程序提供配置;[mysql][mysqld][mysqld_safe][server][client][mysqldump]... #配置文件 cat /etc/my.cnf #专门的配置文件存放目录,比如client.cnf用于专门配置客户端,server.cnf专门配置服务端 ls /etc/my.cnf.d/ mysql的各类程序启动都读取不止一个配置文件,按顺序读取,且最后读取的为最终生效; #使用以下命令查看配置文件的默认读取顺序 # Default options are read from the following files in the given order: #/etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf #其中/etc/my.cnf这个配置文件还包含了/etc/my.cnf.d/*.cnf my_print_defaults 命令行交互式客户端程序:mysql mysql [OPTIONS] [database] 常用选项:-u,--user=username:用户名,默认为root;-h,--host=hostname:远程主机(即mysql服务器)地址,默认为localhost;客户端连接服务端,服务器会反解客户的IP为主机名,关闭此功能:skip_name_resolve=ON;-p,--password[=PASSWORD]:USERNAME所表示的用户的密码;默认为空; 注意:mysql的用户账号由两部分组成:'USERNAME'@'HOST';其中HOST用于限制此用户可通过哪些远程主机连接当前的mysql服务;HOST的表示方式,支持使用通配符:%:匹配任意长度的任意字符;172.16.%.%,172.16.0.0/16_:匹配任意单个字符; -P,--port=#:mysql服务器监听的端口;默认为3360/tcp;-S,--socket=/PATH/TO/mysql.sock:套接字文件路径(当前主机内部进程socket通信);-D,--database=DB_name:连接到服务器端之后,设定其处指明的数据库为默认数据库;-e,--execute='SQL STATEMENT;':连接至服务器并让其执行此命令后直接返回; mysql -hlocalhost -uroot -Dmysql -p -e'show tables;' 命令:客户端命令:本地执行 #查看相关客户端命令 help \\u db_name:设定哪个库为默认数据库;\\q:退出;\\d CHAR:设定新的语句结束符;\\g:语句结束标记;\\G:语句结束标记,结果竖排方式显式;\\s:获取当前数据库服务器的状态信息;\\!:执行shell命令;\\.:装载并运行sql脚本; --设定默认数据库 \\u mysql --语句结束符标记 select user,host from user\\g --语句结束标记,结果竖排方式显式 select user,host from user\\G --执行shell命令 \\! ls /var 服务器端命令:通过mysql连接发往服务器执行并取回结果(SQL语句);DDL,DML,DCL 注意:每个语句必须有语句结束符,默认为分号(;)服务端命令获取帮助使用: --查看服务端命令选项 help contents --查看具体选项的服务端命令,比如这里查看所有数据类型 help Data Types 字符集码表:在字符和二进制数字之间建立映射关系; --查看mysql支持的字符集 show character set; --显示mysql支持的排序规则 show collation; 获取命令帮助:help KEYWORD例如: help create database help alter database help drop database help show databases help create table help create index --查看sql结尾的数据库 show databases like '%sql'; --查看数据库所支持的所有存储引擎 show engines; --查看当前数据库所有表的状态 show table status\\G --查看某张表的状态 show table status like 'user'\\G --显示表状态的name字段以help开头的所有表状态信息 show table status where name like 'help%'\\G --显示当前数据库表状态engine='MyISAM'的数据 show table status where engine='MyISAM'\\G --创建表 create table tb1 if not exists(id int unsigned auto_increment,name nvarchar(50),unique key (id)); --查看表结构 describe tbl1 --添加列gender,类型为ENUM alter table tb1 add gender ENUM('F','M'); --将新增字段放在id之后 alter table tb1 add age smallint after id; --修改字段包括字段名将id改为stuid,并且字段的所有属性都得写明 alter table tb1 change id stuid smallint unsigned auto_increment not null; --仅修改字段属性,不包含字段名 alter table tb1 modify name nvarchar(100) not null; --删除字段 alter table tb1 drop gender; --修改表的方式创建索引,使用desc tb1查看在key列看到name字段的值为MUL,这就表示该列允许索引,而且索引项是允许重复的 alter table tb1 add index (name); --查看某表下的索引 show indexes from tb1; --删除Key_name为id的索引 alter table tb1 drop index id; --复制表结构:复制某张表的表结构来创建表.这里复制mysql库下的user表的表结构 create table tb7 like mysql.user; --删除表 drop table if exists tb7; --复制表结构和数据:我们也可以指定某表的几个字段的表结构来创建一个新表,并且会将表数据也一并复制过来 create table tb8 select user,host,password from mysql.user; --创建索引,可以指定索引名称等,这里指定索引名为name_index,指定为表tb8的user字段创建索引,推荐使用这种方式 create index name_index on tb8(user); --查看索引信息 show indexes from tb8; --创建唯一索引,指定user和host组合键索引 create unique index user_host_unique on tb8(user,host); --删除索引 drop index user_host_unique on tb8; --比如我们创建一个已经存在的表,那么就会提示warning信息 create table if not exists tb1(id int unsigned auto_increment,name nvarchar(50),unique key (id)); --我们可以使用show warnings;命令查看上条语句所产生的warning信息 show warnings; --建表 create table if not exists students(stuid int unsigned auto_increment primary key,name nvarchar(20) not null,Gender ENUM('F','M'),birthdate datetime,classid int); --插入多行数据 insert into students (name,gender,birthdate,classid) values ('lisi','M','2019-09-11',1),('wangwu','F','2019-09-11',2); --主键自增列不能重复插入,但是可以替换一行数据 replace into students (stuid,name,gender,birthdate,classid) values (2,'mababa','F','2019-09-11',1); --正则表达式查询,查找name为m开头,任意字符0个或多个结尾的数据 select * from students where name rlike '^m.*$'; --取反 select * from students where name not rlike '^m.*$'; 用户账号及权限管理 用户账号:'username'@'host'host:此用户访问当前mysql服务器时,允许其通过哪些主机远程创建连接;表示方式:IP,网络地址、主机名、通配符(%和_); 禁用检查主机名:my.cnf[mysqld]skip_name_resolve=ON 创建用户账号:create user 'username'@'host' [identity by 'password'] 删除用户账号:drop user 'user'@'host' [,user@host]... 授权:权限级别:管理权限、数据库、表、字段、存储过程;grant priv_type,... ON [object_type] db_name.tbl_name TO 'user'@'host' [identified by 'password']; priv_type:ALL [PRIVLEGES]db_name.tbl_name:.:所有库的所有表;db_name.*:指定库的所有表;db_name.tbl_name:指定库的特定表;db_name.routine_name:指定库上的存储过程或存储函数; [object_type]TABLEFUNCTIONPROCEDURE 查看指定用户所获得的授权:show grants for 'user'@'host';show grants for current_user; 回收权限:revoke priv_type,... on db_name.tbl_name from 'user'@'host'; 注意:MariaDB服务进程启动时,会读取mysql库的所有授权表至内存中;(1) grant或revoke命令等执行的权限操作会保存于表中,MariaDB此时一般会自动重读授权表,权限修改会立即生效;(2) 其它方式实现的权限修改,要想生效,必须手动运行flush privileges命令方可; --在152这台主机上,创建用户名tom,指定只能是192.168.0.0网段能访问,并设置密码 create user 'tom'@'192.168.%.%' identified by '123456'; --删除用户 drop user 'tom'@'192.168.%.%'; --授权'jesse'@'192.168.%.%'这个用户拥有访问mydb这个数据库的所有权限;使用grant这个用户如果不存在,则会自动创建 grant all on mydb.* to 'jesse'@'192.168.%.%' identified by '123456'; --收回mydb.*上的所有表的update,delete权限 revoke update,delete on mydb.* from 'jesse'@'192.168.%.%'; --单独为某个表分配所有权限 grant all on mydb.tb1 to 'jesse'@'192.168.%.%'; --root查看jesse的权限 show grants for 'jesse'@'192.168.%.%'; --如果不立即生效,可以使用以下命令 flush privileges; --在153这台主机上登录,首先要安装客户端 yum install mariadb -y --登录 mysql -h192.168.147.152 -utom -p --使用以下命令发现并没什么权限 show databases; --登录 mysql -h192.168.147.152 -ujesse -p --查看自己的权限 show grants --查看当前登录的用户 select user(); 加固mysql服务器,在安装完成后,运行mysql_secure_installation命令;它会自动让你设置root用户密码,删除匿名用户,删除test数据库,并重载授权表. "},"pages/52.php-fpm基础应用与实战.html":{"url":"pages/52.php-fpm基础应用与实战.html","title":"52.php-fpm基础应用与实战","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 php-fpm: mariadb安装和配置 php-fpm安装和配置 httpd安装和配置 httpd+php结合的方式: module:phpfastcgi:php-fpm php-fpm: CentOS 6:php-5.3.2:默认不支持fpm机制;需要自行打补丁并编译安装;httpd-2.2:默认不支持fcgi协议,需要自行编译此模块;解决方案:编译安装httpd-2.4,php-5.3.3+; CentOS 7:httpd-2.4:rpm包默认编译支持了fcgi模块;php-fpm包:专用于将php运行于fpm模式; CentOS 7: #查看httpd是否有proxy_fcgi_module模块 httpd -M | grep proxy_fcgi_module #查看php-fpm yum info php-fpm mariadb安装和配置 yum install mariadb-server -y 配置vim /etc/my.cnf.d/server.cnf: [mysqld] #跳过名称解析 skip_name_resolve=ON #innodb的每个表,使用单独的表空间文件 innodb_file_per_table=ON #启动服务 systemctl start mariadb.service #设置开机自启动 systemctl enable mariadb.service #查看3306端口 ss -tnlp #安全加强 mysql_secure_installation #登录 mysql -h127.0.0.1 -uroot -p #授权 grant all on testdb.* to 'myuser'@'192.168.%.%' identified by '123456' #刷新特权 flush privileges; #退出 exit; #myuser登录,这时就要使用主机的ip了,不能使用本机的127.0.0.1 mysql -h192.168.147.153 -umyuser -p #创建数据库 create database testdb character set 'utf8'; php-fpm安装和配置 服务配置文件:/etc/php-fpm.conf,/etc/php-fpm.d/.confphp环境配置文件:/etc/php.ini,/etc/php.d/.ini 连接池:pm=static|dynamicstatic:固定数量的子进程;pm.max_children;dynamic:子进程数据以动态模式管理;pm.start_servers:服务启动时的启动的进程数pm.min_spare_servers:最小空闲进程数pm.max_spare_servers:最大空闲进程数pm.max_requests=500:一个子进程最多可以处理多少个请求,超过这里设定的值就销毁重启,如果设置为0,代表不限制 创建session目录,并确保运行php-fpm进程的用户对此目录有读写权限;mkdir /var/lib/php/session -pvchown apache:apache /var/lib/php/session/ 首先保证php和php-fpm未安装,应为php和php-fpm同一个东西,只需安装php-fpm即可; yum info php yum info php-fpm #安装php-fpm、php-mysql(连接数据库模块)、php-mbstring(多字节字符串,比如中文就是多字节的)、php-mcrypt(加解密) yum install php-fpm php-mysql php-mbstring php-mcrypt -y 配置www.conf文件: cd /etc/php-fpm.d/ ls #先备份 cp www.conf{,.bak} ls vim www.conf www.conf文件: ;fpm也有一个状态页,为了不和httpd的冲突,这里修改为pmstatus pm.status_path = /pmstatus ;探测fpm是否是工作进程,去除\";\"号注释;用于服务进程远程健康探测 ping.path = /ping #去除\";\"号注释,ping的默认响应是pong,如果ping出去响应回来是pong代表服务器是正常的; ping.response = pong php的会话保存目录默认是不存在的,配置文件如下,默认值在/var/lib/php/session目录下:我们需要手工创建这个目录,并分配属主属组为apache; #创建session保存目录 mkdir /var/lib/php/session -pv #为什么要apache,应为在www.conf配置文件中属主属组都配置为apache,也就是运行的进程用户就是apache chown apache:apache /var/lib/php/session/ #启动服务 systemctl start php-fpm.service #查看9000端口是否是php-fpm,因为配置文件中配置php-fpm为9000端口 ss -tnlp #可以看到php-fpm默认启用了5个进程,这也是www.conf配置文件中配的 ps aux | grep apache httpd安装和配置 (1) 配置httpd,添加/etc/httpd/conf.d/fcgi.conf配置文件,内容类似:格式: DirectoryIndex index.php #主页支持index.php ProxyRequests Off #关闭正向代理 ProxyPassMatch ^/(.*\\.php)$ fcgi://127.0.0.1:9000/var/www/html/$1 #匹配.php结尾的文件反代到指定的地址和目录 (2) 虚拟主机配置格式: DirectoryIndex index.php ServerName www.b.net DocumentRoot /apps/vhosts/b.net ProxyRequests Off ProxyPassMatch ^/(.*\\.php)$ fcgi://127.0.0.1:9000/apps/vhosts/b.net/$1 Options None AllowOverride None Require all granted 假设fpm的status页面输出URL为/pmstatus,测试接口的输出位置为/pingProxyPassMatch ^/(ping|pmstatus)$ fcgi://127.0.0.1:9000/$1如:http://192.168.147.153/ping、http://192.168.147.153/pmstatus、http://192.168.147.153/pmstatus?full、 http://192.168.147.153/pmstatus?xml&full、http://192.168.147.153/pmstatus?json&full 操作: yum install -y httpd #确保有proxy_fcgi_module模块 httpd -M | grep proxy_fcgi_module #配置 cd /etc/httpd/conf.d/ 配置vim vhosts.conf: DirectoryIndex index.php #这里代表所有虚拟主机都生效,你也可以写到标签里,这样只有这个虚拟主机有效 ServerName www.ilinux.io DocumentRoot \"/data/www/html\" ProxyRequests Off ProxyPassMatch ^/(.*\\.php)$ fcgi://127.0.0.1:9000/data/www/html/$1 ProxyPassMatch ^/(ping|pmstatus)$ fcgi://127.0.0.1:9000/$1 Options None AllowOverride None Require all granted #创建目录 mkdir -pv /data/www/html 创建php文件后,访问即可; "},"pages/53.文件共享服务、ftp、vsftp.html":{"url":"pages/53.文件共享服务、ftp、vsftp.html","title":"53.文件共享服务、ftp、vsftp","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 ftp: vsftpd IO:网络、存储 存储:DAS:Direct Attached Storage接口类型:\"block\"设备:SATA,SAS,IDE,SCSI,USB; NAS:Network Attached Storage接口类型:\"file\"协议:CIFS(samba),NFS(Network File System)RPC:Remote Procedure Call SAN:Storage Area Network接口类型:\"block\"协议:ISCSI(IP-SAN),FCSAN,FCoE,... 应用层:ftp,... 文件服务:ftp,cifs/nfs ftp: ftp:file transfer protocol,文件传输协议;两类连接:命令连接:传输命令数据连接:传输数据两种模式:主动模式:PORTServer:20/tcp连接客户端的命令连接使用的端口向后的第一个可用端口;被动模式:PASVServer:打开一个随机端口,并等待客户端连接 PAM:Pluggable Authenticate Module认证框架:库,高度模块化; 协议:C/SServer:Windows:Serv-U,IIS,Filezilla开源:wuftpd,proftpd,pureftpd,vsftpd(Very Secure FTP daemon),...Client:Windows:ftp,Filezilla,CuteFTP,FlashFXP,...开源:lftp,ftp,Filezilla,gftp,... vsftpd vsftpd is a Very Secure FTP daemon. It was written completely from scratch. URL:SCHEME://username:password@HOST:PORT/PATH/TO/FILE 路径映射:用户家目录:每个用户的URL的'/'映射到当前用户的家目录; vsftpd以ftp用户的身份运行进程,默认用户即为ftp用户,匿名用户的默认路径即ftp用户的家目录/var/ftpftp,anonymous #查看默认用户 grep ^ftp /etc/passwd yum install -y vsftpd systemctl start vsftpd #查看21端口 ss -tnlp #配置文件权限访问权限 cd /etc/vsftpd/ cp vsftpd.conf{,.bak} 另起一台主机 #默认用户,默认没有密码,提示输入口径的话直接回车 lftp 192.168.147.153 -uftp ls #匿名用户登录 lftp 192.168.147.153 anonymous 示例: cp /etc/issue /var/ftp/pub cd /var/ftp/pub #将属主属组改为ftp用户 chown ftp.ftp issue ll 拥有Linux系统的权限并不代表就拥有了对ftp的操作的权限.还需额外配置vsftpd相关配置文件.一个用户通过文件共享服务访问文件系统上的文件的生效权限为此二者的交集; 程序环境:主程序:/usr/sbin/vsftpd主配置文件:/etc/vsftpd/vsftpd.conf数据根目录:/var/ftpSystemd Unit File:/usr/lib/systemd/system/vsftpd.service 配置vsftpd:用户类别:匿名用户:anonymous-->ftp,/var/ftp系统用户:至少禁止系统用户访问ftp服务,/etc/vsftpd/ftpusers,PAM(/etc/pam.d/vsftpd);虚拟用户:非系统用户,用户账号非为可登录操作系统的用户账号(非/etc/passwd); 用户通过vsftpd服务访问到的默认路径,是用户自己的家目录;默认可以自己有权限访问的所有路径间切换;禁锢用户于其家目录中; 配置文件:/etc/vsftpd/vsftpd.confdirective value注意:directive之前不能有多余字符; 匿名用户:anonymous_enable=YESanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YESanon_umask=077 匿名用户的权限掩码 示例,配置匿名用户: cd /var/ftp mkdir upload chown ftp.ftp upload cd /etc/vsftpd 配置vim vsftpd.conf: #允许匿名用户上传 anon_upload_enable=YES #允许匿名用户创建目录 anon_mkdir_write_enable=YES #其他写操作权限,删除等 anon_other_write_enable=YES 重启服务:systemctl restart vsftpd.service 登录ftp操作: lftp 192.168.147.153 -uftp cd upload/ #上传 put /etc/issue #删除目录 rm -rf testdir/ #删除文件 rm issue 系统用户:(以下配置默认都开启)local_enable=YES 是否允许本地用户访问ftp服务write_enable=YES 是否允许本地用户拥有写权限,写权限包括上传、创建目录和其他任何权限local_umask=022 用预设定本地用户创建文件的掩码,所以本地用户创建的文件应该是644,文件666-022=644 示例: #创建用户和设置密码 useradd fedora echo 123456 | passwd --stdin fedora 换台主机登录: #登录 lftp 192.168.147.153 -u fedora mkdir abc cd abc #上传 put /etc/issue #下载文件到/tmp目录下 get issue -o /tmp 辅助配置文件/etc/vsftpd/ftpusers;列在此文件中的用户均禁止使用ftp服务; chroot_local_user=YES禁锢所有本地用户于其家目录;需要事先去除用户对家目录的写权限; chroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_list禁锢列表文件中存在的用户于其家目录中;需要事先去除用户对家目录的写权限; 传输日志:xferlog_enable=YESxferlog_file=/var/log/xferlogxferlog_sdt_format=YES 守护进程的类型:standalone:独立守护进程;由服务进程自行监听套接字,并接收用户访问请求;transient:瞬时守护进程;由受托管方代为监听套接字,服务进程没有访问请求时不启动;当托管方收到访问请求时,才启动服务进程;CentOS 6:xinetd独立守护进程,/etc/xinetd.d/CentOS 7:由systemd代为监听; 控制可登陆vsftpd服务的用户列表:userlist_enable=YES启用/etc/vsftpd/user_list文件来控制可登陆用户;userlist_deny=YES:意味着此为黑名单;NO:白名单; 上传下载速率(单位bytes):annon_max_rate=0 匿名用户的上传下载速率local_max_rate=0 本地用户的上传下载速率0:为不限制 并发连接数限制:max_clinets=2000 客户端最大连接数max_per_ip=50 单ip的最大连接数 "},"pages/54.nfs服务配置应用与实战.html":{"url":"pages/54.nfs服务配置应用与实战.html","title":"54.nfs服务配置应用与实战","keywords":"","body":""},"pages/55.samba服务基础应用.html":{"url":"pages/55.samba服务基础应用.html","title":"55.samba服务基础应用","keywords":"","body":""},"pages/56.iptables.html":{"url":"pages/56.iptables.html","title":"56.iptables","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 iptables/netfilter iptables命令: 匹配条件: 基本匹配条件:无需加载任何模块,由iptables/netfilter自行提供; 扩展匹配条件:需要加载扩展模块,方可生效 隐式扩展:不需要手动加载扩展模块;因为它们是对协议的扩展,所有,但凡使用-p指明了协议,就表示已经指明了要扩展的模块; 显示扩展: 处理动作(跳转目标): 保存和载入规则: 规则优化的思路: iptables:包过滤型的防火墙 Firewall:防火墙,隔离工具;工作于主机或网络边缘,对于进出本主机或本网络的报文根据事先定义的检查规则作匹配检测,对于能够被规则匹配到的报文作出相应处理的组件;主机防火墙网络防火墙 软件防火墙(软件逻辑)硬件防火墙(硬件和软件逻辑) linux防火墙发展:ipfw(firewall framework)ipchains(firewall framework)iptables(netfilter)netfilter:kerneliptables:rules untilnftables hook function:preroutinginputoutputforwardpostrouting 链(内置):PREROUTINGINPUTFORWARDOUTPUTPOSTROUTING 功能:filter:过滤,防火墙;nat:network address translation;用于修改源IP或目标IP,也可以改端口;mangle:拆解报文,做出修改,并重新封装起来;raw:关闭nat表上启用的连接追踪机制; 功能raw:PREROUTING,OUTPUTmangle:PREROUTING,INPUT,FORWARD,OUTPUT,POSTROUTINGnat:PREROUTING,[INPUT,]OUTPUT,POSTROUTINGfilter:INPUT,FORWARD,OUTPUT 报文流向:流入本机:PREROUTING-->INPUT由本机流出:OUTPUT-->POSTROUTING转发:PREROUTING-->FORWARD-->POSTROUTING 路由功能发生的时刻:报文进入本机后:判断目标主机是?报文离开本机之前:判断经由哪个接口送往下一站? iptables/netfilter 规则:组成部分:根据规则匹配条件来尝试匹配报文,一旦匹配成功,就由规则定义的处理动作做出处理;匹配条件:基本匹配条件:内建扩展匹配条件:由扩展模块定义;处理动作:基本处理动作:内建扩展处理动作:由扩展模块定义;自定义处理机制:自定义链 iptables的链:内置链和自定义链内置链:对应于hook function自定义链接:用于内置链的扩展和补充,可实现更灵活的规则管理机制; 添加规则时的考量点:(1) 要实现那种功能:判断添加到哪个表上;(2) 报文流经的路径:判断添加到哪个链上; 链:链上的规则次序,即为检查的次序;因此,隐含一定的应用法则:(1) 同类规则(访问同一应用),匹配范围小的放上面;(2) 不同类的规则(访问不同应用),匹配到报文频率较大的放在上面;(3) 将那些可由一条规则描述的多个规则合并起来;(4) 设置默认策略; iptables命令: /usr/lib64/xtables/IPv6:libip6tIPv4:libipt,libxt_ #查看iptables的模块 rpm -ql iptables iptables [-t table] {-A|-C|-D} chain rule-specification iptables [-t table] -I chain [rulenum] rule-specification iptables [-t table] -R chain rulenum rule-specification iptables [-t table] -D chain rulenum iptables [-t table] -S [chain [rulenum]] iptables [-t table] {-F|-L|-Z} [chain [rulenum]] [options...] iptables [-t table] -N chain iptables [-t table] -X [chain] iptables [-t table] -P chain target iptables [-t table] -E old-chain-name new-chain-name rule-specification=[matches...] [target] match=-m matchname [per-match-options] target=-j targetname [per-target-options] 规则格式:iptables [-t table] COMMAND [chain] [PARAMETERS] [-m matchname [per-match-options]] -j targetname [per-target-options] -t table:raw,mangle,nat,[filter] COMMAND:链管理:-N:new,自定义一条新的规则链;-X:delete,删除自定义的规则链;注意:仅能删除用户自定义的引用计数为0的且空的链(没有规则的链);-P:Policy,设置默认策略;对filter表中的链而言,其默认策略有:ACCEPT:接受DROP:丢弃REJECT:拒绝-E:重命名自定义链;引用计数不为0的自定义链不能够被重命名,也不能被删除; 规则管理:-A:append,追加;-I:insert,插入,要指明位置,省略时表示第一条;-D:delete,删除;(1) 指明规则序号;(2) 指明规则本身;-R:replace,替换指定链上的指定规则; -F:flush,清空指定的规则链;-Z:zero,置零;iptables的每条规则都有两个计数器:(1) 匹配到的报文的个数;(2) 匹配到的所有报文的大小之和; 查看:-L:list,列出指定键上的所有规则;-n:numberic,以数字格式显示地址和端口号;-v:verbose,详细信息;-vv,-vvv:更详细和更更详细信息;-x:exactly,显示计数器结果的精确值;-line-numbers:显示规则的序号; chain:PREROUTING,INPUT,FORWARD,OUTPUT,POSTROUTING #两个命令结果是一样的,没有指定-t table,默认就是-t filter #查看filter表 iptables -L iptables -t filter -L #查看mangle表 iptables -t mangle -L #查看nat表 iptables -t nat -L #查看raw表 iptables -t raw -L #查看iptables规则 iptable -vnL #带计数器 iptables -n -L -v --line-numbers #-L需要单独写或者放最后 iptables -vnx -L iptables -vnL #只看INPUT链 iptables -vnL INPUT #创建自定义规则链,名为in_web_rules iptables -N in_web_rules #删除自定义规则链 iptables -X in_web_rules #修改FORWARD链默认策略为DROP iptables -P FORWARD DROP #改回FORWARD为ACCEPT iptables -P FORWARD ACCEPT #创建自定义链 iptables -N in_web #将自定义链名in_web改为in_wap iptables -E in_web in_wap #为INPUT_ZONES链的所有规则计数置0 iptables -Z INPUT_ZONES #如果不指定链,表示指定表的所有规则计数置0 iptables -Z #指定INPUT_ZONES链的第一条规则计数置0 iptables -Z INPUT_ZONES 1 #清除IN_public链上的所有规则 iptables -F IN_public #清除该表所有规则 iptables -F #查看FORWARD链规则 iptables -vnL FORWARD --line-number #删除FORWARD链第一条规则 iptables -D FORWARD 1 匹配条件: 基本匹配条件:无需加载任何模块,由iptables/netfilter自行提供; [!] -s,--source address[/mask][,...]:检查报文中的源IP地址是否符合此处指定的地址或范围;[!] -d,--destination address[/mask][,...]:检查报文中的目标IP地址是否符合此处指定的地址或范围;所有地址:0.0.0.0/0[!] -p,--protocol protocolprotocol:tcp,udp,udplite,icmp,icmpv6,esp,ah,sctp,mh or \"all\"{tcp|upd|icmp}[!] -i,--in-interface name:流入网卡,数据报文流入的接口;只能应用于数据报文流入环节,只能应用于PREROUTING,INPUT和FORWARD链;[!] -o,--out-interface name:流出网卡,数据报文流出的接口;只能应用于数据报文流出的环节,只能应用于FORWARD,OUTPUT和POSTROUTING链; #filter表的INPUT链中允许来自于192.168.147.0网络访问本机地址的tcp协议的服务 iptables -t filter -A INPUT -s 192.168.147.0/24 -d 192.168.147.153 -p tcp -j ACCEPT #filter表的OUTPUT链中允许本机访问或响应192.168.0.0网络的tcp协议的服务 iptables -A OUTPUT -s 192.168.147.153 -d 192.168.147.0/24 -p tcp -j ACCEPT #现在我们就可以将策略设置为DROP了,因为以上规则能放行ssh服务,就不会被默认规则所拒绝 iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP #允许任何人ping,这里省略了-s:代表所有主机,现在可以进来,但不能响应 iptables -A INPUT -d 192.168.147.153 -p icmp -j ACCEPT #使用tcpdump,抓icmp的包 tcpdump -i ens33 -nn icmp #因此想要响应,需要加入一条OUTPUT规则,省略-d:代表所有主机 iptables -A OUTPUT -s 192.168.147.153 -p icmp -j ACCEPT #抓包ping查看,这时就可以看到进来和响应了 tcpdump -i ens33 -nn icmp 扩展匹配条件:需要加载扩展模块,方可生效 隐式扩展:在使用-p选项指明了特定的协议时,无需再同时使用-m选项指明扩展模块的扩展机制;显示扩展:必须使用-m选项指明要调用的扩展模块的扩展机制; 隐式扩展:不需要手动加载扩展模块;因为它们是对协议的扩展,所有,但凡使用-p指明了协议,就表示已经指明了要扩展的模块; tcp:[!] --source-port,--sport port[:port]:匹配报文的源端口;可以是端口范围;[!] --destination-port,--dport port[:port]:匹配报文的目标端口;可以是端口范围;[!] --tcp-flags mask compmask is the flags which web should examine,written as a comma-separated list,例如SYN,ACK,FIN,RSTcomp is a comma-separated list of flags which must be set,例如SYN例如:\"--tcp-flags SYN,ACK,FIN,RST SYN\"表示,要检查的标志位为SYN,ACK,FIN,RST四个,其中SYN必须为1,余下的必须为0;[!] --syn:用于匹配第一次握手,相当于\"--tcp-flags SYN,ACK,FIN,RST SYN\"; udp[!] --source-port,--sport port[:port]:匹配报文的源端口;可以是端口范围;[!] --destination-port,--dport port[:port]:匹配报文的目标端口;可以是端口范围; icmp[!] --icmp-type {type[/code]|typename}echo-request:8echo-reply:0 #入站 #设置允许192.168.147.0网络允许访问本机的22端口;-I默认会插入到规则列表中的第一条 iptables -I INPUT -s 192.168.147.0/24 -d 192.168.147.153 -p tcp --dport 22 -j ACCEPT #出站 #设置允许192.168.147.153主机的22号端口允许访问或响应192.168.147.0网络;-I默认会插入到规则列表中的第一条 iptables -I OUTPUT -s 192.168.147.153 -d 192.168.147.0/24 -p tcp --sport 22 -j ACCEPT #删除之前创建的规则:允许tcp协议且能访问所有端口的规则,例子中位于第二条,所以删除序号为2;出站和入站全部删除 iptables -D INPUT 2 iptables -D OUTPUT 2 由于我们之前设置filter表的所有链的默认策略是DROP,万一不小心输入了iptables -F清空了规则,就会造成无法登陆到这台主机.所以一般我们都会将默认策略修改为ACCEPT,而后给入站和出站添加拒绝所有访问的规则. #设置入站拒绝所有访问 iptables -A INPUT -d 192.168.147.153 -j DROP #设置出站拒绝所有响应 iptables -A OUTPUT -s 192.168.147.153 -j DROP #将之前的策略改为ACCEPT iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT 还可以设置网卡的方式来拒绝所有访问和响应;和上面的方法选其一即可: iptables -A INPUT -i ens33 -j DROP iptables -A OUTPUT -o ens33 -j DROP 设置icmp #允许自己ping出去,插入到OUTPUT链第二条 iptables -I OUTPUT 2 -s 192.168.147.153 -p icmp --icmp-type 8 -j ACCEPT #允许自己接收ping iptables -I INPUT 2 -d 192.168.147.153 -p icmp --icmp-type 0 -j ACCEPT ping 192.168.147.152 #在152主机抓icmp包 tcpdump -i ens33 -nn icmp 开放137-138的udp端口 iptables -A INPUT -d 192.168.147.153 -p udp --dport 137:138 -j ACCEPT iptables -A OUTPUT -s 192.168.147.153 -p udp --dport 137:138 -j ACCEPT 显示扩展: 必须手动加载扩展模块,使用-m选项指明要调用的扩展模块,[-m matchname [per-match-options]]1、multiport以离散或连续的方式定义多端口匹配条件,最多15个;[!] --source-ports,--sports port[,port|port:port]...:指定多个源端口;[!] --destination-ports,--dports port[,port|,port:port]...:指定多个目标端口; #替换开放22端口的规则为开放22,80,139,445端口 iptables -R INPUT 1 -d 192.168.147.153 -p tcp -m multiport --dport 22,80,139,445 -j ACCEPT iptables -R OUTPUT 1 -s 192.168.147.153 -p tcp -m multiport --sport 22,80,139,445 -j ACCEPT 2、iprange以连续地址块的方式来指明多IP地址匹配条件;[!] --src-range from[-to][!] --dst-range from[-to] 创建用户 useradd centos echo 123456 | passwd --stdin centos yum install -y telnet-server systemctl start telnet.socket #查看23端口是否存在 ss -tnlp | grep 23 #允许指定ip范围访问23端口 iptables -I INPUT 3 -d 192.168.147.153 -p tcp --dport 23 -m iprange --src-range 192.168.147.150-192.168.147.200 -j ACCEPT iptables -I OUTPUT 3 -s 192.168.147.153 -p tcp --sport 23 -m iprange --dst-range 192.168.147.150-192.168.147.200 -j ACCEPT 到152主机测试: #先安装客户端 yum -y install telnet #用之前创建的centos登录 telnet 192.168.147.153 3、time匹配什么时间能访问,什么时间不能访问--timestart hh:mm[:ss] 开始时间--timestop hh:mm[:ss] 结束时间[!] --weekdays day[,day...] 周几[!] --monthdays day[,day...] 每月的几号 --datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]] 开始日期时间--datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]] 结束日期时间 --kerneltz:使用内核配置的时区而非默认的UTC; 修改之前23端口规则增加时间规则: iptables -R INPUT 3 -d 192.168.147.153 -p tcp --dport 23 -m iprange --src-range 192.168.147.150-192.168.147.200 -m time --weekdays 1,2,3,4,5 --timestart 10:00 --timestop 18:00 --kerneltz -j ACCEPT iptables -R OUTPUT 3 -s 192.168.147.153 -p tcp --sport 23 -m iprange --dst-range 192.168.147.150-192.168.147.200 -m time --weekdays 1,2,3,4,5 --timestart 10:00 --timestop 18:00 --kerneltz -j ACCEPT 4.string对请求的报文中包含的字符串匹配 --algo {bm|kmp}[!] --string pattern[!] --hex-string pattern --from offset--to offset #无论是哪个协议,只要包含gay的报文都拒绝响应 iptables -I OUTPUT -s 192.168.147.153 -m string --algo kmp --string \"gay\" -j REJECT 5、connlimit客户端ip允许连接服务器的连接数--connlimit-upto n 连接的上线,小于等于n是开放的,否则拒绝;默认规则是白名单使用--connlimit-above n 大于n拒绝;默认规则是黑名单使用 #先开放3306端口 iptables -I INPUT 2 -s 192.168.147.0/24 -d 192.168.147.153 -p tcp --dport 3306 -j ACCEPT iptables -I OUTPUT 2 -d 192.168.147.0/24 -s 192.168.147.153 -p tcp --sport 3306 -j ACCEPT #替换并限制连接数,只需限制入站即可 iptables -I INPUT 2 -s 192.168.147.0/24 -d 192.168.147.153 -p tcp --dport 3306 -m connlimit --connlimit-upto 2 -j ACCEPT 6、limitThis module matches at a limited rate using a token bucket filter.令牌桶算法限速--limit rate[/second|/minute|/hour|/day] 指令速率,比如每秒多少个包--limit-burst number 令牌桶最多能够收集多少个令牌 #限制3秒钟只能发一个ping包,入站做限制 iptables -I INPUT 3 -d 192.168.147.153 -p icmp --icmp-type 8 -m limit --limit-burst 5 --limit 20/minute -j ACCEPT #出站就不做限制了 iptables -I OUTPUT 3 -s 192.168.147.153 -p icmp --icmp-type 0 -j ACCEPT 然后就可以用ping去测试了. 限制本机某tcp服务接收新请求的速率:--syn,-m limit 7、state基于连接追踪功能去查看每一报文当前所处的状态. [!] --state stateINVALID,ESTABLISHED,NEW,RELATED or UNTRACKED. NEW:新连接请求;ESTABLISHED:已建立的连接;INVALID:无法识别的连接;RELATED:相关联的连接,当前连接是一个新请求,但附属于某个已存在的连接;UNTRACKED:未追踪的连接; state扩展:内核模块装载:nf_conntracknt_conntrack_ipv4 手工装载:nf_conntrack_ftp 追踪到的连接:/proc/net/nf_conntrack 调整可记录的连接数量最大值:/proc/sys/net/nf_conntrack_max 超时时长:/proc/sys/net/netfilter/*timeout* #清空规则 iptables -F #开放端口和允许的状态 iptables -A INPUT -d 192.168.147.153 -p tcp -m multiport --dport 22:23,80,139,445,3306 -m state --state NEW -j ACCEPT iptables -I INPUT 1 -d 192.168.147.153 -m state --state ESTABLISHED -j ACCEPT iptables -A OUTPUT -s 192.168.147.153 -m state --state ESTABLISHED -j ACCEPT #创建138:139端口支持udp iptables -I INPUT 2 -d 192.168.147.153 -p udp --dport 137:138 -m state --state NEW -j ACCEPT #设置拒绝所有 iptables -A INPUT -d 192.168.147.153 -j REJECT iptables -A OUTPUT -s 192.168.147.153 -j REJECT #同步时间服务器,本机是客户端,时间服务器是服务器;所以服务器端口是123,323,本机是任意端口,省略不写 iptables -I OUTPUT 2 -s 192.168.147.153 -p udp -m multiport --dport 123,323 -m state --state NEW -j ACCEPT #使用阿里云时间同步服务器测试 ntpdate 120.25.115.20 要追踪RELATED状态的连接,需要装载内核模块:nf_conntrack_ftp: #查看内核模块信息 modinfo nf_conntrack_ftp #装载模块 modprobe nf_conntrack_ftp #查看是否装载了该模块 lsmod | grep nf_conntrack_ftp #改造规则支持21号端口,支持ftp iptables -R INPUT 3 -d 192.168.147.153 -p tcp -m multiport --dport 21:23,80,139,445,3306 -m state --state NEW -j ACCEPT #由于21端口用于处理ftp指令,传输数据会生成随机端口,这里需要加入允许RELATED状态连接,也就是与21端口关联的状态连接允许访问 iptables -R INPUT 1 -d 192.168.147.153 -m state --state ESTABLISHED,RELATED -j ACCEPT 另起一台主机测试ftp: #安装ftp yum install -y ftp ftp 192.168.147.153 处理动作(跳转目标): -j targetname [per-target-options]简单target:ACCEPT,DROP 扩展target:REJECT--reject-with typeType可以是icmp-net-unreachable、icmp-host-unreachable、icmp-port-nreachable、icmp-prot o-unreachable、 icmp-net-prohibited 或者 icmp-host-prohibited,该类型会返回相应的ICMP错误信息(默认是port-unreachable) LOGTurn on kernel logging of matching packets.--log-level--log-prefix RETURN返回调用者; 默认日志保存于/var/log/messages #连接状态为NEW的且为23端口加入日志,并加入日前缀,注,此规则要加载开放23端口规则之前 iptables -I INPUT 3 -d 192.168.147.153 -p tcp --dport 23 -m state --state NEW -j LOG --log-prefix \"access telnet \" #另起客户端telnet后,查看日志 grep -i \"access telnet\" /var/log/messages 自定义链作为target: #添加自定义链in_ping_rules iptables -N in_ping_rules #允许ping主机153 iptables -A in_ping_rules -d 192.168.147.153 -p icmp --icmp-type 8 -j ACCEPT #拒绝139主机ping操作 iptables -I in_ping_rules -d 192.168.147.153 -s 192.168.147.139 -p icmp -j REJECT #将自定义链加入到INPUT链中 iptables -I INPUT 5 -d 192.168.147.153 -p icmp -j in_ping_rules #删除自定义链,删除自定义链的引用,再清空自定义链规则,最后删除自定义链,否则无法删除 #删除自定义链的引用 iptables -D INPUT 5 #再清空自定义链规则 iptables -F in_ping_rules #删除自定义链 iptables -X in_ping_rules 保存和载入规则: 保存:iptables-save > /PATH/TO/SOME_RULE_FILE重载:iptables-restore -n,--noflush:不清除原有规则-t,--test:仅分析生成规则集,但不提交 #将iptables规则保存到文件 iptables-save > /etc/sysconfig/iptables-20190923-v1 #这时清空也没关系,可以重载 iptables -F #重载 iptables-restore CentOS 6:保存规则:service iptables save保存规则于/etc/sysconfig/iptables文件,覆盖保存;重载规则:service iptables restart默认重载/etc/sysconfig/iptables-config CentOS 7:(1) 自定义Unit File,进行iptable-restore;(2) firewalld服务;(3) 自定义脚本; 规则优化的思路: 使用自定义链管理特定应用的相关规则,模块化管理规则; (1) 优先放行双方向状态为ESTABLISHED的报文;(2) 服务于不同类别的功能的规则,匹配到报文可能性更大的放前面;(3) 服务于同一类别的功能的规则,匹配条件较严格的放在前面;(4) 设置默认策略:白名单机制(a) iptables -P,不建议;(b) 建议在规则的最后定义规则作为默认策略; "},"pages/57.iptables网络防火墙.html":{"url":"pages/57.iptables网络防火墙.html","title":"57.iptables网络防火墙","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 网络防火墙主机 网络防火墙局域网内的主机 客户端主机 ping测试 iptables网络防火墙 网络防火墙主机 我们以192.168.147.139作为网络防火墙为它添加一块新的网卡: 输入命令ifconfig可以看到新的网卡ens34使用nmtui配置新网卡,将新网卡地址修改为10.10.0.254/16: #重启 systemctl restart network #查看ip ifconfig #先清空防火墙规则 iptables -F #禁用firewalld systemctl stop firewalld #禁止开启自启动 systemctl disable firewalld #查看核心转发是否打开 cat /proc/sys/net/ipv4/ip_forward #打开核心转发 sysctl -w net.ipv4.ip_forward=1 设置规则: #设置FORWARD链拒绝所有 iptables -A FORWARD -j REJECT #开放内网主机允许访问外网的任意主机 iptables -I FORWARD -s 10.10.0.0/16 -p tcp --dport 80 -j ACCEPT #开放内网主机允许响应外网任意主机 iptables -I FORWARD 2 -d 10.10.0.0/16 -p tcp --sport 80 -j ACCEPT 每个服务都按端口来加规则太痛苦了,我们可以使用状态机制: #删除之前添加的2条 iptables -D FORWARD 1 iptables -D FORWARD 1 #无论从源和目标是哪到哪只要状态是ESTABLISH全部放行(对所有已建立连接的请求和响应报文放行) iptables -I FORWARD -m state --state ESTABLISH -j ACCEPT #开放10.10.0.0/16网段可以访问任意防火墙内主机的服务 iptables -I FORWARD 2 -s 10.10.0.0/16 -m state --state NEW -j ACCEPT #开放192.168.147.153能够访问10.10.0.52的80端口的web服务 iptables -I FORWARD 3 -d 10.10.0.52 -p tcp --dport 80 -m state --state NEW -j ACCEPT #替换之前80端口的规则 iptables -R FORWARD 3 -d 10.10.0.52 -p tcp -m multiport --dports 21:23,80,139,445 -m state --state NEW -j ACCEPT #开放138,139的udp端口 iptables -I FORWARD 4 -d 10.10.0.52 -p udp --dport 137:138 -m state --state NEW -j ACCEPT #开放RELATED状态之前,先装载模块 modprobe nf_conntrack_ftp #检查模块 lsmod | grep nf_conntrack_ftp #开放RELATED状态 iptables -I FORWARD 5 -d 10.10.0.52 -p tcp -m state --state RELATED -j ACCEPT 网络防火墙局域网内的主机 这里以192.168.147.153为例 #安装相关服务 yum install httpd vsftpd samba telnet-server -y #添加路由,访问10.10.0.0/16网段的时候,下一跳为192.168.147.139 route add -net 10.10.0.0/16 gw 192.168.147.139 #查看 route -n 客户端主机 将192.168.147.152这台主机ip改为10.10.0.52/16,使用nmtui配置: #重启 systemctl restart network #查看ip ifconfig #ping网络防火墙其中的一块通网段ip的网卡是否通 ping 10.10.0.254 #添加默认路由的吓一跳为10.10.0.254 route add default gw 10.10.0.254 #查看,如果没有错误提示,也没有添加进默认路由,可以使用以下\"注意\"的方法解决 route -n 客户机也安装相应服务,用于做服务端访问客户端服务示例: yum install httpd vsftpd samba telnet-server -y systemctl start httpd systemctl start vsftpd.service systemctl start telnet.socket systemctl start nmb.service smb.service ss -tnlp ss -unlp 注意,如果默认路由添加不上:解决方法1: #检查networkmanager的版本,1.8版本存在BUG,无法添加默认路由,在1.10版本修复 rpm -qa | grep Network #如果低于1.10版本,可以升级NetworkManager来解决这个问题。 yum update NetworkManager-tui yum update NetworkManager-wifi yum update NetworkManager yum update NetworkManager-team yum update NetworkManager-libnm #查看升级后的版本 rpm -qa | grep Network 解决方法2: 可以修改网络配置文件/etc/sysconfig/network-scripts/ifcfg-eth0，添加一行NM_CONTROLLED=no来解决. ping测试 #想在以上三台哪台主机抓包,可以使用以下命令 tcpdump -i ens33 -nn icmp #抓tcp的80端口的包 tcpdump -i ens34 -nn tcp port 80 "},"pages/58.iptables_nat路由.html":{"url":"pages/58.iptables_nat路由.html","title":"58.iptables_nat路由","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 SNAT 网关 NAT:Network Address Translation 请求报文:由管理员定义;响应报文:由NAT的conntrack机制自动实现; 请求报文:改源地址:SNAT,MASQUERADE改目标地址:DNAT iptables/netfilter:NAT定义在nat表;PREROUTING,INPUT,OUTPUT,POSTROUTING SNAT:POSTROUTINGDNAT:PREROUTINGPAT: SNAT 网关 这里以两个网卡的ip:192.168.147.139,10.10.0.154这台主机为例: #清空之前的FORWORD链规则 iptables -F FORWARD #查看 iptables -vnL #查看NAT链规则 iptables -vnL -t nat #SNAT,将10.10.0.0/16网络请求出去的ip改为192.168.147.139,在192.168.147.153上用tcpdump抓包查看 iptables -t nat -A POSTROUTING -s 10.10.0.0/16 -j SNAT --to-source 192.168.147.139 #假设我们访问外网的公网ip经常变(比如adsl拨号上网),就不能使用--to-source #MASQUERADE:SNAT场景中应用于POSTROUTING链上的规则实现源地址转换,但外网地址不固定时,使用此target tcpdump测试： tcpdump -i ens33 -nn tcp port 80 "},"pages/59.Linux时间服务-chrony.html":{"url":"pages/59.Linux时间服务-chrony.html","title":"59.Linux时间服务-chrony","keywords":"","body":"Chrony 早期的时间服务:NTP(network time protocal) Chrony是网络时间协议的(NTP)的另一种实现,与网络时间协议后台程序(ntpd)不同,它可以更快地且更准确地同步系统时钟.请注意,ntpd仍然包含其中以供需要运行NTP服务的客户使用. Chrony的优势包括: 更快的同步只需要数分钟而非数小时时间,从而最大程度减少了时间和频率误差,这对于并非全天24小时运行的台式计算机或系统而言非常有用. 能够更好地响应时钟频率的快速变化,这对于具备不稳定时钟的虚拟机或导致时钟频率发生变化的节能技术而言非常有用. 在初始同步后,它不会停止时钟,以防对需要系统时间保持单调的应用程序造成影响. 在应对临时非对称延迟时(例如,在大规模下载造成链接饱和时)提供了更好的稳定性. 无需对服务器进行定期轮询,因此具备间歇性网络连接的系统仍然可以快速同步时钟. CentOS 7为例作为客户端: #查看是否安装 yum info chrony #查看安装生成的文件 rpm -ql chrony 修改配置vim /etc/chrony.conf: #server 0.centos.pool.ntp.org iburst #server 1.centos.pool.ntp.org iburst #server 2.centos.pool.ntp.org iburst #server 3.centos.pool.ntp.org iburst #指定时间服务器 server 192.168.147.139 iburst 重启服务:systemctl start chronyd.service查看状态:systemctl status chronyd.service CentOS 7为例作为服务器:修改配置vim /etc/chrony.conf: # Allow NTP client access from local network. #允许的网段 allow 192.168.147.0/24 # Serve time even if not synchronized to a time source. #即使当前时间服务器没有和任何ntp服务器同步,那么我们依然给我们的客户端提供时间服务(这个配置按自身需要开启) local stratum 10 重启服务:systemctl restart chronyd.service 另开一台主机,做时间同步: #ntpdate是强行调时间方式,中间会有时间空白,推荐修改配置文件 ntpdate 192.168.147.153 修改配置vim /etc/chrony.conf: #server 0.centos.pool.ntp.org iburst #server 1.centos.pool.ntp.org iburst #server 2.centos.pool.ntp.org iburst #server 3.centos.pool.ntp.org iburst server 192.168.147.153 iburst 重启服务:systemctl restart chronyd.service #进入交互式 chronyc #查看连接到哪些服务器上 sources #时间同步正常与否 sourcestats #退出 exit #非交互式指令 chronyc sources #还能查看详细信息 chronyc sources -v #时间同步正常与否 chronyc sourcestats #查看帮助 man chronyc "},"pages/GitLab安装_CentOS7.html":{"url":"pages/GitLab安装_CentOS7.html","title":"GitLab安装_CentOS7","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Postfix安装和设置默认开机自启动和启动 gitlab-ce下载地址 安装(最新版本太大了,找了个300mb+的版本,而且起码要给虚拟机分配6g内存) 修改配置文件 gitlab汉化包下载 gitlab汉化 默认端口修改 GitLab依赖安装 sudo yum install -y curl policycoreutils-python openssh-server sudo systemctl enable sshd sudo systemctl start sshd sudo firewall-cmd --permanent --add-service=http sudo systemctl reload firewalld Postfix安装和设置默认开机自启动和启动 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix gitlab-ce下载地址 https://packages.gitlab.com/gitlab/gitlab-ce 安装(最新版本太大了,找了个300mb+的版本,而且起码要给虚拟机分配6g内存) rpm -ivh gitlab-ce-10.2.3-ce.0.el7.x86_64.rpm 修改配置文件 vim /etc/gitlab/gitlab.rb 在配置文件里将external_url 'http://gitlab.example.com' 修改为你的ip或者域名地址 external_url 'http://192.168.147.139' 配置完后执行gitlab-ctl reconfigure让你修改的配置生效,gitlab会重启它的服务 gitlab汉化包下载 https://gitlab.com/xhang gitlab汉化 # 汉化前先关闭gitlab服务 gitlab-ctl stop # 解压: tar -xzvf gitlab-patch-zh.tat.gz # 查看汉化补丁版本 cat /root/gitlab/VERSION # 切换到 gitlab 汉化包所在的目录 cd /root/gitlab # 比较汉化标签和原标签，导出 patch 用的 diff 文件到/root 下 git diff v10.2.3 v10.2.3-zh > ../10.2.3-zh.diff # 将 10.2.3-zh.diff 作为补丁更新到 gitlab 中 patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 默认端口修改 由于默认gitlab使用80端口，所以，我们需要修改gitlab的默认端口 修改 /etc/gitlab/gitlab.rb 文件如下，然后执行重新配置，重启命令后完成。 gitlab-ctl reconfigure //让配置生效，重新执行此命令时间也比较长 gitlab-ctl restart 端口要用9090以后的最好，否则不生效 默认情况下：unicorn会占用8080端口，nginx会占用80端口。改完之后，就可以通过nginx[‘listen_port’] 在浏览器进行访问了。 内部8080端口也不再被占用了。 这样修改了默认端口80后，在idea中获取代码时，要在路径后面加上修改的端口号才可以访问到代码以上是按照gitlab的全过程。 我的改法: "},"pages/JDK安装.html":{"url":"pages/JDK安装.html","title":"JDK安装","keywords":"","body":"查看并卸载已安装的JDK rpm -qa|grep java #卸载 #rpm -e --nodeps xxxx 图中可以看到系统自带的OpenJDK的版本等相关信息。下面我们进行卸载，使用 rpm -e --nodeps命令进行卸载，如下图所示： tar -zxvf jdk-8u251-linux-x64.tar.gz mkdir /usr/local/jdk -p mv jdk1.8.0_251 /usr/local/jdk #环境变量 vim /etc/profile export JAVA_HOME=/usr/local/jdk export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin #使环境变量生效 source /etc/profile #测试 java javac java -version "},"pages/Linux中kill -2和kill -9的区别.html":{"url":"pages/Linux中kill -2和kill -9的区别.html","title":"Linux中kill -2和kill -9的区别","keywords":"","body":"在Linux中用Kill-2和Kill-9都能够结束进程,他们之间的区别为: Kill-2:功能类似于Ctrl+C是程序在结束之前,能够保存相关数据,然后再退出。Kill-9:直接强制结束程序。在用nohup挂起程序时,当想要结束这个程序,最好用kill-2。能够模拟在控制台结束程序的功能。 "},"pages/linux中修改环境变量及生效方法.html":{"url":"pages/linux中修改环境变量及生效方法.html","title":"linux中修改环境变量及生效方法","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 方法二： 方法三： 方法一： 在/etc/profile文件中添加变量【对所有用户生效(永久的)】 用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 要让刚才的修改马上生效，需要执行以下代码 source /etc/profile vim /etc/profile,加入文件的末尾: #设置环境变量 export ASPNETCORE_ENVIRONMENT=Production #设置可执行文件路径(PATH) #JDK1.8 export JAVA_HOME=/usr/jdk1.8.0_211 export PATH=$PATH:$JAVA_HOME/bin #mongodb4.0.9 export MONGODB_HOME=/usr/local/mongodb4.0.9 export PATH=$PATH:$MONGODB_HOME/bin #打印PATH echo $PATH 最后记得source /etc/profile使刚才的配置生效 方法二： 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】 用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 要让刚才的修改马上生效，需要在用户目录下执行以下代码 source .bash_profile 方法三： 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】 在shell的命令行下直接使用[export变量名=变量值]定义变量，该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。 例如：export PATH=/usr/local/webserver/php/bin:$PATH #临时的环境变量 export asp=123 echo $asp #列出所有环境变量 export "},"pages/Linux查看设置系统时区.html":{"url":"pages/Linux查看设置系统时区.html","title":"Linux查看设置系统时区","keywords":"","body":" 关于时区的概念，其实初中地理课已经涉及，很多人都多少了解一些，可能只是细节搞不太清楚。为什么会将地球分为不同时区呢？因为地球总是自西向东自转，东边总比西边先看到太阳，东边的时间也总比西边的早。东边时刻与西边时刻的差值不仅要以时计，而且还要以分和秒来计算。整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。 关于时间的几个标准，如下所示，具体可以Google、Baidu搜索一下。 CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。 UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。 GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 关于时区分布图，大家可以参考http://www.timedate.cn/time/timezone.htm，我们国家跨越了东五区、东六区、东七区、东八区、东九区五个时区，一般都统一采用东八区计时时间。 Linux系统如何查看设置所在的时区呢？ 1：使用date命令查看时区 [root@db-server ~]# date -R Sun, 11 Jan 2015 07:10:28 -0800 [root@db-server ~]# 如上RFC 2822 format所示，上面命令输出了-0800表示西八区，是美国旧金山所在的时区，下面表示我们国家的东八区（+0800） [root@lnx01 ~]# date -R Sun, 11 Jan 2015 23:06:02 +0800 修改时区| Centos6 | Centos7(Mininal,ECS) | |---|---| | cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime | timedatectl | Centos6、7都适用 #先备份时区文件 cd /etc cp localtime localtime_bak #\\cp 覆盖不提示 \\cp /usr/share/zoneinfo/Asia/Tokyo /etc/localtime #(这里用的东京的时区,东9区) [root@manager etc]# date -R Thu, 04 Feb 2021 13:45:29 +0900 #改回东8区 \\cp localtime_bak localtime date -R #也可以做软链接改变时区,这里的-f代表如果文件存在则覆盖 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime Centos7 [root@manager etc]# timedatectl Local time: 四 2021-02-04 12:49:16 CST #本地时间 Universal time: 四 2021-02-04 04:49:16 UTC #世界时间 RTC time: 四 2021-02-04 12:49:16 #主板时间 Time zone: n/a (CST, +0800) #时区 NTP enabled: yes #是否开启NTP时间同步服务 NTP synchronized: yes #是否开启NTP时间同步 RTC in local TZ: yes #主板时间是否和本地时间保持一致 DST active: n/a #设置东京时区 timedatectl set-timezone Asia/Tokyo #查看 timedatectl date -R #调整回来 timedatectl set-timezone Asia/Shanghai #将主板时间和你本地时间保持一致 timedatectl set-local-rtc 1 #关闭将主板时间和你本地时间保持一致 timedatectl set-local-rtc 0 #列出支持的时区 timedatectl list-timezones "},"pages/rc.local脚本开机自启动.html":{"url":"pages/rc.local脚本开机自启动.html","title":"rc.local脚本开机自启动","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1、/etc/rc.local是/etc/rc.d/rc.local的软链接 2、rc.local文件的原始内容 It is highly advisable to create own systemd services or udev rules In contrast to previous versions due to parallel execution during boot Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure touch /var/lock/subsys/local 3、rc.local文件的配置 4、应用经验 在CentOS7中，实现开机启动程序主要有两种方法： 1）把要启动的程序配置成自定义的系统服务，该方法我已经介绍过，请阅读：CentOS7添加自定义系统服务。 2）在/etc/rc.local脚本文件中编写启动程序的脚本，本文将详细介绍这种方法。 1、/etc/rc.local是/etc/rc.d/rc.local的软链接 执行ls -l /etc/rc.local看看。/etc/rc.local是/etc/rc.d/rc.local文件的软链接，也就是说他们是同一个文件。 2、rc.local文件的原始内容 #!/bin/bash # THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES # # It is highly advisable to create own systemd services or udev rules # to run scripts during boot instead of using this file. # # In contrast to previous versions due to parallel execution during boot # this script will NOT be run after all other services. # # Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure # that this script will be executed during boot. # touch /var/lock/subsys/local 中文意思如下： # 添加此文件是为了兼容。 # 强烈建议创建自己的systemd服务或udev规则，以便在引导期间运行脚本，而不是使用此文件。 # 与以前版本不同，由于在引导期间并行执行，此脚本不会在所有其他服务之后运行。 # 请注意,必须运行`chmod +x /etc/rc.d/rc.local`，以确保在引导期间执行此脚本。 明白了吧。 虽然Linux强烈建议采用自定义的系统服务实现开机自启动程序，不过我认为在rc.local中配置开机启动程序也是一个不错的方法，因为rc.local的配置更简单明了，所以仍被广泛的使用。 3、rc.local文件的配置 rc.local本质上是一个shell脚本文件，可以把启动时需要执行的命令写在里面，启动时将按顺序执行。 接下来我们来测试它。 1）在rc.local中添加以下脚本。 /usr/bin/date >> /tmp/date1.log # 把当前时间追加写入到/tmp/date1.log中。 /usr/bin/sleep 10 # 睡眠10秒。 /usr/bin/date >> /tmp/date2.log # 把当前时间追加写入到/tmp/date2.log中。 2）修改/etc/rc.d/rc.local的可执行权限。 chmod +x /etc/rc.d/rc.local 3）重启服务器。4）查看日志文件/tmp/date1.log和/tmp/date2.log的内容。 4、应用经验 1）rc.local脚本在操作系统启动时只执行一次。 2）环境变量的问题。 在rc.local脚本中执行程序时是没有环境变量的，如果您执行的程序需要环境变量，可以在脚本中设置环境变量，也可以用su切换用户来执行，例如： su - oracle -c \"sqlplus scott/tiger @/tmp/test.sql\" 以上命令的含义就是以oracle用户登录再执行sqlplus命令。 3）不要让rc.local挂起。 rc.local是一个脚本，是按顺序执行的，执行完一个程序后才会执行下一个程序，如果某程序不是后台程序，就应该加&让程序运行在后台，否则rc.local会挂起。 可以用以下脚本来测试，rc.local的内容如下： /usr/bin/date >> /tmp/date1.log # 把当前时间追加写入到/tmp/date1.log中。 /usr/bin/sleep 100 # 睡眠100秒。 /usr/bin/date >> /tmp/date2.log # 把当前时间追加写入到/tmp/date2.log中。 如果采用了以上脚本，Linux系统在启动完成100后，才会出现以下的登录界面。 转自:https://www.freecplus.net/bef1eee920df4a66bbcabdece16d58dc.html "},"pages/SSH免密登录.html":{"url":"pages/SSH免密登录.html","title":"SSH免密登录","keywords":"","body":"SSH ssh:secure shell,protocol,22/tcp,安全的远程登录具体的软件实现:OpenSSH:ssh协议的开源实现,CentOS默认安装相关包:openssh openssh-clientsopenssh-server 工具:基于c/s架构Client:ssh,scp,sftp,sloginWindows客户端:xshell,putty,securecrt,sshsecureshellclientServer:sshd 对称加密: 非对称加密 基于密钥的登录方式1.首先在客户端生成一对密钥 (ssh-keygen)2.并将客户端的公钥ssh-copy-id拷贝到服务器3.当客户端再次发送一个连接请求,包括ip、用户名4.服务端得到客户端的请求后,会到authorized_keys中查找,如果有响应的ip和用户,就会随机生成一个字符串,例如:acdf5.服务端将使用客户端拷贝过来的公钥进行加密,然后发送给客户端6.得到服务端发送的消息后,客户端会使用私钥进行解密,然后将解密后的字符串发送给服务端7.服务端接受到客户端发来的字符串后,跟之前的字符串进行对比,如果一致,就允许免密码登录 xshell配置ssh免密登录 ssh登录提供两种认证方式：口令(密码)认证方式和密钥认证方式。其中口令(密码)认证方式是我们最常用的一种，这里介绍密钥认证方式登录到linux的方法。使用密钥登录分为3步：1、生成密钥（公钥与私钥）；2、放置公钥(Public Key)到服务器~/.ssh/authorized_key文件中；3、配置ssh客户端使用密钥登录。 一、生成密钥公钥（Public key）与私钥(Private Key)打开xshell中的工具下的新建用户密钥生成导向在“密钥类型”项选择“RSA”公钥加密算法，“密钥长度”选择为“2048”位密钥长度填写密钥名称，密码（密码等下会用到），确认密码，下一步，复制公钥里面的内容点击“保存文件为”按钮，将公钥(Public key)保存到磁盘，文件名为“id_rsa_2048.pub”，备用。 二、放置公钥(Public Key)到服务器1、方法一（我使用的是阿里云服务器，所以我直接登陆到控制台）打开控制台云服务里面的产品与服务，点击创建密钥对选择导入已有的密钥对，填写密钥对名称，把刚才复制的公钥内容粘贴进来，确定把密钥添加到主机中重启服务器 2、方法二登录到服务器，进入到“/root/.ssh/”目录，运行rz命令(如果没有rz命令，运行yum install lrzsz安装)，将key.pub发送到服务器，然后运行如下命令，将公钥(Public Key)导入到“authorized_keys”文件： [root@localhost ~]# cd /root/.ssh/ [root@localhost .ssh]# rz rz waiting to receive. [root@localhost .ssh]# cat me.pub >> authorized_keys [root@localhost .ssh]# chmod 600 authorized_keys [root@localhost .ssh]# ls authorized_keys known_hosts me.pub [root@localhost .ssh]# cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA4VCOWFrARc1m3MfEAL50v2Z2siavO3Ijpr/LZ00EZah8EjfZhqjAc/agkljyXmNGpVDpRdtlYco8h3P5vegXOEgKcX74fDYm0vNdVABVD1XSD8ElNyLTCCNk7rZJbi3htJox3Q1n0vnMmB5d20d9occkAx4Ac94RWNS33EC5CszNTMgAIn+uZl0FlQklS1oSyWFahSTWyA6b33qG7Y5E4b6J/caObnPx6EgtBrgi97gXJHZWyYlGrpWmUuhPqs5XToRB08CVxAyzewtq1MXv0p+Po4L1pbHLRf+TSoZ5RSBZZjY4/JMAzdXHNtnAyO0j0VNGbBXKUcNSAHZ 三、配置ssh客户端使用密钥登录。打开xshell，填写主机地址，选择22端口 方法选择public key，用户名一般为root,选择用户密钥，填写刚才设置的密码 由图可见，登陆成功 "},"pages/Systemd日志管理journal和journalctl使用.html":{"url":"pages/Systemd日志管理journal和journalctl使用.html","title":"Systemd日志管理journal和journalctl使用","keywords":"","body":"systemd日志管理journal journal:systemd自己提供的日志工具和服务配置文件:/etc/systemd/journald.conf #journal日志服务 systemctl list-units | grep systemd.journald.service #systemd将日志信息交给journal服务,journal服务将日志存放到RAM(内存虚拟文件系统:tmpfs,目录挂载在/run下) systemd --> journal --> RAM [root@ser1 cron.daily]# df -h 文件系统 容量 已用 可用 已用% 挂载点 devtmpfs 1.9G 0 1.9G 0% /dev tmpfs 1.9G 0 1.9G 0% /dev/shm tmpfs 1.9G 12M 1.9G 1% /run #操作系统发生重启后,这个目录下的内容就会丢失,这里面是临时进行缓存来使用的 tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup /dev/sda2 17G 2.7G 14G 17% / /dev/sda1 976M 112M 798M 13% /boot tmpfs 378M 0 378M 0% /run/user/0 日志级别 journalctl查看粗体的日志,日志级别就是在notice或warning级别 journalctl查看红色的日志,日志级别在err级别以上的,也就是可能造成系统性的危害的日志 journalctl查看内存日志 journalctl 可以查看内存日志,这里我们看看常用的指令 #查看全部 journalctl #查看最新3条 journal -n 3 #查看起始时间到结束时间的日志(可加日期) journalctl --since 20:50 --until 21:00:10 #今天0点开始,到当前执行这条命令时间为止的日志 journalctl --since today #查看今天0点到截止为30分钟之前的日志 journalctl --since today --until \"30 min ago\" #查看今天0点到截止为2个小时之前的日志 journalctl --since today --until \"2 hour ago\" #查看err级别的日志 journalctl -p err #查看err级别到alert级别的日志 journalctl -p err..alert #日志详细内容 journalctl -o verbose #查看某个服务的日志 journalctl -u sshd.service #查看包含这些参数的日志,top命令可以查看PID和COMMAND journalctl _PID=1245 _COMM=sshd #或者: journalctl | grep sshd #和tail /var/log/messages -f 里面的-f一样,实时的发现日志,有日志则刷新 journalctl -f #查看操作系统启动的时候的日志 journalctl -b #查看root用户的相关日志,这个可以根据/etc/passwd查看某个用户的UID journalctl _UID=0 注意:journalctl 查看的是内存日志,重启清空演示案例:使用journalctl | grep sshd 来看看用户登录清空,重启系统,再次查询,看看日志有生命变化没有 "},"pages/TCP_IP协议总结.html":{"url":"pages/TCP_IP协议总结.html","title":"TCP_IP协议总结","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一. 应用层 模拟和百度进行通讯: 二.传输控制层(TCP/IP) 三.网络层和数据链路层 IP地址 & 子网掩码得到网络号 在传输过程中,数据包中究竟需要存储目标ip的地址还是下一跳的地址呢? 查看arp表中的内容: 删除网关的mac地址,再去请求外网: 手动添加网关,理解网关的含义 补充 scoket其实就是一个(fd)文件描述符指向的一个四元组 程序和内核间调用 LVS下TCP通信和DDos简单原理 一. 应用层 模拟和百度进行通讯: 1.建立连接(内核去做的) exec 8<> /dev/tcp/www.baidu.com/80 # 含义: /dev/tcp/www.baidu.com/80:与百度的80端口通过socket技术建立了tcp连接,用8去指向了这个连接,从连接中可以拿到输入流和输出流 # 8<> 相当于是一个输入输出流的channel(通道),8就是文件描述符. # exec [-cl] [-a 名称] [命令 [参数 ...]] [重定向 ...] 这个用法会用指定命令去替换shell.只不过上面那句话中没有[命令]这个选项,只是添加了一个重定向（没有用任何给出的cmd覆盖自己,但是给出了重定向的定义语法增加了socket) # 可以通过cd /proc/$$/fd 中找到这个重定向,ll查看 # $$：就是当前程序的进程 ,fd文件描述符. 可以echo $$：就是当前程序的进程号(这里一般是shell窗口的进程号). shell(bash)就是一个守护进程,当用ssh登录的时候fork出一个bash的进程,使用exec ls -l替换了这个进程比如exec ls -l,用ls -l命令当前shell,因为ls -l就是启动->打印->退出,替换掉shell之后,就会造成程序退出了 2.http通讯(用户去做) echo -e \"GET / HTTP/1.0\\n\" 1>& 8　　 #/表示主页,-e能够让\\n得到转义,1表示echo的标准输出, 后面是重定向到前面定义的8中. 注意这里, > 到文件; >& 到文件描述符. 3.读取百度回复的消息(用户去做的) cat 0 文件描述符:8指向了一个socket,可以通过fd:8拿到socket输入输出流 我们可以看一下,redis进程下也有输入输出,文件描述符的信息 二.传输控制层(TCP/IP) 1.TCP:面向连接, 可靠的传输. 为什么握手要三次?socket的IO通讯是双向的,两对syn+ack,分别表示客户端确认自己发送的消息服务端能够收到,以及服务端发送的客服端能够收到. 三次握手之后,双方开辟了资源. 2.linux中查看网络状态 ssh:secure shell,安全外壳协议,应用层协议.ftp,telnet本质上是不安全的. 这里的Local Address就是代表的你说连接到的linux服务器,而Foreign Address表示对端地址.上面的是每个socket对应一个进程,而多个socket对应一个进程就是 多路复用器 (select, poll, epoll). 3.抓取访问百度过程(通过curl www.baidu.com)的数据包,验证3次握手和四次分手.其中[S]代表的是SYN,[.]代表的是ACK.[F]代表FIN. 中间的部分表示数据传输,一开始是1440字节,然后客户端给一个确认;接着是1341字节,然后客户端给一个确认.(因为数据包的大小是有限制的,比如图中说的[mss 1460]) 三.网络层和数据链路层 IP地址 & 子网掩码得到网络号 理解路由表中表示的含义:如果要访问百度的ip,拿百度的ip去和路由表中的子网掩码进行按位与操作, 得到的结果跟路由表中的Destination列的值去进行匹配.这里只有和0.0.0.0去按位与得到0.0.0.0可以与第一条匹配上,这个时候就去找对应的Gateway,这里是192.168.121.2.这是个路由器网关,路由器上有自己的路由表,也有它的下一跳地址,就这么下一跳,下一跳...直到找到百度的地址.... 而访问本局域网中的ip(192.168.121.11),和255.255.255.0按位与之后,得到的是网络号,它对应的网关是0.0.0.0,表示不需要通过网关转发(不需要下一跳,局域网直连). 在传输过程中,数据包中究竟需要存储目标ip的地址还是下一跳的地址呢? 实际上存储的是目标ip,只不过在数据包外层要封装下一跳的mac地址 查看arp表中的内容: arp -a 删除网关的mac地址,再去请求外网: #首先在一个shell窗口抓包 tcpdump -nn -i ens33 port 80 or arp #-X:可以看到详细的抓包信息 tcpdump -nn -X -i ens33 port 80 or arp #另外一个shell窗口删除mac地址,在请求baidu arp -d 192.168.121.2 && curl www.baidu.com 抓包结果:发现会先进行arp请求,找到网关的mac地址,再去进行三次握手和四次分手的过程. 手动添加网关,理解网关的含义 假如原先主机A(192.168.121.4)和主机B(192.168.121.1)是同一个网段,此时它们两个是可以互相访问的.现在在主机B上添加一个ip地址ipB2,比如说是192.168.88.88(通过ifconfig ens33:0 192.168.88.88 netmask 255.255.255.0 up),此时主机A是访问不到该地址的.因为主机A的路由表中并没有到此地址的路由.如下图所示,是主机A的路由表,在ping 192.168.88.88时,会对子网掩码进行与运算,匹配到192.168.121.2(下一跳地址),但是121.2并不能够找到88.88,所以无法去访问. 在主机A中可以通过人为添加路由的方式,来找到88.88地址.方式如下: 告诉主机A,如果要访问88.88可以通过121.1. 补充 scoket其实就是一个(fd)文件描述符指向的一个四元组 只要满足ip:port+ip:port的唯一性,这个连接就能被创建出来 程序和内核间调用 LVS下TCP通信和DDos简单原理 "},"pages/TCP_UDP结构.html":{"url":"pages/TCP_UDP结构.html","title":"TCP_UDP结构","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 TCP数据包结构 UDP数据包结构 IP数据包结构 TCP数据包结构 UDP数据包结构 "},"pages/VMware虚拟机克隆CentOS7并分别设置静态IP.html":{"url":"pages/VMware虚拟机克隆CentOS7并分别设置静态IP.html","title":"VMware虚拟机克隆CentOS7并分别设置静态IP","keywords":"","body":"一：VMware虚拟机克隆CentOS7 这里介绍下VMware下有三种网络连接模式 birdged（桥接）桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。 NAT(网络地址转换)NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在VMware提供的一个虚拟网络。 Host-only(仅主机)在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。 主要讨论桥接和NAT模式NAT和桥接的比较:(1) NAT模式和桥接模式虚拟机都可以上外网。 (2) 由于NAT的网络在VMware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。 (3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。 使用NAT模式下面进行操作1.准备，装好一台镜像安装好的虚拟机，如下图中的CentOS7-S-1： 2.在左边的CentOS7-S-1上面右键–>管理–>克隆，出现如下页面： 3.点击下一步，如下图： 对应自己的需求选择，如下图 在这里，我选择的完整克隆，点击下一步，如下图：最后点击完成就创建好了 设置克隆的CentOS7-S-xx的静态Ip1.在新创建的虚拟机上进行如下操作，如下图： 第一步为鼠标右击，主要目的是第五步，避免克隆导致mac地址重复，产生冲突，完成后进行下一步2.如下图，以此进行右键编辑–>选择虚拟网络编辑器–>,弹开的页面如下图，以此进行操作：记住这里的网关地址 为系统设置一个静态ip，方便日后使用远程连接工具vim /etc/sysconfig/network-scripts/ifcfg-ens33 重启网络服务 CentOS7中使用如下命令 systemctl restart network.service 验证网络配置是否成功 ping 一下 www.baidu.com 或者 www.qq.com ping通了，就说明NAT模式下的网络配置成功了！ 完结！ "},"pages/Vmware虚拟机问题解决方案.html":{"url":"pages/Vmware虚拟机问题解决方案.html","title":"Vmware虚拟机问题解决方案","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 运行虚拟机系统蓝屏 2. 卸载Vmware步骤 3. 运行虚拟机时报错VT-x Vmware虚拟机问题解决方案 1. 运行虚拟机系统蓝屏 可能的原因有两个: 1). 虚拟机所在磁盘的空间不足 ; -------> 清理磁盘空间 。 2). 操作系统版本高, 需要适配新版本的Vmware ; ------> 卸载Vmware15版本, 安装Vmware16版本 。 2. 卸载Vmware步骤 1). 卸载已经安装的VMware 弹出确认框, 点击\"下一步\": 下一步之后, 选择删除: 选择下一步,继续删除: 点击 \"删除\" 按钮: 卸载完成: 同时, 进入磁盘目录, 查看VMware 的安装目录, 查看文件夹是否为空: 退出到VMware这层目录, 右键删除\"VMware\"文件夹，删除完成: 2). 清理注册表 卸载Vmware之后, 一定一定要清理Vmware的注册表信息 ; A. 按住Windows + R , 在弹出框中输入 \"regedit\" 调出注册表 B. 打开“HKEY_CURRENT_USER”文件夹，找到“Software”文件夹并打开 C. 找到“VMware.Inc”，右键删除 3). 安装VMware16版本 链接：https://pan.baidu.com/s/1P_W69FDeJphQUO1_X4PIFg 提取码：zdpo 下载16版本的软件, 并安装 ; 3. 运行虚拟机时报错VT-x 这个是由于英特尔的虚拟化技术, 没有开启, 需要进入系统的BIOS界面 , 开启英特尔的虚拟化技术 ; 不同的电脑型号 , 进入BIOS界面的方式不同, 需要百度查询一下自己电脑的型号 , 如何进BIOS ; windows10系统可以参考: https://blog.csdn.net/biu_code/article/details/107504627 "},"pages/window下面git公钥的配置.html":{"url":"pages/window下面git公钥的配置.html","title":"window下面git公钥的配置","keywords":"","body":"github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。　　由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以必须要让github仓库认证你SSH key，在此之前，必须要生成SSH key。　　 　　以下给出ｗindows中git bash关于ssh key的创建与配置。　　 步骤1　　创建SSH Key。在windows下查看【c盘->用户->自己的用户名->.ssh】下是否有id_rsa、id_rsa.pub文件，如果没有需要手动生成。　　打开git bash，在控制台中输入以下命令。 ssh-keygen -t rsa -C \"your_email@xx.com\" 后面的your_email@xx.com改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。 步骤2　　先打开id_rsa.pub，文本编辑器如Notepad++等都可以，注意一定要按照打开时的源格式【包括开头”ssh..至.xx.com”】复制里面的key；接着登录github。打开Personal settings->SSH and GPG keys， 点击右上角 New SSH key，把复制的id_rsa.pub里面的key按源格式粘贴到 key输入框中，再为当前的key起一个title来区分每个key。 步骤３　　为了验证是否成功，在git bash下输入： ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes回车再输入密码后就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 　　如果出现问题，可以通过以下指令找到哪一步出问题 ssh -v root@IP地址(github的为192.30.252.129) "},"pages/文件描述符.html":{"url":"pages/文件描述符.html","title":"文件描述符","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 概念 实例 stdin(0) stdin(1) stderr(2) 2>&1 自定义文件描述符 介绍 文件描述符是与文件输入、输出相关联的整数，在编写脚本时会经常使用标准的文件描述符来将内容重定向输出，0、1、2是文件描述符（分别对应stdin、stdout、stderr），, >>叫做操作符。 概念 stdin(0):标准输入,这个概念有点不太容易理解比如：1.使用 stdout(1)：标准输出;这是默认选项。使用方法:1>等价于> 或者 1>>等价于>>，;如果想使用其它文件描述符，必须将文件描述符放在操作符之前。 stderr(2):标准错误,使用方法2>或者2>>，标准错误可以将错误信息插入到文件而不在终端显示. :从文件中读取内容。 >:将内容插入到文件,每次插入前都会清空文件内容。 >>:将内容插入到文件, 将内容追加到现有文件的末尾。 实例 生成测试数据 [root@iZbp137rluneva6nal2s2lZ ~]# echo 'hello world' >test1 [root@iZbp137rluneva6nal2s2lZ ~]# cp test1 test2 [root@iZbp137rluneva6nal2s2lZ ~]# chmod 000 test2 [root@iZbp137rluneva6nal2s2lZ ~]# ll test2 ---------- 1 root root 12 Apr 20 09:08 test2 stdin(0) 1.从文本中读取内容 cat 2.将读取到的内容通过管道传输给下一个命令 [root@iZbp137rluneva6nal2s2lZ ~]# cat test1 | tr -t 'a-z' 'A-Z' > test.new [root@iZbp137rluneva6nal2s2lZ ~]# cat test.new HELLO WORLD stdin(1) 将内容重定向到文件 echo \"this is stdout 1\" >std1 追加内容到文件 echo \"this is stdout 11\" >>std1 stderr(2) 遇到报错的时候终端会显示错误，可以将将错误信息写入文件不让终端显示 同时将stderr和stdout信息都插入到文件，使用& 将错误信息定向标准输出 echo \"name\" 2>&1 >> a #或者 echo \"name\" >> a 2>&1 2>&1 看以前的日志的脚本都会有command > log.log 2>&1 一直都不知道后面的2>&1是什么意思最近在看《shell脚本学习指南》，看到文件描述符一章的时候，再次看到了这个,一时没有想明白2>&1这个符号是什么意思。文件描述符0，1，2 是shell 默认的值 描述符 含义 0 标准输入 1 标准输出 2 标准错误输出 为了更直接的了解 2>&1 下面举几个例子 ls not-exist-dir #屏幕输出：ls: cannot access not-exist-dir: No such file or directory ls not-exist-dir > err.log #屏幕输出：ls: cannot access not-exist-dir: No such file or directory #查看err.log 为空 ls not-exist-dir > err.log 2>&1 #屏幕没有输出 #查看err.log ls: cannot access not-exist-dir: No such file or directory 咦为什么ls not-exist-dir > err.log并没有把ls: cannot access not-exist-dir: No such file or directory 这句错误输出到err.log中原因是这样的ls not-exist-dir > err.log = ls not-exist-dir 1> err.log把标准输出(文件描述符1)重定向 err.log 文件中但是 ls: cannot access not-exist-dir: No such file or directory 这句走的是标准错误输出(文件描述符2)所以不会输出到err.log中去 2>&1 把标准错误输出重定向到文件描述符1中去也就是err.log文件最后command > err.log 2>&1 就能把标准的输出和标准错误输出都输出到err.log中去了 自定义文件描述符 系统中实际有12个文件描述符，可以任意使用文件描述符3-9自定义文件描述符也需要用到exec;,>>当调用自定义的描述符时需要在自定义的描述符前加上&。 1.自定义stdin,将3定义为stdin从文件中读取内容，然后就可以调用3了，调用3和直接调用文件结果是一样的，有点类似赋值。 echo \"hello world\" > test1 exec 3 2.自定义stdout，测试结果发现在自定义描述符中使用>往文件中重复写数据并不会清空之前的内容，但是在标准的描述符中是会清空再写入的。 [root@iZbp137rluneva6nal2s2lZ ~]# exec 4>std4 [root@iZbp137rluneva6nal2s2lZ ~]# echo 'message1' >&4 [root@iZbp137rluneva6nal2s2lZ ~]# cat std4 message1 [root@iZbp137rluneva6nal2s2lZ ~]# echo 'message2' >&4 [root@iZbp137rluneva6nal2s2lZ ~]# cat std4 message1 message2 [root@iZbp137rluneva6nal2s2lZ ~]# exec 5>>std5 [root@iZbp137rluneva6nal2s2lZ ~]# echo 'test'>>&5 -bash: syntax error near unexpected token `&' [root@iZbp137rluneva6nal2s2lZ ~]# echo 'test'>&5 [root@iZbp137rluneva6nal2s2lZ ~]# cat std5 test [root@iZbp137rluneva6nal2s2lZ ~]# echo 'test2'>&5 [root@iZbp137rluneva6nal2s2lZ ~]# cat std5 test test2 3.自定义stdin、stdout结合linux有一个特殊的文件/dev/tcp,打开这个文件就类似于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。 exec 9<> /dev/tcp/www.baidu.com/80 #9:文件描述符 类比 java中的变量引用 #<>:输入和输出 #9<>:代表9引入了输入输出流 #/dev/tcp/www.baidu.com/80:输出的路径 echo -e \"GET / HTTP/1.1\\n\" 1>& 9 #-e:代表使\\n转义符生效 #1>&9:标准输出到自定义文件描述符9 cat 0 完整的示例: [root@iZbp137rluneva6nal2s2lZ ~]# exec 9<> /dev/tcp/www.baidu.com/80 [root@iZbp137rluneva6nal2s2lZ ~]# echo -e 'GET / HTTP/1.1\\n' 1>&9 [root@iZbp137rluneva6nal2s2lZ ~]# cat 0 以下和上面例子一样,知识不指定输入输出的描述符:0(标准输入,因为:就是代表标准输出,可以省略) exec 8<> /dev/tcp/www.baidu.com/80 echo -e 'GET / HTTP/1.0\\n' >& 8 cat "},"pages/最小化安装centos7.9.html":{"url":"pages/最小化安装centos7.9.html","title":"最小化安装centos7.9","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Relative paths are relative to the cachedir (and so works for users as well as root). exclude=.gov, facebook include_only=.nl,.de,.uk,.ie 3.yum install Could not retrieve mirrorlist 解决 下载Minimal版本,下载地址:http://mirrors.163.com/ yum install -y wget yum install -y net-tools yum install -y vim 关闭防火墙、关闭selinux 装完做快照 常见问题 1.最好装的时候就设置网卡开机自启动 2.使用yum 安装时出现 ： Loaded plugins: fastestmirror 使用yum 安装是出现 ： Loaded plugins: fastestmirror [root@localhost yum.repos.d]# yum –y install httpd httpd-devel Loaded plugins: fastestmirror 解决办法： 1.修改插件配置文件 [root@localhost yum.repos.d]# vim /etc/yum/pluginconf.d/fastestmirror.conf [main] enabled=0 //由 1 改成0 ，禁用该插件 verbose=0 always_print_best_host = true socket_timeout=3 # Relative paths are relative to the cachedir (and so works for users as well # as root). hostfilepath=timedhosts.txt maxhostfileage=10 maxthreads=15 #exclude=.gov, facebook #include_only=.nl,.de,.uk,.ie 2.修改yum 配置文件 [root@localhost yum.repos.d]# vim /etc/yum.conf 9 plugins=0 //不使用插件 清除缓存并重新构建yum 源 [root@localhost yum.repos.d]# yum clean all [root@localhost yum.repos.d]# yum makecache 使用yum 重新安装 3.yum install Could not retrieve mirrorlist 解决 这个是个网络问题1.能不能ping通外网ip,如百度的某一个ip 能不能ping 通域名, 能不能ping通宿主主机首先保证这三个可以,即自己的网络没有问题,ping不同主机可能是因为主机的防火墙问题 切换镜像使用阿里云的yum镜像 我是发现网卡没启用,用vi /etc/sysconfig/network-script/ifcfg-ens33,设置了网卡信息，重启网卡就好了 "},"pages/查看服务器状态工具.html":{"url":"pages/查看服务器状态工具.html","title":"查看服务器状态工具","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 系统整体运行状态查看 top/htop 系统进程状态查看 ps/bashtop 查看系统内存状态 vmstat/smem/free -m 系统磁盘IO状态查看 iotop/iostat 网络状态查看 查看服务器状态有以下几个方面: CPU状态、内存状态、磁盘状态、网络状态、进程状态 系统整体运行状态查看 top/htop 系统进程状态查看 ps/bashtop ps -aux ps -ef 查看系统内存状态 vmstat/smem/free -m #smem需要安装,需要epel源 #显示每个进程占用内存多少,-k:显示具体单位比如mb,重点关注RSS列(物理内存大小) smem -k #降序排列 smem -k -r RSS 系统磁盘IO状态查看 iotop/iostat #每个进程的io状态,可以清楚的看到哪个进程磁盘读或写占用情况 iotop #磁盘的读写状态 iostat #每3秒钟输出一次,总共输出5次 iostat 3 5 网络状态查看 yum -y install iftop iftop -i ens33 -n -P 安装 tcptrack 工具，查看各个连接的流量情况 yum install -y libpcap-devel libpcap wget http://packages.psychotic.ninja/6/base/x86_64/RPMS/tcptrack-1.4.2-9.el6.psychotic.x86_64.rpm rpm -ivh tcptrack-1.4.2-9.el6.psychotic.x86_64.rpm tcptrack -i ens33 安装 nethogs 工具，查看各个进程的流量情况 yum -y install nethogs nethogs 查看某个进程的连接数: # 查看Mysql 端口的连接数 netstat -ant|grep -i \"3306\"| grep ESTABLISHED | wc -l "}}